import type {
  AcadiaQualityControlLotDto,
  AcadiaQualityControlRunRecordDto,
  AlertActionDto,
  BackupMetadataDto,
  BackupMetadataWrapperDto,
  BarcodeValidationRequestDto,
  BarcodeValidationResponseDto,
  BootItemsDto,
  BreedDto,
  CatOneConfigurationDto,
  CdDriveStatusDto,
  ClientDto,
  ClientSaveEditDto,
  ConnectedDeviceHistoryDto,
  ConnectionApprovalRequestDto,
  CrimsonInstalledReagentDto,
  CrimsonPropertiesDto,
  CrimsonQcBarcodeSaveRequestDto,
  CrimsonQcBarcodeValidateRequestDto,
  CrimsonQcBarcodeValidateResponseDto,
  CrimsonReplaceReagentDto,
  CytologyImageDto,
  DetailedInstrumentStatusDto,
  DoctorDto,
  DoctorSaveEditDto,
  EventLogDto,
  ExecuteInstrumentRunDto,
  ExecuteLabRequestDto,
  ExecutePimsRequestDto,
  ExecuteQualityControlRunResponseDto,
  FeatureFlagActivateDto,
  FlatFileDto,
  GenderDto,
  GraphDataDto,
  IhdigClientSettings,
  InstrumentAlertDto,
  InstrumentLoggingPropertyDto,
  InstrumentStartupResponseDto,
  InstrumentStatusDto,
  InstrumentUpgradeNotificationDto,
  IvlsRouterDto,
  LabRequestDto,
  LabRequestRecordDto,
  LaserCyteProcedureDto,
  LaserCytePropertiesDto,
  LocationDto,
  ManualCrpResultDto,
  ManualUaResultDto,
  Message,
  MessageCounts,
  NotificationContentDto,
  OffsetsDto,
  PatientDto,
  PatientMatchProfileDto,
  PatientSaveEditDto,
  PatientWeightDto,
  PendingPimsRequestMatchDto,
  PimsRequestDto,
  PimsXmlMessageDto,
  QualityControlBarcodesDto,
  QualityControlBarcodeSetDto,
  QualityControlDto,
  QualityControlRunRecordDto,
  QualityControlRunRequestDto,
  QualityControlTrendDto,
  RecentResultDto,
  RefClassDto,
  RefLabResultDto,
  RegistrationKeyMissionPayload,
  RemovableDriveDto,
  RestoreFileDto,
  ResultsTrendingDto,
  RunningInstrumentRunDto,
  RunningLabRequestDto,
  SampleTypeSupportDto,
  SettingDto,
  SmartQCRunRecordDto,
  SmartServiceApiConfigurationDto,
  SmartServiceEulaDto,
  SmartServicePropertiesDto,
  SmartServicePropertyDto,
  SnapDeviceDto,
  SpeciesDto,
  SuggestionDialogCreateNewPatientDto,
  SuggestionDialogShownDto,
  SuggestionDialogUserMatchDto,
  SupportedRunTypeValidationDto,
  SystemDto,
  TenseiQcBarcodeSaveRequestDto,
  TenseiQcBarcodeValidateRequestDto,
  TenseiQcBarcodeValidateResponseDto,
  TheiaMatchingRunResultDto,
  TimeConfigurationDto,
  TimeZoneDto,
  UndoMergeRunsDto,
  UpgradeAvailableDto,
  UpgradeLetterDto,
  UpgradePropertiesDto,
  UpgradeRequestDto,
  UpgradeResultDto,
  UpgradeRouterStatusDto,
  UpgradeStatusDto,
  UriSedImageDto,
  UriSysDxQualityControlRunRecordDto,
  UsbUpgradeCopyResultDto,
  UserEnteredSnapResultDto,
  UserInputRequestDto,
  VcpActivationRequestDto,
  VcpConfigurationDto,
  ViewPointActivationStatusDto,
  WizardDataDto,
  WorkRequestStatusDto,
} from "./ivls-api";
import url from "url";

const BASE_PATH = "/labstation-webapp/api";

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: FetchOptions): Promise<any>;
}

let _fetcher: FetchAPI | undefined;
const portableFetch: FetchAPI = (_url, _init) => {
  if (!_fetcher) {
    throw new Error("IVLS API Services must be initialized");
  }
  return _fetcher(_url, _init);
};

export const initializeApiServices = (fetcher: FetchAPI) => {
  console.log("Initializing IVLS API services");
  _fetcher = fetcher;
};

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: FetchOptions;
}

export interface FetchOptions {
  body?: any;
  headers?: any;
  method?: string;
  query?: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration?: Configuration;
  protected basePath: string;
  protected fetch: FetchAPI;

  constructor(
    configuration?: Configuration,
    basePath: string = BASE_PATH,
    fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    this.fetch = fetch;
    this.basePath = configuration?.basePath || basePath;
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  constructor(public field: string, msg?: string) {
    super(msg);
    this.name = "RequiredError";
  }
}

export interface ConfigurationParameters {
  apiKey?: string | ((name: string) => string);
  username?: string;
  password?: string;
  accessToken?: string | ((name: string, scopes?: string[]) => string);
  basePath?: string;
}

export class Configuration {
  /**
   * parameter for apiKey security
   * @param name security name
   * @memberof Configuration
   */
  apiKey?: string | ((name: string) => string);
  /**
   * parameter for basic security
   *
   * @type {string}
   * @memberof Configuration
   */
  username?: string;
  /**
   * parameter for basic security
   *
   * @type {string}
   * @memberof Configuration
   */
  password?: string;
  /**
   * parameter for oauth2 security
   * @param name security name
   * @param scopes oauth2 scope
   * @memberof Configuration
   */
  accessToken?: string | ((name: string, scopes?: string[]) => string);
  /**
   * override base path
   *
   * @type {string}
   * @memberof Configuration
   */
  basePath?: string;

  constructor(param: ConfigurationParameters = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
  }
}

/**
 * AcadiaApi - fetch parameter creator
 * @export
 */
export const AcadiaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Post an upgrade notification to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {InstrumentUpgradeNotificationDto} [body] The notification details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUpgradeNotification(
      serialNumber: string,
      body?: InstrumentUpgradeNotificationDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling postUpgradeNotification."
        );
      }
      const localVarPath =
        `/acadia/upgrade/notification/{serialNumber}`.replace(
          `{${"serialNumber"}}`,
          encodeURIComponent(String(serialNumber))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentUpgradeNotificationDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request fluid pack status
     * @param {number} instrumentId The instrument ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFluidPackStatus(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestFluidPackStatus."
        );
      }
      const localVarPath = `/acadia/{instrumentId}/fluidPacks`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post an upgrade letter to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {any} [file] The zip file to upload
     * @param {any} [signature] The signature file for the zip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMessageCenterZip(
      serialNumber: string,
      file?: any,
      signature?: any,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling uploadMessageCenterZip."
        );
      }
      const localVarPath =
        `/acadia/upgrade/notification/{serialNumber}/letter`.replace(
          `{${"serialNumber"}}`,
          encodeURIComponent(String(serialNumber))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (file !== undefined) {
        localVarFormParams.set("file", file as any);
      }

      if (signature !== undefined) {
        localVarFormParams.set("signature", signature as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AcadiaApi - functional programming interface
 * @export
 */
export const AcadiaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Post an upgrade notification to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {InstrumentUpgradeNotificationDto} [body] The notification details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUpgradeNotification(
      serialNumber: string,
      body?: InstrumentUpgradeNotificationDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaApiFetchParamCreator(
        configuration
      ).postUpgradeNotification(serialNumber, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request fluid pack status
     * @param {number} instrumentId The instrument ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFluidPackStatus(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaApiFetchParamCreator(
        configuration
      ).requestFluidPackStatus(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Post an upgrade letter to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {any} [file] The zip file to upload
     * @param {any} [signature] The signature file for the zip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMessageCenterZip(
      serialNumber: string,
      file?: any,
      signature?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaApiFetchParamCreator(
        configuration
      ).uploadMessageCenterZip(serialNumber, file, signature, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AcadiaApi - factory interface
 * @export
 */
export const AcadiaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Post an upgrade notification to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {InstrumentUpgradeNotificationDto} [body] The notification details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUpgradeNotification(
      serialNumber: string,
      body?: InstrumentUpgradeNotificationDto,
      options?: any
    ) {
      return AcadiaApiFp(configuration).postUpgradeNotification(
        serialNumber,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request fluid pack status
     * @param {number} instrumentId The instrument ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFluidPackStatus(instrumentId: number, options?: any) {
      return AcadiaApiFp(configuration).requestFluidPackStatus(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Post an upgrade letter to IVLS
     * @param {string} serialNumber The serial number of the instrument that was upgraded
     * @param {any} [file] The zip file to upload
     * @param {any} [signature] The signature file for the zip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadMessageCenterZip(
      serialNumber: string,
      file?: any,
      signature?: any,
      options?: any
    ) {
      return AcadiaApiFp(configuration).uploadMessageCenterZip(
        serialNumber,
        file,
        signature,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AcadiaApi - object-oriented interface
 * @export
 * @class AcadiaApi
 * @extends {BaseAPI}
 */
export class AcadiaApi extends BaseAPI {
  /**
   *
   * @summary Post an upgrade notification to IVLS
   * @param {string} serialNumber The serial number of the instrument that was upgraded
   * @param {InstrumentUpgradeNotificationDto} [body] The notification details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaApi
   */
  public postUpgradeNotification(
    serialNumber: string,
    body?: InstrumentUpgradeNotificationDto,
    options?: any
  ) {
    return AcadiaApiFp(this.configuration).postUpgradeNotification(
      serialNumber,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request fluid pack status
   * @param {number} instrumentId The instrument ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaApi
   */
  public requestFluidPackStatus(instrumentId: number, options?: any) {
    return AcadiaApiFp(this.configuration).requestFluidPackStatus(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Post an upgrade letter to IVLS
   * @param {string} serialNumber The serial number of the instrument that was upgraded
   * @param {any} [file] The zip file to upload
   * @param {any} [signature] The signature file for the zip
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaApi
   */
  public uploadMessageCenterZip(
    serialNumber: string,
    file?: any,
    signature?: any,
    options?: any
  ) {
    return AcadiaApiFp(this.configuration).uploadMessageCenterZip(
      serialNumber,
      file,
      signature,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * AcadiaMaintenanceApi - fetch parameter creator
 * @export
 */
export const AcadiaMaintenanceApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Cancel the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBleachClean(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelBleachClean."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/bleachClean/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestBleachClean(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestBleachClean."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/bleachClean/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a Drain Mix Chambers.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainMixChambers(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestDrainMixChambers."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/drainMixChamber/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a Flow Cell Soak.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellSoak(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestFlowCellSoak."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/flowCellSoak/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a Full System Prime.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFullSystemPrime(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestFullSystemPrime."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/fullSystemPrime/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a Prime Reagent.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeReagent(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestPrimeReagent."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/primeReagent/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a Prime Sheath.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeSheath(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestPrimeSheath."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/primeSheath/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {"SHIPPING" | "POWER_OFF"} type The type of shutdown to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(
      instrumentId: number,
      type: "SHIPPING" | "POWER_OFF",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestShutDown."
        );
      }
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling requestShutDown."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/shutdown/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request a System Flush.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSystemFlush(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestSystemFlush."
        );
      }
      const localVarPath =
        `/instruments/acadiadx/{instrumentId}/maintenance/systemFlush/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AcadiaMaintenanceApi - functional programming interface
 * @export
 */
export const AcadiaMaintenanceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBleachClean(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).cancelBleachClean(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestBleachClean(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestBleachClean(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a Drain Mix Chambers.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainMixChambers(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestDrainMixChambers(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a Flow Cell Soak.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellSoak(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestFlowCellSoak(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a Full System Prime.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFullSystemPrime(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestFullSystemPrime(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a Prime Reagent.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeReagent(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestPrimeReagent(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a Prime Sheath.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeSheath(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestPrimeSheath(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {"SHIPPING" | "POWER_OFF"} type The type of shutdown to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(
      instrumentId: number,
      type: "SHIPPING" | "POWER_OFF",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestShutDown(instrumentId, type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request a System Flush.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSystemFlush(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AcadiaMaintenanceApiFetchParamCreator(
        configuration
      ).requestSystemFlush(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AcadiaMaintenanceApi - factory interface
 * @export
 */
export const AcadiaMaintenanceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Cancel the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBleachClean(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).cancelBleachClean(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Bleach Clean maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestBleachClean(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestBleachClean(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a Drain Mix Chambers.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainMixChambers(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestDrainMixChambers(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a Flow Cell Soak.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellSoak(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestFlowCellSoak(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a Full System Prime.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFullSystemPrime(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestFullSystemPrime(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a Prime Reagent.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeReagent(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestPrimeReagent(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a Prime Sheath.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPrimeSheath(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestPrimeSheath(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {"SHIPPING" | "POWER_OFF"} type The type of shutdown to perform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(
      instrumentId: number,
      type: "SHIPPING" | "POWER_OFF",
      options?: any
    ) {
      return AcadiaMaintenanceApiFp(configuration).requestShutDown(
        instrumentId,
        type,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request a System Flush.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSystemFlush(instrumentId: number, options?: any) {
      return AcadiaMaintenanceApiFp(configuration).requestSystemFlush(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AcadiaMaintenanceApi - object-oriented interface
 * @export
 * @class AcadiaMaintenanceApi
 * @extends {BaseAPI}
 */
export class AcadiaMaintenanceApi extends BaseAPI {
  /**
   *
   * @summary Cancel the Bleach Clean maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public cancelBleachClean(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).cancelBleachClean(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Bleach Clean maintenance procedure.
   * @param {number} instrumentId The instrument ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestBleachClean(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestBleachClean(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a Drain Mix Chambers.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestDrainMixChambers(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestDrainMixChambers(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a Flow Cell Soak.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestFlowCellSoak(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestFlowCellSoak(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a Full System Prime.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestFullSystemPrime(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestFullSystemPrime(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a Prime Reagent.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestPrimeReagent(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestPrimeReagent(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a Prime Sheath.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestPrimeSheath(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestPrimeSheath(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Shut down maintenance procedure.
   * @param {number} instrumentId The instrument ID.
   * @param {"SHIPPING" | "POWER_OFF"} type The type of shutdown to perform
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestShutDown(
    instrumentId: number,
    type: "SHIPPING" | "POWER_OFF",
    options?: any
  ) {
    return AcadiaMaintenanceApiFp(this.configuration).requestShutDown(
      instrumentId,
      type,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request a System Flush.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaMaintenanceApi
   */
  public requestSystemFlush(instrumentId: number, options?: any) {
    return AcadiaMaintenanceApiFp(this.configuration).requestSystemFlush(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * AcadiaQualityControlApi - fetch parameter creator
 * @export
 */
export const AcadiaQualityControlApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Gets PCO QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlLots(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAcadiaQualityControlLots."
        );
      }
      const localVarPath = `/acadiaQualityControl/{instrumentId}/lots`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get quality control runs for this PCO instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {string} [lotNumber] The quality control lot number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlRunsByLotNumber(
      instrumentId: number,
      lotNumber?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAcadiaQualityControlRunsByLotNumber."
        );
      }
      const localVarPath =
        `/acadiaQualityControl/{instrumentId}/lot/runs`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (lotNumber !== undefined) {
        localVarQueryParameter["lotNumber"] = lotNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AcadiaQualityControlApi - functional programming interface
 * @export
 */
export const AcadiaQualityControlApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Gets PCO QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlLots(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<AcadiaQualityControlLotDto>> {
      const localVarFetchArgs = AcadiaQualityControlApiFetchParamCreator(
        configuration
      ).fetchAcadiaQualityControlLots(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get quality control runs for this PCO instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {string} [lotNumber] The quality control lot number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlRunsByLotNumber(
      instrumentId: number,
      lotNumber?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<AcadiaQualityControlRunRecordDto>> {
      const localVarFetchArgs = AcadiaQualityControlApiFetchParamCreator(
        configuration
      ).fetchAcadiaQualityControlRunsByLotNumber(
        instrumentId,
        lotNumber,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AcadiaQualityControlApi - factory interface
 * @export
 */
export const AcadiaQualityControlApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets PCO QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlLots(instrumentId: number, options?: any) {
      return AcadiaQualityControlApiFp(
        configuration
      ).fetchAcadiaQualityControlLots(instrumentId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get quality control runs for this PCO instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {string} [lotNumber] The quality control lot number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAcadiaQualityControlRunsByLotNumber(
      instrumentId: number,
      lotNumber?: string,
      options?: any
    ) {
      return AcadiaQualityControlApiFp(
        configuration
      ).fetchAcadiaQualityControlRunsByLotNumber(
        instrumentId,
        lotNumber,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AcadiaQualityControlApi - object-oriented interface
 * @export
 * @class AcadiaQualityControlApi
 * @extends {BaseAPI}
 */
export class AcadiaQualityControlApi extends BaseAPI {
  /**
   *
   * @summary Gets PCO QC lots.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaQualityControlApi
   */
  public fetchAcadiaQualityControlLots(instrumentId: number, options?: any) {
    return AcadiaQualityControlApiFp(
      this.configuration
    ).fetchAcadiaQualityControlLots(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get quality control runs for this PCO instrument and QC lot.
   * @param {number} instrumentId The instrument id.
   * @param {string} [lotNumber] The quality control lot number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaQualityControlApi
   */
  public fetchAcadiaQualityControlRunsByLotNumber(
    instrumentId: number,
    lotNumber?: string,
    options?: any
  ) {
    return AcadiaQualityControlApiFp(
      this.configuration
    ).fetchAcadiaQualityControlRunsByLotNumber(
      instrumentId,
      lotNumber,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * BackupApi - fetch parameter creator
 * @export
 */
export const BackupApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Synchronously wait for the asynchronous backup response
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awaitAsyncResponse(backupId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/backup/await`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (backupId !== undefined) {
        localVarQueryParameter["backupId"] = backupId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Frees up IVLS, but will not stop the SS Agent.
     * @summary Cancels the asynchronous wait for an in-process backup.
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelAwait(backupId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/backup/await/cancel`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (backupId !== undefined) {
        localVarQueryParameter["backupId"] = backupId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBackup(options: any = {}): FetchArgs {
      const localVarPath = `/backup/cancel`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create backup disk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBackupDisk(options: any = {}): FetchArgs {
      const localVarPath = `/backup/createBackupDisk`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check SSAgent is running and can serve HTTP requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isSSAgentRunning(options: any = {}): FetchArgs {
      const localVarPath = `/backup/agent/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform database backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performDatabaseBackup(options: any = {}): FetchArgs {
      const localVarPath = `/backup/performDatabaseBackup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the backup ID.
     * @summary Post a request to generate an asynchronous backup request to the SS agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postForBackup(options: any = {}): FetchArgs {
      const localVarPath = `/backup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Prepare backup device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupDevice(options: any = {}): FetchArgs {
      const localVarPath = `/backup/prepareBackupDevice`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Prepare backup image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupImage(options: any = {}): FetchArgs {
      const localVarPath = `/backup/prepareBackupImage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Try to recover SSAgent service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverSSAgent(options: any = {}): FetchArgs {
      const localVarPath = `/backup/agent/doRecover`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BackupApi - functional programming interface
 * @export
 */
export const BackupApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Synchronously wait for the asynchronous backup response
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awaitAsyncResponse(
      backupId?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<BackupMetadataWrapperDto> {
      const localVarFetchArgs = BackupApiFetchParamCreator(
        configuration
      ).awaitAsyncResponse(backupId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Frees up IVLS, but will not stop the SS Agent.
     * @summary Cancels the asynchronous wait for an in-process backup.
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelAwait(
      backupId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = BackupApiFetchParamCreator(
        configuration
      ).cancelAwait(backupId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancel backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBackup(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).cancelBackup(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create backup disk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBackupDisk(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).createBackupDisk(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Check SSAgent is running and can serve HTTP requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isSSAgentRunning(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).isSSAgentRunning(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform database backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performDatabaseBackup(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).performDatabaseBackup(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the backup ID.
     * @summary Post a request to generate an asynchronous backup request to the SS agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postForBackup(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).postForBackup(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Prepare backup device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupDevice(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).prepareBackupDevice(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Prepare backup image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupImage(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).prepareBackupImage(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Try to recover SSAgent service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverSSAgent(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        BackupApiFetchParamCreator(configuration).recoverSSAgent(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * BackupApi - factory interface
 * @export
 */
export const BackupApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Synchronously wait for the asynchronous backup response
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awaitAsyncResponse(backupId?: string, options?: any) {
      return BackupApiFp(configuration).awaitAsyncResponse(backupId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Frees up IVLS, but will not stop the SS Agent.
     * @summary Cancels the asynchronous wait for an in-process backup.
     * @param {string} [backupId] The backup ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelAwait(backupId?: string, options?: any) {
      return BackupApiFp(configuration).cancelAwait(backupId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Cancel backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBackup(options?: any) {
      return BackupApiFp(configuration).cancelBackup(options)(fetch, basePath);
    },
    /**
     *
     * @summary Create backup disk.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBackupDisk(options?: any) {
      return BackupApiFp(configuration).createBackupDisk(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Check SSAgent is running and can serve HTTP requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isSSAgentRunning(options?: any) {
      return BackupApiFp(configuration).isSSAgentRunning(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Perform database backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performDatabaseBackup(options?: any) {
      return BackupApiFp(configuration).performDatabaseBackup(options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns the backup ID.
     * @summary Post a request to generate an asynchronous backup request to the SS agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postForBackup(options?: any) {
      return BackupApiFp(configuration).postForBackup(options)(fetch, basePath);
    },
    /**
     *
     * @summary Prepare backup device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupDevice(options?: any) {
      return BackupApiFp(configuration).prepareBackupDevice(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Prepare backup image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareBackupImage(options?: any) {
      return BackupApiFp(configuration).prepareBackupImage(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Try to recover SSAgent service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recoverSSAgent(options?: any) {
      return BackupApiFp(configuration).recoverSSAgent(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
export class BackupApi extends BaseAPI {
  /**
   *
   * @summary Synchronously wait for the asynchronous backup response
   * @param {string} [backupId] The backup ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public awaitAsyncResponse(backupId?: string, options?: any) {
    return BackupApiFp(this.configuration).awaitAsyncResponse(
      backupId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Frees up IVLS, but will not stop the SS Agent.
   * @summary Cancels the asynchronous wait for an in-process backup.
   * @param {string} [backupId] The backup ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public cancelAwait(backupId?: string, options?: any) {
    return BackupApiFp(this.configuration).cancelAwait(backupId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Cancel backup.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public cancelBackup(options?: any) {
    return BackupApiFp(this.configuration).cancelBackup(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Create backup disk.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public createBackupDisk(options?: any) {
    return BackupApiFp(this.configuration).createBackupDisk(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Check SSAgent is running and can serve HTTP requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public isSSAgentRunning(options?: any) {
    return BackupApiFp(this.configuration).isSSAgentRunning(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Perform database backup.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public performDatabaseBackup(options?: any) {
    return BackupApiFp(this.configuration).performDatabaseBackup(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns the backup ID.
   * @summary Post a request to generate an asynchronous backup request to the SS agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public postForBackup(options?: any) {
    return BackupApiFp(this.configuration).postForBackup(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Prepare backup device.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public prepareBackupDevice(options?: any) {
    return BackupApiFp(this.configuration).prepareBackupDevice(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Prepare backup image.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public prepareBackupImage(options?: any) {
    return BackupApiFp(this.configuration).prepareBackupImage(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Try to recover SSAgent service.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackupApi
   */
  public recoverSSAgent(options?: any) {
    return BackupApiFp(this.configuration).recoverSSAgent(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * BootApi - fetch parameter creator
 * @export
 */
export const BootApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get boot items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBootItems(options: any = {}): FetchArgs {
      const localVarPath = `/boot/getBootItems`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BootApi - functional programming interface
 * @export
 */
export const BootApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get boot items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBootItems(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BootItemsDto> {
      const localVarFetchArgs =
        BootApiFetchParamCreator(configuration).getBootItems(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * BootApi - factory interface
 * @export
 */
export const BootApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get boot items.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBootItems(options?: any) {
      return BootApiFp(configuration).getBootItems(options)(fetch, basePath);
    },
  };
};

/**
 * BootApi - object-oriented interface
 * @export
 * @class BootApi
 * @extends {BaseAPI}
 */
export class BootApi extends BaseAPI {
  /**
   *
   * @summary Get boot items.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BootApi
   */
  public getBootItems(options?: any) {
    return BootApiFp(this.configuration).getBootItems(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * CatOneApi - fetch parameter creator
 * @export
 */
export const CatOneApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Cancel the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGeneralClean(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelGeneralClean."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/clean/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOffsets(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelOffsets."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/offsets/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOpticsCalibration(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelOpticsCalibration."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/opticsCalibration/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Complete the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeGeneralClean(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling completeGeneralClean."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/clean/complete`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Complete the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOffsets(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling completeOffsets."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/offsets/complete`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Complete the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOpticsCalibration(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling completeOpticsCalibration."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/opticsCalibration/complete`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatOneConfiguration(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchCatOneConfiguration."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/catOneConfigurations`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get smart quality control runs for the specified CatOne instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchQualityControlRuns."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/smartQC/runs`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestGeneralClean(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestGeneralClean."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/clean/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {OffsetsDto} [body] QC Lot information to broadcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffsets(
      instrumentId: number,
      body?: OffsetsDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestOffsets."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/offsets/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"OffsetsDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOpticsCalibration(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestOpticsCalibration."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/opticsCalibration/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request that the RTD driven optimization procedure be run by the instrument
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOptimization(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestOptimization."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/optimize`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Shutdown for Shipping maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutdownForShipping(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestShutdownForShipping."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/shutdownForShipping/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {CatOneConfigurationDto} [body] CatOne instrument configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCatOneConfiguration(
      instrumentId: number,
      body?: CatOneConfigurationDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateCatOneConfiguration."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/catOneConfigurations`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CatOneConfigurationDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CatOneApi - functional programming interface
 * @export
 */
export const CatOneApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGeneralClean(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).cancelGeneralClean(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancel the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOffsets(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).cancelOffsets(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancel the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOpticsCalibration(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).cancelOpticsCalibration(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Complete the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeGeneralClean(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).completeGeneralClean(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Complete the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOffsets(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).completeOffsets(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Complete the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOpticsCalibration(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).completeOpticsCalibration(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatOneConfiguration(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<CatOneConfigurationDto> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).fetchCatOneConfiguration(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get smart quality control runs for the specified CatOne instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<SmartQCRunRecordDto>> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).fetchQualityControlRuns(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestGeneralClean(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).requestGeneralClean(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {OffsetsDto} [body] QC Lot information to broadcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffsets(
      instrumentId: number,
      body?: OffsetsDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).requestOffsets(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOpticsCalibration(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).requestOpticsCalibration(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request that the RTD driven optimization procedure be run by the instrument
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOptimization(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).requestOptimization(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Shutdown for Shipping maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutdownForShipping(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).requestShutdownForShipping(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {CatOneConfigurationDto} [body] CatOne instrument configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCatOneConfiguration(
      instrumentId: number,
      body?: CatOneConfigurationDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<CatOneConfigurationDto> {
      const localVarFetchArgs = CatOneApiFetchParamCreator(
        configuration
      ).updateCatOneConfiguration(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CatOneApi - factory interface
 * @export
 */
export const CatOneApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Cancel the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGeneralClean(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).cancelGeneralClean(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cancel the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOffsets(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).cancelOffsets(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Cancel the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOpticsCalibration(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).cancelOpticsCalibration(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Complete the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeGeneralClean(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).completeGeneralClean(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Complete the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOffsets(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).completeOffsets(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Complete the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOpticsCalibration(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).completeOpticsCalibration(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatOneConfiguration(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).fetchCatOneConfiguration(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get smart quality control runs for the specified CatOne instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).fetchQualityControlRuns(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the General Clean maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestGeneralClean(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).requestGeneralClean(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Offsets maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {OffsetsDto} [body] QC Lot information to broadcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOffsets(instrumentId: number, body?: OffsetsDto, options?: any) {
      return CatOneApiFp(configuration).requestOffsets(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Optics Calibration maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOpticsCalibration(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).requestOpticsCalibration(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request that the RTD driven optimization procedure be run by the instrument
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestOptimization(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).requestOptimization(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Shutdown for Shipping maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutdownForShipping(instrumentId: number, options?: any) {
      return CatOneApiFp(configuration).requestShutdownForShipping(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update CatOne instrument configuration.
     * @param {number} instrumentId The instrument Id.
     * @param {CatOneConfigurationDto} [body] CatOne instrument configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCatOneConfiguration(
      instrumentId: number,
      body?: CatOneConfigurationDto,
      options?: any
    ) {
      return CatOneApiFp(configuration).updateCatOneConfiguration(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * CatOneApi - object-oriented interface
 * @export
 * @class CatOneApi
 * @extends {BaseAPI}
 */
export class CatOneApi extends BaseAPI {
  /**
   *
   * @summary Cancel the General Clean maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public cancelGeneralClean(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).cancelGeneralClean(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cancel the Offsets maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public cancelOffsets(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).cancelOffsets(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Cancel the Optics Calibration maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public cancelOpticsCalibration(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).cancelOpticsCalibration(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Complete the General Clean maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public completeGeneralClean(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).completeGeneralClean(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Complete the Offsets maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public completeOffsets(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).completeOffsets(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Complete the Optics Calibration maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public completeOpticsCalibration(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).completeOpticsCalibration(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch CatOne instrument configuration.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public fetchCatOneConfiguration(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).fetchCatOneConfiguration(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get smart quality control runs for the specified CatOne instrument
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public fetchQualityControlRuns(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).fetchQualityControlRuns(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the General Clean maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public requestGeneralClean(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).requestGeneralClean(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Offsets maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {OffsetsDto} [body] QC Lot information to broadcast.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public requestOffsets(
    instrumentId: number,
    body?: OffsetsDto,
    options?: any
  ) {
    return CatOneApiFp(this.configuration).requestOffsets(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Optics Calibration maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public requestOpticsCalibration(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).requestOpticsCalibration(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request that the RTD driven optimization procedure be run by the instrument
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public requestOptimization(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).requestOptimization(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Shutdown for Shipping maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public requestShutdownForShipping(instrumentId: number, options?: any) {
    return CatOneApiFp(this.configuration).requestShutdownForShipping(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update CatOne instrument configuration.
   * @param {number} instrumentId The instrument Id.
   * @param {CatOneConfigurationDto} [body] CatOne instrument configurations.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatOneApi
   */
  public updateCatOneConfiguration(
    instrumentId: number,
    body?: CatOneConfigurationDto,
    options?: any
  ) {
    return CatOneApiFp(this.configuration).updateCatOneConfiguration(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * CatalystDxApi - fetch parameter creator
 * @export
 */
export const CatalystDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get smart quality control runs for the specified CatalystDx instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchQualityControlRuns."
        );
      }
      const localVarPath = `/catalystDx/{instrumentId}/smartQC/runs`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CatalystDxApi - functional programming interface
 * @export
 */
export const CatalystDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get smart quality control runs for the specified CatalystDx instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<SmartQCRunRecordDto>> {
      const localVarFetchArgs = CatalystDxApiFetchParamCreator(
        configuration
      ).fetchQualityControlRuns(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CatalystDxApi - factory interface
 * @export
 */
export const CatalystDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get smart quality control runs for the specified CatalystDx instrument
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlRuns(instrumentId: number, options?: any) {
      return CatalystDxApiFp(configuration).fetchQualityControlRuns(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * CatalystDxApi - object-oriented interface
 * @export
 * @class CatalystDxApi
 * @extends {BaseAPI}
 */
export class CatalystDxApi extends BaseAPI {
  /**
   *
   * @summary Get smart quality control runs for the specified CatalystDx instrument
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystDxApi
   */
  public fetchQualityControlRuns(instrumentId: number, options?: any) {
    return CatalystDxApiFp(this.configuration).fetchQualityControlRuns(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * CdDriveApi - fetch parameter creator
 * @export
 */
export const CdDriveApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get CD drive status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options: any = {}): FetchArgs {
      const localVarPath = `/cdDrives/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Toggle (enable/disable)) of CD drive status poller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCdDriveStatePollerRequest(options: any = {}): FetchArgs {
      const localVarPath = `/cdDrives/statePollers/toggle`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Open CD drive drawer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openDrawer(options: any = {}): FetchArgs {
      const localVarPath = `/cdDrives/open`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CdDriveApi - functional programming interface
 * @export
 */
export const CdDriveApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get CD drive status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CdDriveStatusDto> {
      const localVarFetchArgs =
        CdDriveApiFetchParamCreator(configuration).getStatus(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Toggle (enable/disable)) of CD drive status poller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCdDriveStatePollerRequest(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        CdDriveApiFetchParamCreator(
          configuration
        ).handleCdDriveStatePollerRequest(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Open CD drive drawer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openDrawer(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        CdDriveApiFetchParamCreator(configuration).openDrawer(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CdDriveApi - factory interface
 * @export
 */
export const CdDriveApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get CD drive status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatus(options?: any) {
      return CdDriveApiFp(configuration).getStatus(options)(fetch, basePath);
    },
    /**
     *
     * @summary Toggle (enable/disable)) of CD drive status poller.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleCdDriveStatePollerRequest(options?: any) {
      return CdDriveApiFp(configuration).handleCdDriveStatePollerRequest(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Open CD drive drawer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    openDrawer(options?: any) {
      return CdDriveApiFp(configuration).openDrawer(options)(fetch, basePath);
    },
  };
};

/**
 * CdDriveApi - object-oriented interface
 * @export
 * @class CdDriveApi
 * @extends {BaseAPI}
 */
export class CdDriveApi extends BaseAPI {
  /**
   *
   * @summary Get CD drive status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CdDriveApi
   */
  public getStatus(options?: any) {
    return CdDriveApiFp(this.configuration).getStatus(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Toggle (enable/disable)) of CD drive status poller.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CdDriveApi
   */
  public handleCdDriveStatePollerRequest(options?: any) {
    return CdDriveApiFp(this.configuration).handleCdDriveStatePollerRequest(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Open CD drive drawer.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CdDriveApi
   */
  public openDrawer(options?: any) {
    return CdDriveApiFp(this.configuration).openDrawer(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ClientApi - fetch parameter creator
 * @export
 */
export const ClientApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Save a new client.
     * @param {ClientSaveEditDto} [clientDto] The client to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(clientDto?: ClientSaveEditDto, options: any = {}): FetchArgs {
      const localVarPath = `/client`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ClientSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(clientDto || {})
        : clientDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit an existing client.
     * @param {number} clientId The client Id.
     * @param {ClientSaveEditDto} [body] The new client data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      clientId: number,
      body?: ClientSaveEditDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling edit."
        );
      }
      const localVarPath = `/client/{clientId}`.replace(
        `{${"clientId"}}`,
        encodeURIComponent(String(clientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ClientSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Checks if the proposed user facing client identifier edit will generate a duplicate
     * @param {string} clientIdentifier The new (edited) user facing client identifier.
     * @param {number} clientId the primary key ID of the client being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingClientIdentifierWillGenerateDuplicate(
      clientIdentifier: string,
      clientId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'clientIdentifier' is not null or undefined
      if (clientIdentifier === null || clientIdentifier === undefined) {
        throw new RequiredError(
          "clientIdentifier",
          "Required parameter clientIdentifier was null or undefined when calling editingClientIdentifierWillGenerateDuplicate."
        );
      }
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling editingClientIdentifierWillGenerateDuplicate."
        );
      }
      const localVarPath =
        `/client/{clientId}/editingClientIdentifierWillGenerateDuplicate`.replace(
          `{${"clientId"}}`,
          encodeURIComponent(String(clientId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (clientIdentifier !== undefined) {
        localVarQueryParameter["clientIdentifier"] = clientIdentifier;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get client by ID.
     * @param {number} clientId The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(clientId: number, options: any = {}): FetchArgs {
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling get."
        );
      }
      const localVarPath = `/client/{clientId}`.replace(
        `{${"clientId"}}`,
        encodeURIComponent(String(clientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all clients. NOTE: The returned list excludes Control clients.
     * @param {string} [clientFirstName] The client first name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The user facing client identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClients(
      clientFirstName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/client`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (clientFirstName !== undefined) {
        localVarQueryParameter["clientFirstName"] = clientFirstName;
      }

      if (clientLastName !== undefined) {
        localVarQueryParameter["clientLastName"] = clientLastName;
      }

      if (clientIdentifier !== undefined) {
        localVarQueryParameter["clientIdentifier"] = clientIdentifier;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Save a new client.
     * @param {ClientSaveEditDto} [clientDto] The client to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      clientDto?: ClientSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
      const localVarFetchArgs = ClientApiFetchParamCreator(
        configuration
      ).create(clientDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit an existing client.
     * @param {number} clientId The client Id.
     * @param {ClientSaveEditDto} [body] The new client data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      clientId: number,
      body?: ClientSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
      const localVarFetchArgs = ClientApiFetchParamCreator(configuration).edit(
        clientId,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Checks if the proposed user facing client identifier edit will generate a duplicate
     * @param {string} clientIdentifier The new (edited) user facing client identifier.
     * @param {number} clientId the primary key ID of the client being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingClientIdentifierWillGenerateDuplicate(
      clientIdentifier: string,
      clientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = ClientApiFetchParamCreator(
        configuration
      ).editingClientIdentifierWillGenerateDuplicate(
        clientIdentifier,
        clientId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get client by ID.
     * @param {number} clientId The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(
      clientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
      const localVarFetchArgs = ClientApiFetchParamCreator(configuration).get(
        clientId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all clients. NOTE: The returned list excludes Control clients.
     * @param {string} [clientFirstName] The client first name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The user facing client identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClients(
      clientFirstName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClientDto>> {
      const localVarFetchArgs = ClientApiFetchParamCreator(
        configuration
      ).getAllClients(
        clientFirstName,
        clientLastName,
        clientIdentifier,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Save a new client.
     * @param {ClientSaveEditDto} [clientDto] The client to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(clientDto?: ClientSaveEditDto, options?: any) {
      return ClientApiFp(configuration).create(clientDto, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Edit an existing client.
     * @param {number} clientId The client Id.
     * @param {ClientSaveEditDto} [body] The new client data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(clientId: number, body?: ClientSaveEditDto, options?: any) {
      return ClientApiFp(configuration).edit(
        clientId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Checks if the proposed user facing client identifier edit will generate a duplicate
     * @param {string} clientIdentifier The new (edited) user facing client identifier.
     * @param {number} clientId the primary key ID of the client being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingClientIdentifierWillGenerateDuplicate(
      clientIdentifier: string,
      clientId: number,
      options?: any
    ) {
      return ClientApiFp(
        configuration
      ).editingClientIdentifierWillGenerateDuplicate(
        clientIdentifier,
        clientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get client by ID.
     * @param {number} clientId The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(clientId: number, options?: any) {
      return ClientApiFp(configuration).get(clientId, options)(fetch, basePath);
    },
    /**
     *
     * @summary Get all clients. NOTE: The returned list excludes Control clients.
     * @param {string} [clientFirstName] The client first name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The user facing client identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllClients(
      clientFirstName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options?: any
    ) {
      return ClientApiFp(configuration).getAllClients(
        clientFirstName,
        clientLastName,
        clientIdentifier,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
  /**
   *
   * @summary Save a new client.
   * @param {ClientSaveEditDto} [clientDto] The client to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public create(clientDto?: ClientSaveEditDto, options?: any) {
    return ClientApiFp(this.configuration).create(clientDto, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Edit an existing client.
   * @param {number} clientId The client Id.
   * @param {ClientSaveEditDto} [body] The new client data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public edit(clientId: number, body?: ClientSaveEditDto, options?: any) {
    return ClientApiFp(this.configuration).edit(
      clientId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Checks if the proposed user facing client identifier edit will generate a duplicate
   * @param {string} clientIdentifier The new (edited) user facing client identifier.
   * @param {number} clientId the primary key ID of the client being edited
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public editingClientIdentifierWillGenerateDuplicate(
    clientIdentifier: string,
    clientId: number,
    options?: any
  ) {
    return ClientApiFp(
      this.configuration
    ).editingClientIdentifierWillGenerateDuplicate(
      clientIdentifier,
      clientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get client by ID.
   * @param {number} clientId The client Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public get(clientId: number, options?: any) {
    return ClientApiFp(this.configuration).get(clientId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get all clients. NOTE: The returned list excludes Control clients.
   * @param {string} [clientFirstName] The client first name.
   * @param {string} [clientLastName] The client last name.
   * @param {string} [clientIdentifier] The user facing client identifier.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientApi
   */
  public getAllClients(
    clientFirstName?: string,
    clientLastName?: string,
    clientIdentifier?: string,
    options?: any
  ) {
    return ClientApiFp(this.configuration).getAllClients(
      clientFirstName,
      clientLastName,
      clientIdentifier,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ConnecteddeviceApi - fetch parameter creator
 * @export
 */
export const ConnecteddeviceApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get connected device status
     * @param {number} id The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatus(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling fetchConnectedDeviceStatus."
        );
      }
      const localVarPath = `/device/{id}/status`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatuses(options: any = {}): FetchArgs {
      const localVarPath = `/device/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedSnapProDeviceStatuses(options: any = {}): FetchArgs {
      const localVarPath = `/device/snap/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of devices awaiting approval.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDevicesAwaitingApproval(options: any = {}): FetchArgs {
      const localVarPath = `/device/awaitingApproval`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get connected device history for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/device/history/byType`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentType !== undefined) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get quality control runs for this instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling getQcRunsForDevice."
        );
      }
      const localVarPath = `/device/{instrumentId}/runs`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get quality control runs for this instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {number} qualityControlId The quality control lot id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice_1(
      instrumentId: number,
      qualityControlId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling getQcRunsForDevice_1."
        );
      }
      // verify required parameter 'qualityControlId' is not null or undefined
      if (qualityControlId === null || qualityControlId === undefined) {
        throw new RequiredError(
          "qualityControlId",
          "Required parameter qualityControlId was null or undefined when calling getQcRunsForDevice_1."
        );
      }
      const localVarPath = `/device/{instrumentId}/{qualityControlId}/runs`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(
          `{${"qualityControlId"}}`,
          encodeURIComponent(String(qualityControlId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if connected device history exists for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/device/history/exists`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentType !== undefined) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the approval status for a device.
     * @param {number} deviceId ID of the device to approve/disapprove.
     * @param {boolean} approved updated approval status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setApprovalStatus(
      deviceId: number,
      approved: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'deviceId' is not null or undefined
      if (deviceId === null || deviceId === undefined) {
        throw new RequiredError(
          "deviceId",
          "Required parameter deviceId was null or undefined when calling setApprovalStatus."
        );
      }
      // verify required parameter 'approved' is not null or undefined
      if (approved === null || approved === undefined) {
        throw new RequiredError(
          "approved",
          "Required parameter approved was null or undefined when calling setApprovalStatus."
        );
      }
      const localVarPath = `/device/{deviceId}/approved`.replace(
        `{${"deviceId"}}`,
        encodeURIComponent(String(deviceId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (approved !== undefined) {
        localVarQueryParameter["approved"] = approved;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Stop waiting for current action
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopWaiting(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling stopWaiting."
        );
      }
      const localVarPath = `/device/{instrumentId}/stopWaiting`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Suppress device.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suppress(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling suppress."
        );
      }
      const localVarPath = `/device/{instrumentId}/suppress`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnecteddeviceApi - functional programming interface
 * @export
 */
export const ConnecteddeviceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get connected device status
     * @param {number} id The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatus(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InstrumentStatusDto> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).fetchConnectedDeviceStatus(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatuses(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<InstrumentStatusDto>> {
      const localVarFetchArgs =
        ConnecteddeviceApiFetchParamCreator(
          configuration
        ).fetchConnectedDeviceStatuses(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedSnapProDeviceStatuses(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<InstrumentStatusDto>> {
      const localVarFetchArgs =
        ConnecteddeviceApiFetchParamCreator(
          configuration
        ).fetchConnectedSnapProDeviceStatuses(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get a list of devices awaiting approval.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDevicesAwaitingApproval(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<ConnectionApprovalRequestDto>> {
      const localVarFetchArgs =
        ConnecteddeviceApiFetchParamCreator(
          configuration
        ).fetchDevicesAwaitingApproval(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get connected device history for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<ConnectedDeviceHistoryDto>> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).getConnectedDeviceHistoryForType(instrumentType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get quality control runs for this instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<QualityControlRunRecordDto>> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).getQcRunsForDevice(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get quality control runs for this instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {number} qualityControlId The quality control lot id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice_1(
      instrumentId: number,
      qualityControlId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<QualityControlRunRecordDto>> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).getQcRunsForDevice_1(instrumentId, qualityControlId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Check if connected device history exists for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).hasConnectedDeviceHistoryForType(instrumentType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set the approval status for a device.
     * @param {number} deviceId ID of the device to approve/disapprove.
     * @param {boolean} approved updated approval status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setApprovalStatus(
      deviceId: number,
      approved: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).setApprovalStatus(deviceId, approved, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Stop waiting for current action
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopWaiting(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).stopWaiting(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Suppress device.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suppress(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ConnecteddeviceApiFetchParamCreator(
        configuration
      ).suppress(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ConnecteddeviceApi - factory interface
 * @export
 */
export const ConnecteddeviceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get connected device status
     * @param {number} id The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatus(id: number, options?: any) {
      return ConnecteddeviceApiFp(configuration).fetchConnectedDeviceStatus(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedDeviceStatuses(options?: any) {
      return ConnecteddeviceApiFp(configuration).fetchConnectedDeviceStatuses(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get list of all connected device statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchConnectedSnapProDeviceStatuses(options?: any) {
      return ConnecteddeviceApiFp(
        configuration
      ).fetchConnectedSnapProDeviceStatuses(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get a list of devices awaiting approval.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDevicesAwaitingApproval(options?: any) {
      return ConnecteddeviceApiFp(configuration).fetchDevicesAwaitingApproval(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get connected device history for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ) {
      return ConnecteddeviceApiFp(
        configuration
      ).getConnectedDeviceHistoryForType(instrumentType, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get quality control runs for this instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice(instrumentId: number, options?: any) {
      return ConnecteddeviceApiFp(configuration).getQcRunsForDevice(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get quality control runs for this instrument and QC lot.
     * @param {number} instrumentId The instrument id.
     * @param {number} qualityControlId The quality control lot id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQcRunsForDevice_1(
      instrumentId: number,
      qualityControlId: number,
      options?: any
    ) {
      return ConnecteddeviceApiFp(configuration).getQcRunsForDevice_1(
        instrumentId,
        qualityControlId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Check if connected device history exists for a specified instrument type
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasConnectedDeviceHistoryForType(
      instrumentType?:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ) {
      return ConnecteddeviceApiFp(
        configuration
      ).hasConnectedDeviceHistoryForType(instrumentType, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Set the approval status for a device.
     * @param {number} deviceId ID of the device to approve/disapprove.
     * @param {boolean} approved updated approval status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setApprovalStatus(deviceId: number, approved: boolean, options?: any) {
      return ConnecteddeviceApiFp(configuration).setApprovalStatus(
        deviceId,
        approved,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Stop waiting for current action
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopWaiting(instrumentId: number, options?: any) {
      return ConnecteddeviceApiFp(configuration).stopWaiting(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Suppress device.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    suppress(instrumentId: number, options?: any) {
      return ConnecteddeviceApiFp(configuration).suppress(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ConnecteddeviceApi - object-oriented interface
 * @export
 * @class ConnecteddeviceApi
 * @extends {BaseAPI}
 */
export class ConnecteddeviceApi extends BaseAPI {
  /**
   *
   * @summary Get connected device status
   * @param {number} id The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public fetchConnectedDeviceStatus(id: number, options?: any) {
    return ConnecteddeviceApiFp(this.configuration).fetchConnectedDeviceStatus(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get list of all connected device statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public fetchConnectedDeviceStatuses(options?: any) {
    return ConnecteddeviceApiFp(
      this.configuration
    ).fetchConnectedDeviceStatuses(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get list of all connected device statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public fetchConnectedSnapProDeviceStatuses(options?: any) {
    return ConnecteddeviceApiFp(
      this.configuration
    ).fetchConnectedSnapProDeviceStatuses(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get a list of devices awaiting approval.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public fetchDevicesAwaitingApproval(options?: any) {
    return ConnecteddeviceApiFp(
      this.configuration
    ).fetchDevicesAwaitingApproval(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get connected device history for a specified instrument type
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public getConnectedDeviceHistoryForType(
    instrumentType?:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    options?: any
  ) {
    return ConnecteddeviceApiFp(
      this.configuration
    ).getConnectedDeviceHistoryForType(instrumentType, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get quality control runs for this instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public getQcRunsForDevice(instrumentId: number, options?: any) {
    return ConnecteddeviceApiFp(this.configuration).getQcRunsForDevice(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get quality control runs for this instrument and QC lot.
   * @param {number} instrumentId The instrument id.
   * @param {number} qualityControlId The quality control lot id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public getQcRunsForDevice_1(
    instrumentId: number,
    qualityControlId: number,
    options?: any
  ) {
    return ConnecteddeviceApiFp(this.configuration).getQcRunsForDevice_1(
      instrumentId,
      qualityControlId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Check if connected device history exists for a specified instrument type
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} [instrumentType] The instrument type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public hasConnectedDeviceHistoryForType(
    instrumentType?:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    options?: any
  ) {
    return ConnecteddeviceApiFp(
      this.configuration
    ).hasConnectedDeviceHistoryForType(instrumentType, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Set the approval status for a device.
   * @param {number} deviceId ID of the device to approve/disapprove.
   * @param {boolean} approved updated approval status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public setApprovalStatus(deviceId: number, approved: boolean, options?: any) {
    return ConnecteddeviceApiFp(this.configuration).setApprovalStatus(
      deviceId,
      approved,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Stop waiting for current action
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public stopWaiting(instrumentId: number, options?: any) {
    return ConnecteddeviceApiFp(this.configuration).stopWaiting(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Suppress device.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnecteddeviceApi
   */
  public suppress(instrumentId: number, options?: any) {
    return ConnecteddeviceApiFp(this.configuration).suppress(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * DeltaApi - fetch parameter creator
 * @export
 */
export const DeltaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Reset the delta mode to Initial and create a backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reinitialize(options: any = {}): FetchArgs {
      const localVarPath = `/delta/reinitialize`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DeltaApi - functional programming interface
 * @export
 */
export const DeltaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Reset the delta mode to Initial and create a backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reinitialize(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        DeltaApiFetchParamCreator(configuration).reinitialize(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DeltaApi - factory interface
 * @export
 */
export const DeltaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Reset the delta mode to Initial and create a backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reinitialize(options?: any) {
      return DeltaApiFp(configuration).reinitialize(options)(fetch, basePath);
    },
  };
};

/**
 * DeltaApi - object-oriented interface
 * @export
 * @class DeltaApi
 * @extends {BaseAPI}
 */
export class DeltaApi extends BaseAPI {
  /**
   *
   * @summary Reset the delta mode to Initial and create a backup.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DeltaApi
   */
  public reinitialize(options?: any) {
    return DeltaApiFp(this.configuration).reinitialize(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * DoctorApi - fetch parameter creator
 * @export
 */
export const DoctorApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Save a new doctor.
     * @param {DoctorSaveEditDto} [doctorDto] The doctor to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(doctorDto?: DoctorSaveEditDto, options: any = {}): FetchArgs {
      const localVarPath = `/doctor`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"DoctorSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(doctorDto || {})
        : doctorDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit an existing doctor.
     * @param {number} doctorId The id of the doctor to edit.
     * @param {DoctorSaveEditDto} [doctorDto] The new doctor data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      doctorId: number,
      doctorDto?: DoctorSaveEditDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'doctorId' is not null or undefined
      if (doctorId === null || doctorId === undefined) {
        throw new RequiredError(
          "doctorId",
          "Required parameter doctorId was null or undefined when calling edit."
        );
      }
      const localVarPath = `/doctor/{doctorId}`.replace(
        `{${"doctorId"}}`,
        encodeURIComponent(String(doctorId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"DoctorSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(doctorDto || {})
        : doctorDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all doctors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAll(options: any = {}): FetchArgs {
      const localVarPath = `/doctor`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a doctor.
     * @param {number} doctorId The id of the doctor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(doctorId: number, options: any = {}): FetchArgs {
      // verify required parameter 'doctorId' is not null or undefined
      if (doctorId === null || doctorId === undefined) {
        throw new RequiredError(
          "doctorId",
          "Required parameter doctorId was null or undefined when calling remove."
        );
      }
      const localVarPath = `/doctor/{doctorId}`.replace(
        `{${"doctorId"}}`,
        encodeURIComponent(String(doctorId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DoctorApi - functional programming interface
 * @export
 */
export const DoctorApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Save a new doctor.
     * @param {DoctorSaveEditDto} [doctorDto] The doctor to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      doctorDto?: DoctorSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DoctorDto> {
      const localVarFetchArgs = DoctorApiFetchParamCreator(
        configuration
      ).create(doctorDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit an existing doctor.
     * @param {number} doctorId The id of the doctor to edit.
     * @param {DoctorSaveEditDto} [doctorDto] The new doctor data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      doctorId: number,
      doctorDto?: DoctorSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DoctorDto> {
      const localVarFetchArgs = DoctorApiFetchParamCreator(configuration).edit(
        doctorId,
        doctorDto,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all doctors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAll(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DoctorDto>> {
      const localVarFetchArgs =
        DoctorApiFetchParamCreator(configuration).fetchAll(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete a doctor.
     * @param {number} doctorId The id of the doctor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(
      doctorId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = DoctorApiFetchParamCreator(
        configuration
      ).remove(doctorId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DoctorApi - factory interface
 * @export
 */
export const DoctorApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Save a new doctor.
     * @param {DoctorSaveEditDto} [doctorDto] The doctor to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(doctorDto?: DoctorSaveEditDto, options?: any) {
      return DoctorApiFp(configuration).create(doctorDto, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Edit an existing doctor.
     * @param {number} doctorId The id of the doctor to edit.
     * @param {DoctorSaveEditDto} [doctorDto] The new doctor data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(doctorId: number, doctorDto?: DoctorSaveEditDto, options?: any) {
      return DoctorApiFp(configuration).edit(
        doctorId,
        doctorDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all doctors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAll(options?: any) {
      return DoctorApiFp(configuration).fetchAll(options)(fetch, basePath);
    },
    /**
     *
     * @summary Delete a doctor.
     * @param {number} doctorId The id of the doctor to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    remove(doctorId: number, options?: any) {
      return DoctorApiFp(configuration).remove(doctorId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * DoctorApi - object-oriented interface
 * @export
 * @class DoctorApi
 * @extends {BaseAPI}
 */
export class DoctorApi extends BaseAPI {
  /**
   *
   * @summary Save a new doctor.
   * @param {DoctorSaveEditDto} [doctorDto] The doctor to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public create(doctorDto?: DoctorSaveEditDto, options?: any) {
    return DoctorApiFp(this.configuration).create(doctorDto, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Edit an existing doctor.
   * @param {number} doctorId The id of the doctor to edit.
   * @param {DoctorSaveEditDto} [doctorDto] The new doctor data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public edit(doctorId: number, doctorDto?: DoctorSaveEditDto, options?: any) {
    return DoctorApiFp(this.configuration).edit(
      doctorId,
      doctorDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all doctors.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public fetchAll(options?: any) {
    return DoctorApiFp(this.configuration).fetchAll(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Delete a doctor.
   * @param {number} doctorId The id of the doctor to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DoctorApi
   */
  public remove(doctorId: number, options?: any) {
    return DoctorApiFp(this.configuration).remove(doctorId, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * DotPlotsApi - fetch parameter creator
 * @export
 */
export const DotPlotsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Gets the dot plot for the given instrument run
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDotPlot(instrumentRunId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getDotPlot."
        );
      }
      const localVarPath = `/dotPlots/{instrumentRunId}`.replace(
        `{${"instrumentRunId"}}`,
        encodeURIComponent(String(instrumentRunId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DotPlotsApi - functional programming interface
 * @export
 */
export const DotPlotsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets the dot plot for the given instrument run
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDotPlot(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = DotPlotsApiFetchParamCreator(
        configuration
      ).getDotPlot(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DotPlotsApi - factory interface
 * @export
 */
export const DotPlotsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Gets the dot plot for the given instrument run
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDotPlot(instrumentRunId: number, options?: any) {
      return DotPlotsApiFp(configuration).getDotPlot(instrumentRunId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * DotPlotsApi - object-oriented interface
 * @export
 * @class DotPlotsApi
 * @extends {BaseAPI}
 */
export class DotPlotsApi extends BaseAPI {
  /**
   *
   * @summary Gets the dot plot for the given instrument run
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DotPlotsApi
   */
  public getDotPlot(instrumentRunId: number, options?: any) {
    return DotPlotsApiFp(this.configuration).getDotPlot(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * EventLogApi - fetch parameter creator
 * @export
 */
export const EventLogApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch event logs
     * @param {string} [identifier] The identifier to filter on. For instruments, this is the serial number.
     * @param {string} [cutoffDate] Cutoff date for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEventLogs(
      identifier?: string,
      cutoffDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/eventlog`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (identifier !== undefined) {
        localVarQueryParameter["identifier"] = identifier;
      }

      if (cutoffDate !== undefined) {
        localVarQueryParameter["cutoffDate"] =
          (cutoffDate as any) instanceof Date
            ? (cutoffDate as any).toISOString().substr(0, 10)
            : cutoffDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EventLogApi - functional programming interface
 * @export
 */
export const EventLogApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Fetch event logs
     * @param {string} [identifier] The identifier to filter on. For instruments, this is the serial number.
     * @param {string} [cutoffDate] Cutoff date for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEventLogs(
      identifier?: string,
      cutoffDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventLogDto>> {
      const localVarFetchArgs = EventLogApiFetchParamCreator(
        configuration
      ).fetchEventLogs(identifier, cutoffDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * EventLogApi - factory interface
 * @export
 */
export const EventLogApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch event logs
     * @param {string} [identifier] The identifier to filter on. For instruments, this is the serial number.
     * @param {string} [cutoffDate] Cutoff date for the request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEventLogs(identifier?: string, cutoffDate?: string, options?: any) {
      return EventLogApiFp(configuration).fetchEventLogs(
        identifier,
        cutoffDate,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * EventLogApi - object-oriented interface
 * @export
 * @class EventLogApi
 * @extends {BaseAPI}
 */
export class EventLogApi extends BaseAPI {
  /**
   *
   * @summary Fetch event logs
   * @param {string} [identifier] The identifier to filter on. For instruments, this is the serial number.
   * @param {string} [cutoffDate] Cutoff date for the request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventLogApi
   */
  public fetchEventLogs(
    identifier?: string,
    cutoffDate?: string,
    options?: any
  ) {
    return EventLogApiFp(this.configuration).fetchEventLogs(
      identifier,
      cutoffDate,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * FeatureFlagApi - fetch parameter creator
 * @export
 */
export const FeatureFlagApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Activate/deactivate a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {FeatureFlagActivateDto} [body] The activation status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      body?: FeatureFlagActivateDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'featureFlagName' is not null or undefined
      if (featureFlagName === null || featureFlagName === undefined) {
        throw new RequiredError(
          "featureFlagName",
          "Required parameter featureFlagName was null or undefined when calling activate."
        );
      }
      const localVarPath = `/featureFlag/{featureFlagName}`.replace(
        `{${"featureFlagName"}}`,
        encodeURIComponent(String(featureFlagName))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"FeatureFlagActivateDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active status of a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveStatus(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'featureFlagName' is not null or undefined
      if (featureFlagName === null || featureFlagName === undefined) {
        throw new RequiredError(
          "featureFlagName",
          "Required parameter featureFlagName was null or undefined when calling fetchActiveStatus."
        );
      }
      const localVarPath = `/featureFlag/{featureFlagName}`.replace(
        `{${"featureFlagName"}}`,
        encodeURIComponent(String(featureFlagName))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FeatureFlagApi - functional programming interface
 * @export
 */
export const FeatureFlagApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Activate/deactivate a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {FeatureFlagActivateDto} [body] The activation status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      body?: FeatureFlagActivateDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = FeatureFlagApiFetchParamCreator(
        configuration
      ).activate(featureFlagName, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active status of a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveStatus(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = FeatureFlagApiFetchParamCreator(
        configuration
      ).fetchActiveStatus(featureFlagName, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * FeatureFlagApi - factory interface
 * @export
 */
export const FeatureFlagApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Activate/deactivate a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {FeatureFlagActivateDto} [body] The activation status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      body?: FeatureFlagActivateDto,
      options?: any
    ) {
      return FeatureFlagApiFp(configuration).activate(
        featureFlagName,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active status of a feature flag.
     * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveStatus(
      featureFlagName:
        | "SNAP_PRO_FIRMWARE_POLLING"
        | "REFERENCE_LAB"
        | "VC_PLUS_LOCALIZE_RESULTS"
        | "UA_IA_GENERATE_AND_PERSIST"
        | "UA_IA_DISPLAY_AND_PRINT"
        | "UA_IA_PIMS_TRANSMIT"
        | "UA_IA_VCP_TRANSMIT"
        | "UA_IA_VCP_USE_SEPARATE_FIELD"
        | "UA_ABN_COL_VCP_TRANSMIT"
        | "IHDIG_SDK"
        | "TENSEI_CONNECTION"
        | "TENSEI_RESULTS"
        | "LEISHMANIA_2SPOT_ENABLED"
        | "LEISH_FOUR_DX_ENABLED"
        | "THEIA_RESULTS"
        | "THEIA_CONNECTION"
        | "THEIA_FNA_ENABLED"
        | "THEIA_CANINE_EARSWAB_RESULTS"
        | "THEIA_FELINE_EARSWAB_RESULTS"
        | "THEIA_CANINE_BLOOD_RESULTS"
        | "THEIA_FELINE_BLOOD_RESULTS"
        | "THEIA_CANINE_EARSWAB_ENABLED"
        | "THEIA_FELINE_EARSWAB_ENABLED"
        | "THEIA_CANINE_BLOOD_ENABLED"
        | "THEIA_FELINE_BLOOD_ENABLED"
        | "CATONE_SMARTQC"
        | "CATALYSTDX_SMARTQC"
        | "VIEWPOINT_AWARENESS_POPUP"
        | "THEIA_BARCODE_ENTRY_ENABLED",
      options?: any
    ) {
      return FeatureFlagApiFp(configuration).fetchActiveStatus(
        featureFlagName,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * FeatureFlagApi - object-oriented interface
 * @export
 * @class FeatureFlagApi
 * @extends {BaseAPI}
 */
export class FeatureFlagApi extends BaseAPI {
  /**
   *
   * @summary Activate/deactivate a feature flag.
   * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
   * @param {FeatureFlagActivateDto} [body] The activation status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureFlagApi
   */
  public activate(
    featureFlagName:
      | "SNAP_PRO_FIRMWARE_POLLING"
      | "REFERENCE_LAB"
      | "VC_PLUS_LOCALIZE_RESULTS"
      | "UA_IA_GENERATE_AND_PERSIST"
      | "UA_IA_DISPLAY_AND_PRINT"
      | "UA_IA_PIMS_TRANSMIT"
      | "UA_IA_VCP_TRANSMIT"
      | "UA_IA_VCP_USE_SEPARATE_FIELD"
      | "UA_ABN_COL_VCP_TRANSMIT"
      | "IHDIG_SDK"
      | "TENSEI_CONNECTION"
      | "TENSEI_RESULTS"
      | "LEISHMANIA_2SPOT_ENABLED"
      | "LEISH_FOUR_DX_ENABLED"
      | "THEIA_RESULTS"
      | "THEIA_CONNECTION"
      | "THEIA_FNA_ENABLED"
      | "THEIA_CANINE_EARSWAB_RESULTS"
      | "THEIA_FELINE_EARSWAB_RESULTS"
      | "THEIA_CANINE_BLOOD_RESULTS"
      | "THEIA_FELINE_BLOOD_RESULTS"
      | "THEIA_CANINE_EARSWAB_ENABLED"
      | "THEIA_FELINE_EARSWAB_ENABLED"
      | "THEIA_CANINE_BLOOD_ENABLED"
      | "THEIA_FELINE_BLOOD_ENABLED"
      | "CATONE_SMARTQC"
      | "CATALYSTDX_SMARTQC"
      | "VIEWPOINT_AWARENESS_POPUP"
      | "THEIA_BARCODE_ENTRY_ENABLED",
    body?: FeatureFlagActivateDto,
    options?: any
  ) {
    return FeatureFlagApiFp(this.configuration).activate(
      featureFlagName,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active status of a feature flag.
   * @param {"SNAP_PRO_FIRMWARE_POLLING" | "REFERENCE_LAB" | "VC_PLUS_LOCALIZE_RESULTS" | "UA_IA_GENERATE_AND_PERSIST" | "UA_IA_DISPLAY_AND_PRINT" | "UA_IA_PIMS_TRANSMIT" | "UA_IA_VCP_TRANSMIT" | "UA_IA_VCP_USE_SEPARATE_FIELD" | "UA_ABN_COL_VCP_TRANSMIT" | "IHDIG_SDK" | "TENSEI_CONNECTION" | "TENSEI_RESULTS" | "LEISHMANIA_2SPOT_ENABLED" | "LEISH_FOUR_DX_ENABLED" | "THEIA_RESULTS" | "THEIA_CONNECTION" | "THEIA_FNA_ENABLED" | "THEIA_CANINE_EARSWAB_RESULTS" | "THEIA_FELINE_EARSWAB_RESULTS" | "THEIA_CANINE_BLOOD_RESULTS" | "THEIA_FELINE_BLOOD_RESULTS" | "THEIA_CANINE_EARSWAB_ENABLED" | "THEIA_FELINE_EARSWAB_ENABLED" | "THEIA_CANINE_BLOOD_ENABLED" | "THEIA_FELINE_BLOOD_ENABLED" | "CATONE_SMARTQC" | "CATALYSTDX_SMARTQC" | "VIEWPOINT_AWARENESS_POPUP" | "THEIA_BARCODE_ENTRY_ENABLED"} featureFlagName The feature flag name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeatureFlagApi
   */
  public fetchActiveStatus(
    featureFlagName:
      | "SNAP_PRO_FIRMWARE_POLLING"
      | "REFERENCE_LAB"
      | "VC_PLUS_LOCALIZE_RESULTS"
      | "UA_IA_GENERATE_AND_PERSIST"
      | "UA_IA_DISPLAY_AND_PRINT"
      | "UA_IA_PIMS_TRANSMIT"
      | "UA_IA_VCP_TRANSMIT"
      | "UA_IA_VCP_USE_SEPARATE_FIELD"
      | "UA_ABN_COL_VCP_TRANSMIT"
      | "IHDIG_SDK"
      | "TENSEI_CONNECTION"
      | "TENSEI_RESULTS"
      | "LEISHMANIA_2SPOT_ENABLED"
      | "LEISH_FOUR_DX_ENABLED"
      | "THEIA_RESULTS"
      | "THEIA_CONNECTION"
      | "THEIA_FNA_ENABLED"
      | "THEIA_CANINE_EARSWAB_RESULTS"
      | "THEIA_FELINE_EARSWAB_RESULTS"
      | "THEIA_CANINE_BLOOD_RESULTS"
      | "THEIA_FELINE_BLOOD_RESULTS"
      | "THEIA_CANINE_EARSWAB_ENABLED"
      | "THEIA_FELINE_EARSWAB_ENABLED"
      | "THEIA_CANINE_BLOOD_ENABLED"
      | "THEIA_FELINE_BLOOD_ENABLED"
      | "CATONE_SMARTQC"
      | "CATALYSTDX_SMARTQC"
      | "VIEWPOINT_AWARENESS_POPUP"
      | "THEIA_BARCODE_ENTRY_ENABLED",
    options?: any
  ) {
    return FeatureFlagApiFp(this.configuration).fetchActiveStatus(
      featureFlagName,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * GraphingApi - fetch parameter creator
 * @export
 */
export const GraphingApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch graphable data points for a given assay/patient combination
     * @param {number} patientId ID of the patient
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType Type of the instrument to base the graph data on
     * @param {string} assayIdentityName The assay identity name
     * @param {number} [sampleTypeId] The ID of the sample type to use. Required for non-Catalyst instruments
     * @param {string} [fromDate] Date to collect data from
     * @param {string} [toDate] Date to collect data to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGraphableData(
      patientId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      assayIdentityName: string,
      sampleTypeId?: number,
      fromDate?: string,
      toDate?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling fetchGraphableData."
        );
      }
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling fetchGraphableData."
        );
      }
      // verify required parameter 'assayIdentityName' is not null or undefined
      if (assayIdentityName === null || assayIdentityName === undefined) {
        throw new RequiredError(
          "assayIdentityName",
          "Required parameter assayIdentityName was null or undefined when calling fetchGraphableData."
        );
      }
      const localVarPath = `/graph/dataPoints`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientId !== undefined) {
        localVarQueryParameter["patientId"] = patientId;
      }

      if (instrumentType !== undefined) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      if (assayIdentityName !== undefined) {
        localVarQueryParameter["assayIdentityName"] = assayIdentityName;
      }

      if (sampleTypeId !== undefined) {
        localVarQueryParameter["sampleTypeId"] = sampleTypeId;
      }

      if (fromDate !== undefined) {
        localVarQueryParameter["fromDate"] =
          (fromDate as any) instanceof Date
            ? (fromDate as any).toISOString().substr(0, 10)
            : fromDate;
      }

      if (toDate !== undefined) {
        localVarQueryParameter["toDate"] =
          (toDate as any) instanceof Date
            ? (toDate as any).toISOString().substr(0, 10)
            : toDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GraphingApi - functional programming interface
 * @export
 */
export const GraphingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Fetch graphable data points for a given assay/patient combination
     * @param {number} patientId ID of the patient
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType Type of the instrument to base the graph data on
     * @param {string} assayIdentityName The assay identity name
     * @param {number} [sampleTypeId] The ID of the sample type to use. Required for non-Catalyst instruments
     * @param {string} [fromDate] Date to collect data from
     * @param {string} [toDate] Date to collect data to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGraphableData(
      patientId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      assayIdentityName: string,
      sampleTypeId?: number,
      fromDate?: string,
      toDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GraphDataDto> {
      const localVarFetchArgs = GraphingApiFetchParamCreator(
        configuration
      ).fetchGraphableData(
        patientId,
        instrumentType,
        assayIdentityName,
        sampleTypeId,
        fromDate,
        toDate,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * GraphingApi - factory interface
 * @export
 */
export const GraphingApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch graphable data points for a given assay/patient combination
     * @param {number} patientId ID of the patient
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType Type of the instrument to base the graph data on
     * @param {string} assayIdentityName The assay identity name
     * @param {number} [sampleTypeId] The ID of the sample type to use. Required for non-Catalyst instruments
     * @param {string} [fromDate] Date to collect data from
     * @param {string} [toDate] Date to collect data to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchGraphableData(
      patientId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      assayIdentityName: string,
      sampleTypeId?: number,
      fromDate?: string,
      toDate?: string,
      options?: any
    ) {
      return GraphingApiFp(configuration).fetchGraphableData(
        patientId,
        instrumentType,
        assayIdentityName,
        sampleTypeId,
        fromDate,
        toDate,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * GraphingApi - object-oriented interface
 * @export
 * @class GraphingApi
 * @extends {BaseAPI}
 */
export class GraphingApi extends BaseAPI {
  /**
   *
   * @summary Fetch graphable data points for a given assay/patient combination
   * @param {number} patientId ID of the patient
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType Type of the instrument to base the graph data on
   * @param {string} assayIdentityName The assay identity name
   * @param {number} [sampleTypeId] The ID of the sample type to use. Required for non-Catalyst instruments
   * @param {string} [fromDate] Date to collect data from
   * @param {string} [toDate] Date to collect data to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GraphingApi
   */
  public fetchGraphableData(
    patientId: number,
    instrumentType:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    assayIdentityName: string,
    sampleTypeId?: number,
    fromDate?: string,
    toDate?: string,
    options?: any
  ) {
    return GraphingApiFp(this.configuration).fetchGraphableData(
      patientId,
      instrumentType,
      assayIdentityName,
      sampleTypeId,
      fromDate,
      toDate,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * IhdigApi - fetch parameter creator
 * @export
 */
export const IhdigApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the current settings for the IHDIG SDK
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientSettings(options: any = {}): FetchArgs {
      const localVarPath = `/ihdig/settings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post a registration key to be used by the IHDIG SDK
     * @param {RegistrationKeyMissionPayload} body The registration key payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey(
      body: RegistrationKeyMissionPayload,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling postRegistrationKey."
        );
      }
      const localVarPath = `/ihdig/registrationKey`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RegistrationKeyMissionPayload" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Post an IVLS ID and a registration key to be used by the IHDIG SDK
     * @param {string} ivlsId IVLS ID of the system to be registered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey_1(ivlsId: string, options: any = {}): FetchArgs {
      // verify required parameter 'ivlsId' is not null or undefined
      if (ivlsId === null || ivlsId === undefined) {
        throw new RequiredError(
          "ivlsId",
          "Required parameter ivlsId was null or undefined when calling postRegistrationKey_1."
        );
      }
      const localVarPath = `/ihdig/registrationKey/{ivlsId}`.replace(
        `{${"ivlsId"}}`,
        encodeURIComponent(String(ivlsId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IhdigApi - functional programming interface
 * @export
 */
export const IhdigApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the current settings for the IHDIG SDK
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientSettings(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IhdigClientSettings> {
      const localVarFetchArgs =
        IhdigApiFetchParamCreator(configuration).getClientSettings(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Post a registration key to be used by the IHDIG SDK
     * @param {RegistrationKeyMissionPayload} body The registration key payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey(
      body: RegistrationKeyMissionPayload,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = IhdigApiFetchParamCreator(
        configuration
      ).postRegistrationKey(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Post an IVLS ID and a registration key to be used by the IHDIG SDK
     * @param {string} ivlsId IVLS ID of the system to be registered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey_1(
      ivlsId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = IhdigApiFetchParamCreator(
        configuration
      ).postRegistrationKey_1(ivlsId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * IhdigApi - factory interface
 * @export
 */
export const IhdigApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the current settings for the IHDIG SDK
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientSettings(options?: any) {
      return IhdigApiFp(configuration).getClientSettings(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Post a registration key to be used by the IHDIG SDK
     * @param {RegistrationKeyMissionPayload} body The registration key payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey(body: RegistrationKeyMissionPayload, options?: any) {
      return IhdigApiFp(configuration).postRegistrationKey(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Post an IVLS ID and a registration key to be used by the IHDIG SDK
     * @param {string} ivlsId IVLS ID of the system to be registered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRegistrationKey_1(ivlsId: string, options?: any) {
      return IhdigApiFp(configuration).postRegistrationKey_1(ivlsId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * IhdigApi - object-oriented interface
 * @export
 * @class IhdigApi
 * @extends {BaseAPI}
 */
export class IhdigApi extends BaseAPI {
  /**
   *
   * @summary Get the current settings for the IHDIG SDK
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IhdigApi
   */
  public getClientSettings(options?: any) {
    return IhdigApiFp(this.configuration).getClientSettings(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Post a registration key to be used by the IHDIG SDK
   * @param {RegistrationKeyMissionPayload} body The registration key payload.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IhdigApi
   */
  public postRegistrationKey(
    body: RegistrationKeyMissionPayload,
    options?: any
  ) {
    return IhdigApiFp(this.configuration).postRegistrationKey(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Post an IVLS ID and a registration key to be used by the IHDIG SDK
   * @param {string} ivlsId IVLS ID of the system to be registered.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IhdigApi
   */
  public postRegistrationKey_1(ivlsId: string, options?: any) {
    return IhdigApiFp(this.configuration).postRegistrationKey_1(
      ivlsId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentApi - fetch parameter creator
 * @export
 */
export const InstrumentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCrimsonProperties(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchCrimsonProperties."
        );
      }
      const localVarPath =
        `/instrument/crimson/{instrumentId}/properties`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch instrument reminder codes.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentReminders(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentReminders."
        );
      }
      const localVarPath =
        `/instruments/hematology/{instrumentId}/reminders`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get instrument status.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentStatus."
        );
      }
      const localVarPath = `/instruments/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch instrument performance report.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPerformanceReport(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchPerformanceReport."
        );
      }
      const localVarPath =
        `/instruments/hematology/{instrumentId}/performanceReportName`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Asynchronous get properties for instrument. Will return properties via push message.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertiesAsync(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchPropertiesAsync."
        );
      }
      const localVarPath =
        `/instrument/{instrumentId}/properties/async`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save properties for crimson instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {CrimsonPropertiesDto} body Crimson properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCrimsonProperties(
      instrumentId: number,
      body: CrimsonPropertiesDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling saveCrimsonProperties."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveCrimsonProperties."
        );
      }
      const localVarPath =
        `/instrument/crimson/{instrumentId}/properties`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CrimsonPropertiesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {InstrumentLoggingPropertyDto} body Logging properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveInstrumentLoggingProperties(
      instrumentId: number,
      body: InstrumentLoggingPropertyDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling saveInstrumentLoggingProperties."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveInstrumentLoggingProperties."
        );
      }
      const localVarPath =
        `/instrument/{instrumentId}/properties/logging`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentLoggingPropertyDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save properties for lasercyte instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {LaserCytePropertiesDto} body Lasercyte properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLaserCyteProperties(
      instrumentId: number,
      body: LaserCytePropertiesDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling saveLaserCyteProperties."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveLaserCyteProperties."
        );
      }
      const localVarPath =
        `/instrument/lasercyte/{instrumentId}/properties`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"LaserCytePropertiesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Start target instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startupInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling startupInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/startup`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validates the bar code of an instrument consumable.
     * @param {number} instrumentId The instrument ID.
     * @param {BarcodeValidationRequestDto} body The details of the bar code validation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateBarcode(
      instrumentId: number,
      body: BarcodeValidationRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling validateBarcode."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling validateBarcode."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/barcode`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BarcodeValidationRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentApi - functional programming interface
 * @export
 */
export const InstrumentApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCrimsonProperties(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CrimsonPropertiesDto> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchCrimsonProperties(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch instrument reminder codes.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentReminders(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchInstrumentReminders(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get instrument status.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<DetailedInstrumentStatusDto> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchInstrumentStatus(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch instrument performance report.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPerformanceReport(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchPerformanceReport(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Asynchronous get properties for instrument. Will return properties via push message.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertiesAsync(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchPropertiesAsync(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save properties for crimson instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {CrimsonPropertiesDto} body Crimson properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCrimsonProperties(
      instrumentId: number,
      body: CrimsonPropertiesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).saveCrimsonProperties(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {InstrumentLoggingPropertyDto} body Logging properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveInstrumentLoggingProperties(
      instrumentId: number,
      body: InstrumentLoggingPropertyDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).saveInstrumentLoggingProperties(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save properties for lasercyte instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {LaserCytePropertiesDto} body Lasercyte properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLaserCyteProperties(
      instrumentId: number,
      body: LaserCytePropertiesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).saveLaserCyteProperties(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Start target instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startupInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).startupInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validates the bar code of an instrument consumable.
     * @param {number} instrumentId The instrument ID.
     * @param {BarcodeValidationRequestDto} body The details of the bar code validation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateBarcode(
      instrumentId: number,
      body: BarcodeValidationRequestDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<BarcodeValidationResponseDto> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).validateBarcode(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentApi - factory interface
 * @export
 */
export const InstrumentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCrimsonProperties(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchCrimsonProperties(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch instrument reminder codes.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentReminders(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchInstrumentReminders(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get instrument status.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchInstrumentStatus(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch instrument performance report.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPerformanceReport(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchPerformanceReport(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Asynchronous get properties for instrument. Will return properties via push message.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertiesAsync(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchPropertiesAsync(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save properties for crimson instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {CrimsonPropertiesDto} body Crimson properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveCrimsonProperties(
      instrumentId: number,
      body: CrimsonPropertiesDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).saveCrimsonProperties(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save properties for instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {InstrumentLoggingPropertyDto} body Logging properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveInstrumentLoggingProperties(
      instrumentId: number,
      body: InstrumentLoggingPropertyDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).saveInstrumentLoggingProperties(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save properties for lasercyte instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {LaserCytePropertiesDto} body Lasercyte properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveLaserCyteProperties(
      instrumentId: number,
      body: LaserCytePropertiesDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).saveLaserCyteProperties(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Start target instrument.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startupInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).startupInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Validates the bar code of an instrument consumable.
     * @param {number} instrumentId The instrument ID.
     * @param {BarcodeValidationRequestDto} body The details of the bar code validation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateBarcode(
      instrumentId: number,
      body: BarcodeValidationRequestDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).validateBarcode(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentApi - object-oriented interface
 * @export
 * @class InstrumentApi
 * @extends {BaseAPI}
 */
export class InstrumentApi extends BaseAPI {
  /**
   *
   * @summary Get properties for instrument.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchCrimsonProperties(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchCrimsonProperties(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch instrument reminder codes.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchInstrumentReminders(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchInstrumentReminders(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get instrument status.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchInstrumentStatus(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchInstrumentStatus(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch instrument performance report.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchPerformanceReport(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchPerformanceReport(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Asynchronous get properties for instrument. Will return properties via push message.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchPropertiesAsync(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchPropertiesAsync(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save properties for crimson instrument.
   * @param {number} instrumentId The instrument Id.
   * @param {CrimsonPropertiesDto} body Crimson properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public saveCrimsonProperties(
    instrumentId: number,
    body: CrimsonPropertiesDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).saveCrimsonProperties(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save properties for instrument.
   * @param {number} instrumentId The instrument Id.
   * @param {InstrumentLoggingPropertyDto} body Logging properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public saveInstrumentLoggingProperties(
    instrumentId: number,
    body: InstrumentLoggingPropertyDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).saveInstrumentLoggingProperties(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save properties for lasercyte instrument.
   * @param {number} instrumentId The instrument Id.
   * @param {LaserCytePropertiesDto} body Lasercyte properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public saveLaserCyteProperties(
    instrumentId: number,
    body: LaserCytePropertiesDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).saveLaserCyteProperties(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Start target instrument.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public startupInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).startupInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Validates the bar code of an instrument consumable.
   * @param {number} instrumentId The instrument ID.
   * @param {BarcodeValidationRequestDto} body The details of the bar code validation request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public validateBarcode(
    instrumentId: number,
    body: BarcodeValidationRequestDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).validateBarcode(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentAlertsApi - fetch parameter creator
 * @export
 */
export const InstrumentAlertsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get all instrument alerts for all instruments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllInstrumentAlerts(options: any = {}): FetchArgs {
      const localVarPath = `/instruments/alerts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all instrument alerts for a specific instrument
     * @param {number} instrumentId The ID of the instrument to fetch alerts for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentAlerts(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentAlerts."
        );
      }
      const localVarPath = `/instruments/{instrumentId}/alerts`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform the specified action for the given alert and instrument
     * @param {number} instrumentId The ID of the instrument to perform the alert action on.
     * @param {AlertActionDto} [body] Details directing which action to perform on which alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performAlertAction(
      instrumentId: number,
      body?: AlertActionDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling performAlertAction."
        );
      }
      const localVarPath = `/instruments/{instrumentId}/alertAction`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentAlertActionDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentAlertsApi - functional programming interface
 * @export
 */
export const InstrumentAlertsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all instrument alerts for all instruments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllInstrumentAlerts(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<InstrumentAlertDto>> {
      const localVarFetchArgs =
        InstrumentAlertsApiFetchParamCreator(
          configuration
        ).fetchAllInstrumentAlerts(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all instrument alerts for a specific instrument
     * @param {number} instrumentId The ID of the instrument to fetch alerts for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentAlerts(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InstrumentAlertDto> {
      const localVarFetchArgs = InstrumentAlertsApiFetchParamCreator(
        configuration
      ).fetchInstrumentAlerts(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform the specified action for the given alert and instrument
     * @param {number} instrumentId The ID of the instrument to perform the alert action on.
     * @param {AlertActionDto} [body] Details directing which action to perform on which alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performAlertAction(
      instrumentId: number,
      body?: AlertActionDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentAlertsApiFetchParamCreator(
        configuration
      ).performAlertAction(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentAlertsApi - factory interface
 * @export
 */
export const InstrumentAlertsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get all instrument alerts for all instruments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllInstrumentAlerts(options?: any) {
      return InstrumentAlertsApiFp(configuration).fetchAllInstrumentAlerts(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all instrument alerts for a specific instrument
     * @param {number} instrumentId The ID of the instrument to fetch alerts for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentAlerts(instrumentId: number, options?: any) {
      return InstrumentAlertsApiFp(configuration).fetchInstrumentAlerts(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Perform the specified action for the given alert and instrument
     * @param {number} instrumentId The ID of the instrument to perform the alert action on.
     * @param {AlertActionDto} [body] Details directing which action to perform on which alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performAlertAction(
      instrumentId: number,
      body?: AlertActionDto,
      options?: any
    ) {
      return InstrumentAlertsApiFp(configuration).performAlertAction(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentAlertsApi - object-oriented interface
 * @export
 * @class InstrumentAlertsApi
 * @extends {BaseAPI}
 */
export class InstrumentAlertsApi extends BaseAPI {
  /**
   *
   * @summary Get all instrument alerts for all instruments
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentAlertsApi
   */
  public fetchAllInstrumentAlerts(options?: any) {
    return InstrumentAlertsApiFp(this.configuration).fetchAllInstrumentAlerts(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all instrument alerts for a specific instrument
   * @param {number} instrumentId The ID of the instrument to fetch alerts for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentAlertsApi
   */
  public fetchInstrumentAlerts(instrumentId: number, options?: any) {
    return InstrumentAlertsApiFp(this.configuration).fetchInstrumentAlerts(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Perform the specified action for the given alert and instrument
   * @param {number} instrumentId The ID of the instrument to perform the alert action on.
   * @param {AlertActionDto} [body] Details directing which action to perform on which alert.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentAlertsApi
   */
  public performAlertAction(
    instrumentId: number,
    body?: AlertActionDto,
    options?: any
  ) {
    return InstrumentAlertsApiFp(this.configuration).performAlertAction(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentEventLogsApi - fetch parameter creator
 * @export
 */
export const InstrumentEventLogsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Request the instrument send event logs.
     * @param {number} instrumentId The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSendEventLogs(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestInstrumentSendEventLogs."
        );
      }
      const localVarPath = `/instrumentEventLogs/{instrumentId}`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentEventLogsApi - functional programming interface
 * @export
 */
export const InstrumentEventLogsApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Request the instrument send event logs.
     * @param {number} instrumentId The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSendEventLogs(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentEventLogsApiFetchParamCreator(
        configuration
      ).requestInstrumentSendEventLogs(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentEventLogsApi - factory interface
 * @export
 */
export const InstrumentEventLogsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Request the instrument send event logs.
     * @param {number} instrumentId The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSendEventLogs(instrumentId: number, options?: any) {
      return InstrumentEventLogsApiFp(
        configuration
      ).requestInstrumentSendEventLogs(instrumentId, options)(fetch, basePath);
    },
  };
};

/**
 * InstrumentEventLogsApi - object-oriented interface
 * @export
 * @class InstrumentEventLogsApi
 * @extends {BaseAPI}
 */
export class InstrumentEventLogsApi extends BaseAPI {
  /**
   *
   * @summary Request the instrument send event logs.
   * @param {number} instrumentId The id of the target instrument.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentEventLogsApi
   */
  public requestInstrumentSendEventLogs(instrumentId: number, options?: any) {
    return InstrumentEventLogsApiFp(
      this.configuration
    ).requestInstrumentSendEventLogs(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * InstrumentRunApi - fetch parameter creator
 * @export
 */
export const InstrumentRunApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Cancel a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelRun(instrumentRunId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling cancelRun."
        );
      }
      const localVarPath = `/instrumentRun/{instrumentRunId}/cancel`.replace(
        `{${"instrumentRunId"}}`,
        encodeURIComponent(String(instrumentRunId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit SNAP results - either manually entered or Snap PRO
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editSnapResult(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling editSnapResult."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/snap`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UserEnteredSnapResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(userEnteredSnapResultDto || {})
        : userEnteredSnapResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling editUserEnteredCrp."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/crp`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ManualCrpResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(manualCrpResultDto || {})
        : manualCrpResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling editUserEnteredMua."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/mua`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ManualUaResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(manualCrpResultDto || {})
        : manualCrpResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Execute a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeRun(instrumentRunId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling executeRun."
        );
      }
      const localVarPath = `/instrumentRun/{instrumentRunId}/execute`.replace(
        `{${"instrumentRunId"}}`,
        encodeURIComponent(String(instrumentRunId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get any requests for additional user input given the specified run!
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInputRequests(
      instrumentRunId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getUserInputRequests."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/userInputRequests`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get work request status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkRequestStatus(
      instrumentRunId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getWorkRequestStatus."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/workRequestStatus`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resets a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetSnapTimer(instrumentRunId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling resetSnapTimer."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/resetSnapTimer`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling saveUserEnteredCrp."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/crp`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ManualCrpResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(manualCrpResultDto || {})
        : manualCrpResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling saveUserEnteredMua."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/mua`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ManualUaResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(manualCrpResultDto || {})
        : manualCrpResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save user entered results for SNAP devices
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnap(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling saveUserEnteredSnap."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/results/snap`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UserEnteredSnapResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(userEnteredSnapResultDto || {})
        : userEnteredSnapResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save user entered results for SNAP devices while simultaneously creating a new run
     * @param {number} labRequestId LabRequest ID to save results to
     * @param {number} snapDeviceId Snap Device ID
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnapAndCreateRun(
      labRequestId: number,
      snapDeviceId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling saveUserEnteredSnapAndCreateRun."
        );
      }
      // verify required parameter 'snapDeviceId' is not null or undefined
      if (snapDeviceId === null || snapDeviceId === undefined) {
        throw new RequiredError(
          "snapDeviceId",
          "Required parameter snapDeviceId was null or undefined when calling saveUserEnteredSnapAndCreateRun."
        );
      }
      const localVarPath =
        `/instrumentRun/resultsAndRun/snap/{labRequestId}/{snapDeviceId}`
          .replace(
            `{${"labRequestId"}}`,
            encodeURIComponent(String(labRequestId))
          )
          .replace(
            `{${"snapDeviceId"}}`,
            encodeURIComponent(String(snapDeviceId))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UserEnteredSnapResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(userEnteredSnapResultDto || {})
        : userEnteredSnapResultDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Starts a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startSnapTimer(instrumentRunId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling startSnapTimer."
        );
      }
      const localVarPath =
        `/instrumentRun/{instrumentRunId}/startSnapTimer`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentRunApi - functional programming interface
 * @export
 */
export const InstrumentRunApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelRun(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).cancelRun(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit SNAP results - either manually entered or Snap PRO
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editSnapResult(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).editSnapResult(instrumentRunId, userEnteredSnapResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).editUserEnteredCrp(instrumentRunId, manualCrpResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).editUserEnteredMua(instrumentRunId, manualCrpResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Execute a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeRun(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).executeRun(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get any requests for additional user input given the specified run!
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInputRequests(
      instrumentRunId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<UserInputRequestDto>> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).getUserInputRequests(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get work request status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkRequestStatus(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WorkRequestStatusDto> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).getWorkRequestStatus(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resets a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetSnapTimer(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).resetSnapTimer(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).saveUserEnteredCrp(instrumentRunId, manualCrpResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).saveUserEnteredMua(instrumentRunId, manualCrpResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save user entered results for SNAP devices
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnap(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).saveUserEnteredSnap(instrumentRunId, userEnteredSnapResultDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save user entered results for SNAP devices while simultaneously creating a new run
     * @param {number} labRequestId LabRequest ID to save results to
     * @param {number} snapDeviceId Snap Device ID
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnapAndCreateRun(
      labRequestId: number,
      snapDeviceId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).saveUserEnteredSnapAndCreateRun(
        labRequestId,
        snapDeviceId,
        userEnteredSnapResultDto,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Starts a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startSnapTimer(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentRunApiFetchParamCreator(
        configuration
      ).startSnapTimer(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentRunApi - factory interface
 * @export
 */
export const InstrumentRunApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Cancel a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelRun(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).cancelRun(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Edit SNAP results - either manually entered or Snap PRO
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editSnapResult(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).editSnapResult(
        instrumentRunId,
        userEnteredSnapResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Edit user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).editUserEnteredCrp(
        instrumentRunId,
        manualCrpResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Edit user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).editUserEnteredMua(
        instrumentRunId,
        manualCrpResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Execute a run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeRun(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).executeRun(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get any requests for additional user input given the specified run!
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInputRequests(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).getUserInputRequests(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get work request status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorkRequestStatus(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).getWorkRequestStatus(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Resets a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetSnapTimer(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).resetSnapTimer(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save user entered results for CRP
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredCrp(
      instrumentRunId: number,
      manualCrpResultDto?: ManualCrpResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).saveUserEnteredCrp(
        instrumentRunId,
        manualCrpResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save user entered results for mUA
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredMua(
      instrumentRunId: number,
      manualCrpResultDto?: ManualUaResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).saveUserEnteredMua(
        instrumentRunId,
        manualCrpResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save user entered results for SNAP devices
     * @param {number} instrumentRunId Instrument run ID to save results to
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnap(
      instrumentRunId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).saveUserEnteredSnap(
        instrumentRunId,
        userEnteredSnapResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save user entered results for SNAP devices while simultaneously creating a new run
     * @param {number} labRequestId LabRequest ID to save results to
     * @param {number} snapDeviceId Snap Device ID
     * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveUserEnteredSnapAndCreateRun(
      labRequestId: number,
      snapDeviceId: number,
      userEnteredSnapResultDto?: UserEnteredSnapResultDto,
      options?: any
    ) {
      return InstrumentRunApiFp(configuration).saveUserEnteredSnapAndCreateRun(
        labRequestId,
        snapDeviceId,
        userEnteredSnapResultDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Starts a timer on a Snap run.  SNAP instrument runs only.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startSnapTimer(instrumentRunId: number, options?: any) {
      return InstrumentRunApiFp(configuration).startSnapTimer(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentRunApi - object-oriented interface
 * @export
 * @class InstrumentRunApi
 * @extends {BaseAPI}
 */
export class InstrumentRunApi extends BaseAPI {
  /**
   *
   * @summary Cancel a run.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public cancelRun(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).cancelRun(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Edit SNAP results - either manually entered or Snap PRO
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public editSnapResult(
    instrumentRunId: number,
    userEnteredSnapResultDto?: UserEnteredSnapResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).editSnapResult(
      instrumentRunId,
      userEnteredSnapResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Edit user entered results for CRP
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public editUserEnteredCrp(
    instrumentRunId: number,
    manualCrpResultDto?: ManualCrpResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).editUserEnteredCrp(
      instrumentRunId,
      manualCrpResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Edit user entered results for mUA
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public editUserEnteredMua(
    instrumentRunId: number,
    manualCrpResultDto?: ManualUaResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).editUserEnteredMua(
      instrumentRunId,
      manualCrpResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Execute a run.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public executeRun(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).executeRun(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get any requests for additional user input given the specified run!
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public getUserInputRequests(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).getUserInputRequests(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get work request status.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public getWorkRequestStatus(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).getWorkRequestStatus(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Resets a timer on a Snap run.  SNAP instrument runs only.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public resetSnapTimer(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).resetSnapTimer(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save user entered results for CRP
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {ManualCrpResultDto} [manualCrpResultDto] The user entered CRP result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public saveUserEnteredCrp(
    instrumentRunId: number,
    manualCrpResultDto?: ManualCrpResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).saveUserEnteredCrp(
      instrumentRunId,
      manualCrpResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save user entered results for mUA
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {ManualUaResultDto} [manualCrpResultDto] The user entered mUA result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public saveUserEnteredMua(
    instrumentRunId: number,
    manualCrpResultDto?: ManualUaResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).saveUserEnteredMua(
      instrumentRunId,
      manualCrpResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save user entered results for SNAP devices
   * @param {number} instrumentRunId Instrument run ID to save results to
   * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public saveUserEnteredSnap(
    instrumentRunId: number,
    userEnteredSnapResultDto?: UserEnteredSnapResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(this.configuration).saveUserEnteredSnap(
      instrumentRunId,
      userEnteredSnapResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save user entered results for SNAP devices while simultaneously creating a new run
   * @param {number} labRequestId LabRequest ID to save results to
   * @param {number} snapDeviceId Snap Device ID
   * @param {UserEnteredSnapResultDto} [userEnteredSnapResultDto] The user entered snap result DTO to save
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public saveUserEnteredSnapAndCreateRun(
    labRequestId: number,
    snapDeviceId: number,
    userEnteredSnapResultDto?: UserEnteredSnapResultDto,
    options?: any
  ) {
    return InstrumentRunApiFp(
      this.configuration
    ).saveUserEnteredSnapAndCreateRun(
      labRequestId,
      snapDeviceId,
      userEnteredSnapResultDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Starts a timer on a Snap run.  SNAP instrument runs only.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentRunApi
   */
  public startSnapTimer(instrumentRunId: number, options?: any) {
    return InstrumentRunApiFp(this.configuration).startSnapTimer(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentSettingsApi - fetch parameter creator
 * @export
 */
export const InstrumentSettingsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestInstrumentSetting."
        );
      }
      // verify required parameter 'settingType' is not null or undefined
      if (settingType === null || settingType === undefined) {
        throw new RequiredError(
          "settingType",
          "Required parameter settingType was null or undefined when calling requestInstrumentSetting."
        );
      }
      const localVarPath = `/settings/instrument/{instrumentId}/{settingType}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"settingType"}}`, encodeURIComponent(String(settingType)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to update
     * @param {string} body the proposed value of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      body: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateInstrumentSetting."
        );
      }
      // verify required parameter 'settingType' is not null or undefined
      if (settingType === null || settingType === undefined) {
        throw new RequiredError(
          "settingType",
          "Required parameter settingType was null or undefined when calling updateInstrumentSetting."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateInstrumentSetting."
        );
      }
      const localVarPath = `/settings/instrument/{instrumentId}/{settingType}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"settingType"}}`, encodeURIComponent(String(settingType)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"string" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentSettingsApi - functional programming interface
 * @export
 */
export const InstrumentSettingsApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentSettingsApiFetchParamCreator(
        configuration
      ).requestInstrumentSetting(instrumentId, settingType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to update
     * @param {string} body the proposed value of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      body: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentSettingsApiFetchParamCreator(
        configuration
      ).updateInstrumentSetting(instrumentId, settingType, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentSettingsApi - factory interface
 * @export
 */
export const InstrumentSettingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      options?: any
    ) {
      return InstrumentSettingsApiFp(configuration).requestInstrumentSetting(
        instrumentId,
        settingType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the specified instrument settings value
     * @param {number} instrumentId The instrument ID.
     * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to update
     * @param {string} body the proposed value of the setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentSetting(
      instrumentId: number,
      settingType:
        | "QC_AUTORUN_DATETIME"
        | "CONNECTION_TYPE"
        | "PATIENT_RUN_CUVETTE_MODE"
        | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
        | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
        | "SPEAKER_VOLUME"
        | "K_SCALAR"
        | "CL_SCALAR"
        | "NA_SCALAR"
        | "CA_OFFSET"
        | "CA_OFFSET_DATE"
        | "ALB_OFFSET"
        | "ALB_OFFSET_DATE"
        | "QSDMA_OFFSET"
        | "QSDMA_OFFSET_DATE"
        | "QSDMA_GAIN"
        | "QSDMA_GAIN_DATE",
      body: string,
      options?: any
    ) {
      return InstrumentSettingsApiFp(configuration).updateInstrumentSetting(
        instrumentId,
        settingType,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentSettingsApi - object-oriented interface
 * @export
 * @class InstrumentSettingsApi
 * @extends {BaseAPI}
 */
export class InstrumentSettingsApi extends BaseAPI {
  /**
   *
   * @summary Get the specified instrument settings value
   * @param {number} instrumentId The instrument ID.
   * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentSettingsApi
   */
  public requestInstrumentSetting(
    instrumentId: number,
    settingType:
      | "QC_AUTORUN_DATETIME"
      | "CONNECTION_TYPE"
      | "PATIENT_RUN_CUVETTE_MODE"
      | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
      | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
      | "SPEAKER_VOLUME"
      | "K_SCALAR"
      | "CL_SCALAR"
      | "NA_SCALAR"
      | "CA_OFFSET"
      | "CA_OFFSET_DATE"
      | "ALB_OFFSET"
      | "ALB_OFFSET_DATE"
      | "QSDMA_OFFSET"
      | "QSDMA_OFFSET_DATE"
      | "QSDMA_GAIN"
      | "QSDMA_GAIN_DATE",
    options?: any
  ) {
    return InstrumentSettingsApiFp(this.configuration).requestInstrumentSetting(
      instrumentId,
      settingType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the specified instrument settings value
   * @param {number} instrumentId The instrument ID.
   * @param {"QC_AUTORUN_DATETIME" | "CONNECTION_TYPE" | "PATIENT_RUN_CUVETTE_MODE" | "PATIENT_RUN_IMAGE_CAPTURE_COUNT" | "PATIENT_RUN_IMAGE_TRANSFER_COUNT" | "SPEAKER_VOLUME" | "K_SCALAR" | "CL_SCALAR" | "NA_SCALAR" | "CA_OFFSET" | "CA_OFFSET_DATE" | "ALB_OFFSET" | "ALB_OFFSET_DATE" | "QSDMA_OFFSET" | "QSDMA_OFFSET_DATE" | "QSDMA_GAIN" | "QSDMA_GAIN_DATE"} settingType the setting type to update
   * @param {string} body the proposed value of the setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentSettingsApi
   */
  public updateInstrumentSetting(
    instrumentId: number,
    settingType:
      | "QC_AUTORUN_DATETIME"
      | "CONNECTION_TYPE"
      | "PATIENT_RUN_CUVETTE_MODE"
      | "PATIENT_RUN_IMAGE_CAPTURE_COUNT"
      | "PATIENT_RUN_IMAGE_TRANSFER_COUNT"
      | "SPEAKER_VOLUME"
      | "K_SCALAR"
      | "CL_SCALAR"
      | "NA_SCALAR"
      | "CA_OFFSET"
      | "CA_OFFSET_DATE"
      | "ALB_OFFSET"
      | "ALB_OFFSET_DATE"
      | "QSDMA_OFFSET"
      | "QSDMA_OFFSET_DATE"
      | "QSDMA_GAIN"
      | "QSDMA_GAIN_DATE",
    body: string,
    options?: any
  ) {
    return InstrumentSettingsApiFp(this.configuration).updateInstrumentSetting(
      instrumentId,
      settingType,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentTypeApi - fetch parameter creator
 * @export
 */
export const InstrumentTypeApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get instrument types by species.
     * @param {number} [speciesId] The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesBySpecies(speciesId?: number, options: any = {}): FetchArgs {
      const localVarPath = `/instrumentType/bySpecies`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (speciesId !== undefined) {
        localVarQueryParameter["speciesId"] = speciesId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get instrument types for record columns.
     * @param {boolean} [isQualityControl] The quality control switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesForRecordColumns(
      isQualityControl?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/instrumentType/forRecordColumns`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (isQualityControl !== undefined) {
        localVarQueryParameter["isQualityControl"] = isQualityControl;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Checks if the given instrument type with the given software version supports this species
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType
     * @param {number} speciesId
     * @param {string} [swVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softwareSupportsSpecies(
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      speciesId: number,
      swVersion?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling softwareSupportsSpecies."
        );
      }
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling softwareSupportsSpecies."
        );
      }
      const localVarPath =
        `/instrumentType/{instrumentType}/{speciesId}/supported`
          .replace(
            `{${"instrumentType"}}`,
            encodeURIComponent(String(instrumentType))
          )
          .replace(`{${"speciesId"}}`, encodeURIComponent(String(speciesId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (swVersion !== undefined) {
        localVarQueryParameter["swVersion"] = swVersion;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get instrument types by region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    typesByRegion(options: any = {}): FetchArgs {
      const localVarPath = `/instrumentType/byRegion`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentTypeApi - functional programming interface
 * @export
 */
export const InstrumentTypeApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get instrument types by species.
     * @param {number} [speciesId] The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesBySpecies(
      speciesId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = InstrumentTypeApiFetchParamCreator(
        configuration
      ).getTypesBySpecies(speciesId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get instrument types for record columns.
     * @param {boolean} [isQualityControl] The quality control switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesForRecordColumns(
      isQualityControl?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = InstrumentTypeApiFetchParamCreator(
        configuration
      ).getTypesForRecordColumns(isQualityControl, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Checks if the given instrument type with the given software version supports this species
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType
     * @param {number} speciesId
     * @param {string} [swVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softwareSupportsSpecies(
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      speciesId: number,
      swVersion?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = InstrumentTypeApiFetchParamCreator(
        configuration
      ).softwareSupportsSpecies(instrumentType, speciesId, swVersion, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get instrument types by region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    typesByRegion(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        InstrumentTypeApiFetchParamCreator(configuration).typesByRegion(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentTypeApi - factory interface
 * @export
 */
export const InstrumentTypeApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get instrument types by species.
     * @param {number} [speciesId] The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesBySpecies(speciesId?: number, options?: any) {
      return InstrumentTypeApiFp(configuration).getTypesBySpecies(
        speciesId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get instrument types for record columns.
     * @param {boolean} [isQualityControl] The quality control switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTypesForRecordColumns(isQualityControl?: boolean, options?: any) {
      return InstrumentTypeApiFp(configuration).getTypesForRecordColumns(
        isQualityControl,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Checks if the given instrument type with the given software version supports this species
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType
     * @param {number} speciesId
     * @param {string} [swVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    softwareSupportsSpecies(
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      speciesId: number,
      swVersion?: string,
      options?: any
    ) {
      return InstrumentTypeApiFp(configuration).softwareSupportsSpecies(
        instrumentType,
        speciesId,
        swVersion,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get instrument types by region.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    typesByRegion(options?: any) {
      return InstrumentTypeApiFp(configuration).typesByRegion(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * InstrumentTypeApi - object-oriented interface
 * @export
 * @class InstrumentTypeApi
 * @extends {BaseAPI}
 */
export class InstrumentTypeApi extends BaseAPI {
  /**
   *
   * @summary Get instrument types by species.
   * @param {number} [speciesId] The species id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentTypeApi
   */
  public getTypesBySpecies(speciesId?: number, options?: any) {
    return InstrumentTypeApiFp(this.configuration).getTypesBySpecies(
      speciesId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get instrument types for record columns.
   * @param {boolean} [isQualityControl] The quality control switch.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentTypeApi
   */
  public getTypesForRecordColumns(isQualityControl?: boolean, options?: any) {
    return InstrumentTypeApiFp(this.configuration).getTypesForRecordColumns(
      isQualityControl,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Checks if the given instrument type with the given software version supports this species
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType
   * @param {number} speciesId
   * @param {string} [swVersion]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentTypeApi
   */
  public softwareSupportsSpecies(
    instrumentType:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    speciesId: number,
    swVersion?: string,
    options?: any
  ) {
    return InstrumentTypeApiFp(this.configuration).softwareSupportsSpecies(
      instrumentType,
      speciesId,
      swVersion,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get instrument types by region.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentTypeApi
   */
  public typesByRegion(options?: any) {
    return InstrumentTypeApiFp(this.configuration).typesByRegion(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * InstrumentUpgradeApi - fetch parameter creator
 * @export
 */
export const InstrumentUpgradeApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Execute upgrade to version.
     * @param {number} instrumentId The instrument Id.
     * @param {string} version Upgrade version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeNow(
      instrumentId: number,
      version: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling upgradeNow."
        );
      }
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          "version",
          "Required parameter version was null or undefined when calling upgradeNow."
        );
      }
      const localVarPath = `/instruments/{instrumentId}/upgrade`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (version !== undefined) {
        localVarQueryParameter["version"] = version;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentUpgradeApi - functional programming interface
 * @export
 */
export const InstrumentUpgradeApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Execute upgrade to version.
     * @param {number} instrumentId The instrument Id.
     * @param {string} version Upgrade version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeNow(
      instrumentId: number,
      version: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = InstrumentUpgradeApiFetchParamCreator(
        configuration
      ).upgradeNow(instrumentId, version, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentUpgradeApi - factory interface
 * @export
 */
export const InstrumentUpgradeApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Execute upgrade to version.
     * @param {number} instrumentId The instrument Id.
     * @param {string} version Upgrade version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeNow(instrumentId: number, version: string, options?: any) {
      return InstrumentUpgradeApiFp(configuration).upgradeNow(
        instrumentId,
        version,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentUpgradeApi - object-oriented interface
 * @export
 * @class InstrumentUpgradeApi
 * @extends {BaseAPI}
 */
export class InstrumentUpgradeApi extends BaseAPI {
  /**
   *
   * @summary Execute upgrade to version.
   * @param {number} instrumentId The instrument Id.
   * @param {string} version Upgrade version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentUpgradeApi
   */
  public upgradeNow(instrumentId: number, version: string, options?: any) {
    return InstrumentUpgradeApiFp(this.configuration).upgradeNow(
      instrumentId,
      version,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * LabRequestApi - fetch parameter creator
 * @export
 */
export const LabRequestApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * This is called through Add Test->Append Results.
     * @summary Append lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to append.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    append(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling append."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling append."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/append`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;ExecuteInstrumentRunDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copy and add tests.  This is the Add tests->New Results workflow in the JavaFX client.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to add to the new copied lab request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyAndAddTests(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling copyAndAddTests."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling copyAndAddTests."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/copyAndAddTests`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;ExecuteInstrumentRunDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Executes a new lab request.  From the GUI this is called from through the Analyze Sample button.
     * @summary Execute a new lab request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNew(body: ExecuteLabRequestDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeNew."
        );
      }
      const localVarPath = `/labRequest`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ExecuteLabRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is called through the Census->Run button.  The requisition id is ignored for this request.
     * @summary Execute a new lab request from a census request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNewFromCensus(
      body: ExecuteLabRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeNewFromCensus."
        );
      }
      const localVarPath = `/labRequest/census`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ExecuteLabRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is called through the Pending->Run button.
     * @summary Execute a new lab request from a pending request.
     * @param {ExecutePimsRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePending(body: ExecutePimsRequestDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executePending."
        );
      }
      const localVarPath = `/labRequest/pending`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ExecutePimsRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get detailed results for completed lab request.
     * @param {number} labRequestId The lab request id.
     * @param {number} [previousRunDepth] The number of previous matching runs to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedResults(
      labRequestId: number,
      previousRunDepth?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling getDetailedResults."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/detailed`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (previousRunDepth !== undefined) {
        localVarQueryParameter["previousRunDepth"] = previousRunDepth;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is currently used in the GUI to determine whether to allow the user to send a cropped SediVue image to PIMS or not.
     * @summary Get lab request sent to PIMS by ID.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSentToPims(labRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling getSentToPims."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/sentToPims`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This GET has side-effects.  It will set the found runs to a status of WAITING_FOR_RESULTS.   This is used to populate the tabs when entering a SNAP result for a running SNAP run.
     * @summary Get all SNAP runs awaiting results.
     * @param {number} labRequestId The lab request id.
     * @param {number} instrumentRunId The id of the instrument run that was selected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapRunsAwaitingResults(
      labRequestId: number,
      instrumentRunId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling getSnapRunsAwaitingResults."
        );
      }
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getSnapRunsAwaitingResults."
        );
      }
      const localVarPath =
        `/labRequest/{labRequestId}/snapRunsAwaitingResults/{instrumentRunId}`
          .replace(
            `{${"labRequestId"}}`,
            encodeURIComponent(String(labRequestId))
          )
          .replace(
            `{${"instrumentRunId"}}`,
            encodeURIComponent(String(instrumentRunId))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get instrument run ids by InstrumentTypes.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI">} instrumentType The instrument types to query on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentRunIds(
      labRequestId: number,
      instrumentType: Array<
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI"
      >,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling instrumentRunIds."
        );
      }
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling instrumentRunIds."
        );
      }
      const localVarPath =
        `/labRequest/{labRequestId}/instrumentRunIds`.replace(
          `{${"labRequestId"}}`,
          encodeURIComponent(String(labRequestId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentType) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if request is complete. Is there an associated pending request or a currently running lab request?
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isComplete(labRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling isComplete."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/isComplete`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is called through Add Test->Merge/Replace Results.
     * @summary Merge lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to merge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    merge(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling merge."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling merge."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/merge`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;ExecuteInstrumentRunDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previousRunsForUndoMerge(
      labRequestId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling previousRunsForUndoMerge."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/undoMergeRuns`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resend results to PIMS.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendLabRequest(labRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling resendLabRequest."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/resendToPims`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is used to populate the running lab request pane in the GUI.
     * @summary Get all running lab requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequests(options: any = {}): FetchArgs {
      const localVarPath = `/labRequest/running`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is used by the ViewPoint client.
     * @summary Get all running lab requests, including runs with error status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequestsExtended(options: any = {}): FetchArgs {
      const localVarPath = `/labRequest/running/extended`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transfer a lab request to a different patient.
     * @param {number} labRequestId The lab request Id.
     * @param {number} body The patientId to transfer it to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transfer(labRequestId: number, body: number, options: any = {}): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling transfer."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling transfer."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/transfer`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"number" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    undoMerge(labRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling undoMerge."
        );
      }
      const localVarPath = `/labRequest/{labRequestId}/undoMerge`.replace(
        `{${"labRequestId"}}`,
        encodeURIComponent(String(labRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the supported add test types for this lab request/execute request combinations
     * @param {number} labRequestId The original lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs being requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSupportedAddTestTypes(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'labRequestId' is not null or undefined
      if (labRequestId === null || labRequestId === undefined) {
        throw new RequiredError(
          "labRequestId",
          "Required parameter labRequestId was null or undefined when calling validateSupportedAddTestTypes."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling validateSupportedAddTestTypes."
        );
      }
      const localVarPath =
        `/labRequest/{labRequestId}/addTest/validate`.replace(
          `{${"labRequestId"}}`,
          encodeURIComponent(String(labRequestId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;ExecuteInstrumentRunDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LabRequestApi - functional programming interface
 * @export
 */
export const LabRequestApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This is called through Add Test->Append Results.
     * @summary Append lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to append.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    append(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).append(labRequestId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Copy and add tests.  This is the Add tests->New Results workflow in the JavaFX client.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to add to the new copied lab request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyAndAddTests(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).copyAndAddTests(labRequestId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Executes a new lab request.  From the GUI this is called from through the Analyze Sample button.
     * @summary Execute a new lab request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNew(
      body: ExecuteLabRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).executeNew(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is called through the Census->Run button.  The requisition id is ignored for this request.
     * @summary Execute a new lab request from a census request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNewFromCensus(
      body: ExecuteLabRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).executeNewFromCensus(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is called through the Pending->Run button.
     * @summary Execute a new lab request from a pending request.
     * @param {ExecutePimsRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePending(
      body: ExecutePimsRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).executePending(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get detailed results for completed lab request.
     * @param {number} labRequestId The lab request id.
     * @param {number} [previousRunDepth] The number of previous matching runs to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedResults(
      labRequestId: number,
      previousRunDepth?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).getDetailedResults(labRequestId, previousRunDepth, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is currently used in the GUI to determine whether to allow the user to send a cropped SediVue image to PIMS or not.
     * @summary Get lab request sent to PIMS by ID.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSentToPims(
      labRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).getSentToPims(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This GET has side-effects.  It will set the found runs to a status of WAITING_FOR_RESULTS.   This is used to populate the tabs when entering a SNAP result for a running SNAP run.
     * @summary Get all SNAP runs awaiting results.
     * @param {number} labRequestId The lab request id.
     * @param {number} instrumentRunId The id of the instrument run that was selected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapRunsAwaitingResults(
      labRequestId: number,
      instrumentRunId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RunningInstrumentRunDto>> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).getSnapRunsAwaitingResults(labRequestId, instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get instrument run ids by InstrumentTypes.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI">} instrumentType The instrument types to query on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentRunIds(
      labRequestId: number,
      instrumentType: Array<
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI"
      >,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).instrumentRunIds(labRequestId, instrumentType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Check if request is complete. Is there an associated pending request or a currently running lab request?
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isComplete(
      labRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).isComplete(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is called through Add Test->Merge/Replace Results.
     * @summary Merge lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to merge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    merge(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RunningLabRequestDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).merge(labRequestId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previousRunsForUndoMerge(
      labRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UndoMergeRunsDto> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).previousRunsForUndoMerge(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resend results to PIMS.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendLabRequest(
      labRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).resendLabRequest(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is used to populate the running lab request pane in the GUI.
     * @summary Get all running lab requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequests(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RunningLabRequestDto>> {
      const localVarFetchArgs =
        LabRequestApiFetchParamCreator(configuration).runningLabRequests(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is used by the ViewPoint client.
     * @summary Get all running lab requests, including runs with error status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequestsExtended(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RunningLabRequestDto>> {
      const localVarFetchArgs =
        LabRequestApiFetchParamCreator(
          configuration
        ).runningLabRequestsExtended(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Transfer a lab request to a different patient.
     * @param {number} labRequestId The lab request Id.
     * @param {number} body The patientId to transfer it to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transfer(
      labRequestId: number,
      body: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).transfer(labRequestId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    undoMerge(
      labRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).undoMerge(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the supported add test types for this lab request/execute request combinations
     * @param {number} labRequestId The original lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs being requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSupportedAddTestTypes(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<SupportedRunTypeValidationDto>> {
      const localVarFetchArgs = LabRequestApiFetchParamCreator(
        configuration
      ).validateSupportedAddTestTypes(labRequestId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LabRequestApi - factory interface
 * @export
 */
export const LabRequestApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * This is called through Add Test->Append Results.
     * @summary Append lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to append.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    append(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ) {
      return LabRequestApiFp(configuration).append(
        labRequestId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Copy and add tests.  This is the Add tests->New Results workflow in the JavaFX client.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to add to the new copied lab request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyAndAddTests(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ) {
      return LabRequestApiFp(configuration).copyAndAddTests(
        labRequestId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     * Executes a new lab request.  From the GUI this is called from through the Analyze Sample button.
     * @summary Execute a new lab request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNew(body: ExecuteLabRequestDto, options?: any) {
      return LabRequestApiFp(configuration).executeNew(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * This is called through the Census->Run button.  The requisition id is ignored for this request.
     * @summary Execute a new lab request from a census request.
     * @param {ExecuteLabRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeNewFromCensus(body: ExecuteLabRequestDto, options?: any) {
      return LabRequestApiFp(configuration).executeNewFromCensus(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * This is called through the Pending->Run button.
     * @summary Execute a new lab request from a pending request.
     * @param {ExecutePimsRequestDto} body The lab request details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePending(body: ExecutePimsRequestDto, options?: any) {
      return LabRequestApiFp(configuration).executePending(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get detailed results for completed lab request.
     * @param {number} labRequestId The lab request id.
     * @param {number} [previousRunDepth] The number of previous matching runs to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedResults(
      labRequestId: number,
      previousRunDepth?: number,
      options?: any
    ) {
      return LabRequestApiFp(configuration).getDetailedResults(
        labRequestId,
        previousRunDepth,
        options
      )(fetch, basePath);
    },
    /**
     * This is currently used in the GUI to determine whether to allow the user to send a cropped SediVue image to PIMS or not.
     * @summary Get lab request sent to PIMS by ID.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSentToPims(labRequestId: number, options?: any) {
      return LabRequestApiFp(configuration).getSentToPims(
        labRequestId,
        options
      )(fetch, basePath);
    },
    /**
     * This GET has side-effects.  It will set the found runs to a status of WAITING_FOR_RESULTS.   This is used to populate the tabs when entering a SNAP result for a running SNAP run.
     * @summary Get all SNAP runs awaiting results.
     * @param {number} labRequestId The lab request id.
     * @param {number} instrumentRunId The id of the instrument run that was selected.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapRunsAwaitingResults(
      labRequestId: number,
      instrumentRunId: number,
      options?: any
    ) {
      return LabRequestApiFp(configuration).getSnapRunsAwaitingResults(
        labRequestId,
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get instrument run ids by InstrumentTypes.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI">} instrumentType The instrument types to query on.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    instrumentRunIds(
      labRequestId: number,
      instrumentType: Array<
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI"
      >,
      options?: any
    ) {
      return LabRequestApiFp(configuration).instrumentRunIds(
        labRequestId,
        instrumentType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Check if request is complete. Is there an associated pending request or a currently running lab request?
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isComplete(labRequestId: number, options?: any) {
      return LabRequestApiFp(configuration).isComplete(labRequestId, options)(
        fetch,
        basePath
      );
    },
    /**
     * This is called through Add Test->Merge/Replace Results.
     * @summary Merge lab request.
     * @param {number} labRequestId The lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to merge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    merge(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ) {
      return LabRequestApiFp(configuration).merge(
        labRequestId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previousRunsForUndoMerge(labRequestId: number, options?: any) {
      return LabRequestApiFp(configuration).previousRunsForUndoMerge(
        labRequestId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Resend results to PIMS.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendLabRequest(labRequestId: number, options?: any) {
      return LabRequestApiFp(configuration).resendLabRequest(
        labRequestId,
        options
      )(fetch, basePath);
    },
    /**
     * This is used to populate the running lab request pane in the GUI.
     * @summary Get all running lab requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequests(options?: any) {
      return LabRequestApiFp(configuration).runningLabRequests(options)(
        fetch,
        basePath
      );
    },
    /**
     * This is used by the ViewPoint client.
     * @summary Get all running lab requests, including runs with error status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runningLabRequestsExtended(options?: any) {
      return LabRequestApiFp(configuration).runningLabRequestsExtended(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Transfer a lab request to a different patient.
     * @param {number} labRequestId The lab request Id.
     * @param {number} body The patientId to transfer it to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transfer(labRequestId: number, body: number, options?: any) {
      return LabRequestApiFp(configuration).transfer(
        labRequestId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get previous runs for undo merge.
     * @param {number} labRequestId The lab request Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    undoMerge(labRequestId: number, options?: any) {
      return LabRequestApiFp(configuration).undoMerge(labRequestId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the supported add test types for this lab request/execute request combinations
     * @param {number} labRequestId The original lab request Id.
     * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs being requested
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSupportedAddTestTypes(
      labRequestId: number,
      body: Array<ExecuteInstrumentRunDto>,
      options?: any
    ) {
      return LabRequestApiFp(configuration).validateSupportedAddTestTypes(
        labRequestId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * LabRequestApi - object-oriented interface
 * @export
 * @class LabRequestApi
 * @extends {BaseAPI}
 */
export class LabRequestApi extends BaseAPI {
  /**
   * This is called through Add Test->Append Results.
   * @summary Append lab request.
   * @param {number} labRequestId The lab request Id.
   * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to append.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public append(
    labRequestId: number,
    body: Array<ExecuteInstrumentRunDto>,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).append(
      labRequestId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Copy and add tests.  This is the Add tests->New Results workflow in the JavaFX client.
   * @param {number} labRequestId The lab request Id.
   * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to add to the new copied lab request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public copyAndAddTests(
    labRequestId: number,
    body: Array<ExecuteInstrumentRunDto>,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).copyAndAddTests(
      labRequestId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Executes a new lab request.  From the GUI this is called from through the Analyze Sample button.
   * @summary Execute a new lab request.
   * @param {ExecuteLabRequestDto} body The lab request details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public executeNew(body: ExecuteLabRequestDto, options?: any) {
    return LabRequestApiFp(this.configuration).executeNew(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * This is called through the Census->Run button.  The requisition id is ignored for this request.
   * @summary Execute a new lab request from a census request.
   * @param {ExecuteLabRequestDto} body The lab request details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public executeNewFromCensus(body: ExecuteLabRequestDto, options?: any) {
    return LabRequestApiFp(this.configuration).executeNewFromCensus(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This is called through the Pending->Run button.
   * @summary Execute a new lab request from a pending request.
   * @param {ExecutePimsRequestDto} body The lab request details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public executePending(body: ExecutePimsRequestDto, options?: any) {
    return LabRequestApiFp(this.configuration).executePending(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get detailed results for completed lab request.
   * @param {number} labRequestId The lab request id.
   * @param {number} [previousRunDepth] The number of previous matching runs to include
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public getDetailedResults(
    labRequestId: number,
    previousRunDepth?: number,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).getDetailedResults(
      labRequestId,
      previousRunDepth,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This is currently used in the GUI to determine whether to allow the user to send a cropped SediVue image to PIMS or not.
   * @summary Get lab request sent to PIMS by ID.
   * @param {number} labRequestId The lab request Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public getSentToPims(labRequestId: number, options?: any) {
    return LabRequestApiFp(this.configuration).getSentToPims(
      labRequestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This GET has side-effects.  It will set the found runs to a status of WAITING_FOR_RESULTS.   This is used to populate the tabs when entering a SNAP result for a running SNAP run.
   * @summary Get all SNAP runs awaiting results.
   * @param {number} labRequestId The lab request id.
   * @param {number} instrumentRunId The id of the instrument run that was selected.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public getSnapRunsAwaitingResults(
    labRequestId: number,
    instrumentRunId: number,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).getSnapRunsAwaitingResults(
      labRequestId,
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get instrument run ids by InstrumentTypes.
   * @param {number} labRequestId The lab request Id.
   * @param {Array<"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI">} instrumentType The instrument types to query on.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public instrumentRunIds(
    labRequestId: number,
    instrumentType: Array<
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI"
    >,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).instrumentRunIds(
      labRequestId,
      instrumentType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Check if request is complete. Is there an associated pending request or a currently running lab request?
   * @param {number} labRequestId The lab request Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public isComplete(labRequestId: number, options?: any) {
    return LabRequestApiFp(this.configuration).isComplete(
      labRequestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This is called through Add Test->Merge/Replace Results.
   * @summary Merge lab request.
   * @param {number} labRequestId The lab request Id.
   * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs to merge.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public merge(
    labRequestId: number,
    body: Array<ExecuteInstrumentRunDto>,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).merge(
      labRequestId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get previous runs for undo merge.
   * @param {number} labRequestId The lab request Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public previousRunsForUndoMerge(labRequestId: number, options?: any) {
    return LabRequestApiFp(this.configuration).previousRunsForUndoMerge(
      labRequestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Resend results to PIMS.
   * @param {number} labRequestId The lab request Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public resendLabRequest(labRequestId: number, options?: any) {
    return LabRequestApiFp(this.configuration).resendLabRequest(
      labRequestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This is used to populate the running lab request pane in the GUI.
   * @summary Get all running lab requests.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public runningLabRequests(options?: any) {
    return LabRequestApiFp(this.configuration).runningLabRequests(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * This is used by the ViewPoint client.
   * @summary Get all running lab requests, including runs with error status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public runningLabRequestsExtended(options?: any) {
    return LabRequestApiFp(this.configuration).runningLabRequestsExtended(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Transfer a lab request to a different patient.
   * @param {number} labRequestId The lab request Id.
   * @param {number} body The patientId to transfer it to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public transfer(labRequestId: number, body: number, options?: any) {
    return LabRequestApiFp(this.configuration).transfer(
      labRequestId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get previous runs for undo merge.
   * @param {number} labRequestId The lab request Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public undoMerge(labRequestId: number, options?: any) {
    return LabRequestApiFp(this.configuration).undoMerge(labRequestId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the supported add test types for this lab request/execute request combinations
   * @param {number} labRequestId The original lab request Id.
   * @param {Array<ExecuteInstrumentRunDto>} body The new instrument runs being requested
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabRequestApi
   */
  public validateSupportedAddTestTypes(
    labRequestId: number,
    body: Array<ExecuteInstrumentRunDto>,
    options?: any
  ) {
    return LabRequestApiFp(this.configuration).validateSupportedAddTestTypes(
      labRequestId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * LaserCyteApi - fetch parameter creator
 * @export
 */
export const LaserCyteApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Execute command procedure request.
     * @param {number} instrumentId The instrument ID.
     * @param {LaserCyteProcedureDto} body Instrument command name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommandRequest(
      instrumentId: number,
      body: LaserCyteProcedureDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling executeCommandRequest."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeCommandRequest."
        );
      }
      const localVarPath = `/laserCyte/{instrumentId}/command/execute`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"LaserCyteProcedureDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LaserCyteApi - functional programming interface
 * @export
 */
export const LaserCyteApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Execute command procedure request.
     * @param {number} instrumentId The instrument ID.
     * @param {LaserCyteProcedureDto} body Instrument command name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommandRequest(
      instrumentId: number,
      body: LaserCyteProcedureDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = LaserCyteApiFetchParamCreator(
        configuration
      ).executeCommandRequest(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LaserCyteApi - factory interface
 * @export
 */
export const LaserCyteApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Execute command procedure request.
     * @param {number} instrumentId The instrument ID.
     * @param {LaserCyteProcedureDto} body Instrument command name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeCommandRequest(
      instrumentId: number,
      body: LaserCyteProcedureDto,
      options?: any
    ) {
      return LaserCyteApiFp(configuration).executeCommandRequest(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * LaserCyteApi - object-oriented interface
 * @export
 * @class LaserCyteApi
 * @extends {BaseAPI}
 */
export class LaserCyteApi extends BaseAPI {
  /**
   *
   * @summary Execute command procedure request.
   * @param {number} instrumentId The instrument ID.
   * @param {LaserCyteProcedureDto} body Instrument command name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LaserCyteApi
   */
  public executeCommandRequest(
    instrumentId: number,
    body: LaserCyteProcedureDto,
    options?: any
  ) {
    return LaserCyteApiFp(this.configuration).executeCommandRequest(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * LaserCyteBackupApi - fetch parameter creator
 * @export
 */
export const LaserCyteBackupApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Export LaserCyte data to CD.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToCd(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/laserCyteBackup/executeDataExportToCd`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Please prepare an export for USB first.
     * @summary Export LaserCyte data to USB.
     * @param {string} [usbDriveId] The USB drive id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToUsb(usbDriveId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/laserCyteBackup/executeDataExportToUsb`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbDriveId !== undefined) {
        localVarQueryParameter["usbDriveId"] = usbDriveId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a LaserCyte data export file count.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataExportFileCount(
      startDate?: string,
      endDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/laserCyteBackup/dataExportFileCount`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the payload size (in bytes).
     * @summary Prepare a LaserCyte data export for USB.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareUsbDataExport(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/laserCyteBackup/prepareUsbDataExport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LaserCyteBackupApi - functional programming interface
 * @export
 */
export const LaserCyteBackupApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Export LaserCyte data to CD.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToCd(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = LaserCyteBackupApiFetchParamCreator(
        configuration
      ).executeDataExportToCd(instrumentId, startDate, endDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Please prepare an export for USB first.
     * @summary Export LaserCyte data to USB.
     * @param {string} [usbDriveId] The USB drive id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToUsb(
      usbDriveId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = LaserCyteBackupApiFetchParamCreator(
        configuration
      ).executeDataExportToUsb(usbDriveId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get a LaserCyte data export file count.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataExportFileCount(
      startDate?: string,
      endDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = LaserCyteBackupApiFetchParamCreator(
        configuration
      ).getDataExportFileCount(startDate, endDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the payload size (in bytes).
     * @summary Prepare a LaserCyte data export for USB.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareUsbDataExport(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = LaserCyteBackupApiFetchParamCreator(
        configuration
      ).prepareUsbDataExport(instrumentId, startDate, endDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LaserCyteBackupApi - factory interface
 * @export
 */
export const LaserCyteBackupApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Export LaserCyte data to CD.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToCd(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options?: any
    ) {
      return LaserCyteBackupApiFp(configuration).executeDataExportToCd(
        instrumentId,
        startDate,
        endDate,
        options
      )(fetch, basePath);
    },
    /**
     * Please prepare an export for USB first.
     * @summary Export LaserCyte data to USB.
     * @param {string} [usbDriveId] The USB drive id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeDataExportToUsb(usbDriveId?: string, options?: any) {
      return LaserCyteBackupApiFp(configuration).executeDataExportToUsb(
        usbDriveId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get a LaserCyte data export file count.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataExportFileCount(
      startDate?: string,
      endDate?: string,
      options?: any
    ) {
      return LaserCyteBackupApiFp(configuration).getDataExportFileCount(
        startDate,
        endDate,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the payload size (in bytes).
     * @summary Prepare a LaserCyte data export for USB.
     * @param {number} [instrumentId] The instrument id.
     * @param {string} [startDate] The start date (yyyy-MM-dd).
     * @param {string} [endDate] The end date (yyyy-MM-dd).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    prepareUsbDataExport(
      instrumentId?: number,
      startDate?: string,
      endDate?: string,
      options?: any
    ) {
      return LaserCyteBackupApiFp(configuration).prepareUsbDataExport(
        instrumentId,
        startDate,
        endDate,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * LaserCyteBackupApi - object-oriented interface
 * @export
 * @class LaserCyteBackupApi
 * @extends {BaseAPI}
 */
export class LaserCyteBackupApi extends BaseAPI {
  /**
   *
   * @summary Export LaserCyte data to CD.
   * @param {number} [instrumentId] The instrument id.
   * @param {string} [startDate] The start date (yyyy-MM-dd).
   * @param {string} [endDate] The end date (yyyy-MM-dd).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LaserCyteBackupApi
   */
  public executeDataExportToCd(
    instrumentId?: number,
    startDate?: string,
    endDate?: string,
    options?: any
  ) {
    return LaserCyteBackupApiFp(this.configuration).executeDataExportToCd(
      instrumentId,
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Please prepare an export for USB first.
   * @summary Export LaserCyte data to USB.
   * @param {string} [usbDriveId] The USB drive id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LaserCyteBackupApi
   */
  public executeDataExportToUsb(usbDriveId?: string, options?: any) {
    return LaserCyteBackupApiFp(this.configuration).executeDataExportToUsb(
      usbDriveId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get a LaserCyte data export file count.
   * @param {string} [startDate] The start date (yyyy-MM-dd).
   * @param {string} [endDate] The end date (yyyy-MM-dd).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LaserCyteBackupApi
   */
  public getDataExportFileCount(
    startDate?: string,
    endDate?: string,
    options?: any
  ) {
    return LaserCyteBackupApiFp(this.configuration).getDataExportFileCount(
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the payload size (in bytes).
   * @summary Prepare a LaserCyte data export for USB.
   * @param {number} [instrumentId] The instrument id.
   * @param {string} [startDate] The start date (yyyy-MM-dd).
   * @param {string} [endDate] The end date (yyyy-MM-dd).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LaserCyteBackupApi
   */
  public prepareUsbDataExport(
    instrumentId?: number,
    startDate?: string,
    endDate?: string,
    options?: any
  ) {
    return LaserCyteBackupApiFp(this.configuration).prepareUsbDataExport(
      instrumentId,
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * LexiconApi - fetch parameter creator
 * @export
 */
export const LexiconApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get resources corresponding to clinic's current locale (language + region).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle(options: any = {}): FetchArgs {
      const localVarPath = `/lexicon/bundle`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LexiconApi - functional programming interface
 * @export
 */
export const LexiconApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get resources corresponding to clinic's current locale (language + region).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: any }> {
      const localVarFetchArgs =
        LexiconApiFetchParamCreator(configuration).getBundle(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * LexiconApi - factory interface
 * @export
 */
export const LexiconApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get resources corresponding to clinic's current locale (language + region).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBundle(options?: any) {
      return LexiconApiFp(configuration).getBundle(options)(fetch, basePath);
    },
  };
};

/**
 * LexiconApi - object-oriented interface
 * @export
 * @class LexiconApi
 * @extends {BaseAPI}
 */
export class LexiconApi extends BaseAPI {
  /**
   *
   * @summary Get resources corresponding to clinic's current locale (language + region).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LexiconApi
   */
  public getBundle(options?: any) {
    return LexiconApiFp(this.configuration).getBundle(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ManualAssaysApi - fetch parameter creator
 * @export
 */
export const ManualAssaysApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get Manual Assays for a given species.
     * @param {number} speciesId The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchManualAssaysForSpecies(
      speciesId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling fetchManualAssaysForSpecies."
        );
      }
      const localVarPath = `/manualAssays/{speciesId}`.replace(
        `{${"speciesId"}}`,
        encodeURIComponent(String(speciesId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ManualAssaysApi - functional programming interface
 * @export
 */
export const ManualAssaysApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get Manual Assays for a given species.
     * @param {number} speciesId The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchManualAssaysForSpecies(
      speciesId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ManualAssaysApiFetchParamCreator(
        configuration
      ).fetchManualAssaysForSpecies(speciesId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ManualAssaysApi - factory interface
 * @export
 */
export const ManualAssaysApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get Manual Assays for a given species.
     * @param {number} speciesId The species id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchManualAssaysForSpecies(speciesId: number, options?: any) {
      return ManualAssaysApiFp(configuration).fetchManualAssaysForSpecies(
        speciesId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ManualAssaysApi - object-oriented interface
 * @export
 * @class ManualAssaysApi
 * @extends {BaseAPI}
 */
export class ManualAssaysApi extends BaseAPI {
  /**
   *
   * @summary Get Manual Assays for a given species.
   * @param {number} speciesId The species id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManualAssaysApi
   */
  public fetchManualAssaysForSpecies(speciesId: number, options?: any) {
    return ManualAssaysApiFp(this.configuration).fetchManualAssaysForSpecies(
      speciesId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * MatchingSettingsApi - fetch parameter creator
 * @export
 */
export const MatchingSettingsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create new matching profile
     * @param {PatientMatchProfileDto} [body] The matching object to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProfile(body?: PatientMatchProfileDto, options: any = {}): FetchArgs {
      const localVarPath = `/matchingSettings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PatientMatchProfileDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get current settings for patient and client matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveProfile(options: any = {}): FetchArgs {
      const localVarPath = `/matchingSettings/active`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of matching profiles available on IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProfiles(options: any = {}): FetchArgs {
      const localVarPath = `/matchingSettings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set current settings profile patient and client matching
     * @param {string} body The name of the profile to make active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActiveProfile(body: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling setActiveProfile."
        );
      }
      const localVarPath = `/matchingSettings/active`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"string" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MatchingSettingsApi - functional programming interface
 * @export
 */
export const MatchingSettingsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create new matching profile
     * @param {PatientMatchProfileDto} [body] The matching object to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProfile(
      body?: PatientMatchProfileDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PatientMatchProfileDto> {
      const localVarFetchArgs = MatchingSettingsApiFetchParamCreator(
        configuration
      ).createProfile(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get current settings for patient and client matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveProfile(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PatientMatchProfileDto> {
      const localVarFetchArgs =
        MatchingSettingsApiFetchParamCreator(configuration).fetchActiveProfile(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of matching profiles available on IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProfiles(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<PatientMatchProfileDto>> {
      const localVarFetchArgs =
        MatchingSettingsApiFetchParamCreator(configuration).fetchProfiles(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set current settings profile patient and client matching
     * @param {string} body The name of the profile to make active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActiveProfile(
      body: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PatientMatchProfileDto> {
      const localVarFetchArgs = MatchingSettingsApiFetchParamCreator(
        configuration
      ).setActiveProfile(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MatchingSettingsApi - factory interface
 * @export
 */
export const MatchingSettingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Create new matching profile
     * @param {PatientMatchProfileDto} [body] The matching object to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProfile(body?: PatientMatchProfileDto, options?: any) {
      return MatchingSettingsApiFp(configuration).createProfile(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get current settings for patient and client matching
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchActiveProfile(options?: any) {
      return MatchingSettingsApiFp(configuration).fetchActiveProfile(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get list of matching profiles available on IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProfiles(options?: any) {
      return MatchingSettingsApiFp(configuration).fetchProfiles(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Set current settings profile patient and client matching
     * @param {string} body The name of the profile to make active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActiveProfile(body: string, options?: any) {
      return MatchingSettingsApiFp(configuration).setActiveProfile(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * MatchingSettingsApi - object-oriented interface
 * @export
 * @class MatchingSettingsApi
 * @extends {BaseAPI}
 */
export class MatchingSettingsApi extends BaseAPI {
  /**
   *
   * @summary Create new matching profile
   * @param {PatientMatchProfileDto} [body] The matching object to create
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchingSettingsApi
   */
  public createProfile(body?: PatientMatchProfileDto, options?: any) {
    return MatchingSettingsApiFp(this.configuration).createProfile(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get current settings for patient and client matching
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchingSettingsApi
   */
  public fetchActiveProfile(options?: any) {
    return MatchingSettingsApiFp(this.configuration).fetchActiveProfile(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get list of matching profiles available on IVLS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchingSettingsApi
   */
  public fetchProfiles(options?: any) {
    return MatchingSettingsApiFp(this.configuration).fetchProfiles(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Set current settings profile patient and client matching
   * @param {string} body The name of the profile to make active
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MatchingSettingsApi
   */
  public setActiveProfile(body: string, options?: any) {
    return MatchingSettingsApiFp(this.configuration).setActiveProfile(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * MediaBurnerApi - fetch parameter creator
 * @export
 */
export const MediaBurnerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Eject media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ejectMedia(options: any = {}): FetchArgs {
      const localVarPath = `/mediaBurner/ejectMedia`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get media readable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaReadable(options: any = {}): FetchArgs {
      const localVarPath = `/mediaBurner/isMediaReadable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get media writable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaWritable(options: any = {}): FetchArgs {
      const localVarPath = `/mediaBurner/isMediaWritable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get optical drive present status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isOpticalDrivePresent(options: any = {}): FetchArgs {
      const localVarPath = `/mediaBurner/isOpticalDrivePresent`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MediaBurnerApi - functional programming interface
 * @export
 */
export const MediaBurnerApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Eject media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ejectMedia(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        MediaBurnerApiFetchParamCreator(configuration).ejectMedia(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get media readable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaReadable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        MediaBurnerApiFetchParamCreator(configuration).isMediaReadable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get media writable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaWritable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        MediaBurnerApiFetchParamCreator(configuration).isMediaWritable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get optical drive present status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isOpticalDrivePresent(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        MediaBurnerApiFetchParamCreator(configuration).isOpticalDrivePresent(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MediaBurnerApi - factory interface
 * @export
 */
export const MediaBurnerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Eject media.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ejectMedia(options?: any) {
      return MediaBurnerApiFp(configuration).ejectMedia(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get media readable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaReadable(options?: any) {
      return MediaBurnerApiFp(configuration).isMediaReadable(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get media writable status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isMediaWritable(options?: any) {
      return MediaBurnerApiFp(configuration).isMediaWritable(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get optical drive present status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isOpticalDrivePresent(options?: any) {
      return MediaBurnerApiFp(configuration).isOpticalDrivePresent(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * MediaBurnerApi - object-oriented interface
 * @export
 * @class MediaBurnerApi
 * @extends {BaseAPI}
 */
export class MediaBurnerApi extends BaseAPI {
  /**
   *
   * @summary Eject media.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaBurnerApi
   */
  public ejectMedia(options?: any) {
    return MediaBurnerApiFp(this.configuration).ejectMedia(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get media readable status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaBurnerApi
   */
  public isMediaReadable(options?: any) {
    return MediaBurnerApiFp(this.configuration).isMediaReadable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get media writable status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaBurnerApi
   */
  public isMediaWritable(options?: any) {
    return MediaBurnerApiFp(this.configuration).isMediaWritable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get optical drive present status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaBurnerApi
   */
  public isOpticalDrivePresent(options?: any) {
    return MediaBurnerApiFp(this.configuration).isOpticalDrivePresent(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * NotificationsApi - fetch parameter creator
 * @export
 */
export const NotificationsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete a notification.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification(notificationId: number, options: any = {}): FetchArgs {
      // verify required parameter 'notificationId' is not null or undefined
      if (notificationId === null || notificationId === undefined) {
        throw new RequiredError(
          "notificationId",
          "Required parameter notificationId was null or undefined when calling deleteNotification."
        );
      }
      const localVarPath = `/notifications/{notificationId}`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the number of read and unread notifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotificationCounts(options: any = {}): FetchArgs {
      const localVarPath = `/notifications/counts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotifications(options: any = {}): FetchArgs {
      const localVarPath = `/notifications`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the print notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPrintableContent(
      notificationId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'notificationId' is not null or undefined
      if (notificationId === null || notificationId === undefined) {
        throw new RequiredError(
          "notificationId",
          "Required parameter notificationId was null or undefined when calling fetchPrintableContent."
        );
      }
      const localVarPath = `/notifications/{notificationId}/print`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the optional notification content displayed to the user on message receipt.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProactiveNotificationContent(
      notificationId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'notificationId' is not null or undefined
      if (notificationId === null || notificationId === undefined) {
        throw new RequiredError(
          "notificationId",
          "Required parameter notificationId was null or undefined when calling fetchProactiveNotificationContent."
        );
      }
      const localVarPath =
        `/notifications/{notificationId}/proactiveNotification`.replace(
          `{${"notificationId"}}`,
          encodeURIComponent(String(notificationId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the view notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchViewableContent(notificationId: number, options: any = {}): FetchArgs {
      // verify required parameter 'notificationId' is not null or undefined
      if (notificationId === null || notificationId === undefined) {
        throw new RequiredError(
          "notificationId",
          "Required parameter notificationId was null or undefined when calling fetchViewableContent."
        );
      }
      const localVarPath = `/notifications/{notificationId}/view`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Mark notification as unread.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsUnread(
      notificationId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'notificationId' is not null or undefined
      if (notificationId === null || notificationId === undefined) {
        throw new RequiredError(
          "notificationId",
          "Required parameter notificationId was null or undefined when calling markNotificationAsUnread."
        );
      }
      const localVarPath = `/notifications/{notificationId}/unread`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a notification.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification(
      notificationId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = NotificationsApiFetchParamCreator(
        configuration
      ).deleteNotification(notificationId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the number of read and unread notifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotificationCounts(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MessageCounts> {
      const localVarFetchArgs =
        NotificationsApiFetchParamCreator(
          configuration
        ).fetchNotificationCounts(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotifications(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Message>> {
      const localVarFetchArgs =
        NotificationsApiFetchParamCreator(configuration).fetchNotifications(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the print notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPrintableContent(
      notificationId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = NotificationsApiFetchParamCreator(
        configuration
      ).fetchPrintableContent(notificationId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the optional notification content displayed to the user on message receipt.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProactiveNotificationContent(
      notificationId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<NotificationContentDto> {
      const localVarFetchArgs = NotificationsApiFetchParamCreator(
        configuration
      ).fetchProactiveNotificationContent(notificationId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the view notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchViewableContent(
      notificationId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<NotificationContentDto> {
      const localVarFetchArgs = NotificationsApiFetchParamCreator(
        configuration
      ).fetchViewableContent(notificationId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Mark notification as unread.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsUnread(
      notificationId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = NotificationsApiFetchParamCreator(
        configuration
      ).markNotificationAsUnread(notificationId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete a notification.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification(notificationId: number, options?: any) {
      return NotificationsApiFp(configuration).deleteNotification(
        notificationId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the number of read and unread notifications.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotificationCounts(options?: any) {
      return NotificationsApiFp(configuration).fetchNotificationCounts(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchNotifications(options?: any) {
      return NotificationsApiFp(configuration).fetchNotifications(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the print notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPrintableContent(notificationId: number, options?: any) {
      return NotificationsApiFp(configuration).fetchPrintableContent(
        notificationId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the optional notification content displayed to the user on message receipt.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProactiveNotificationContent(notificationId: number, options?: any) {
      return NotificationsApiFp(
        configuration
      ).fetchProactiveNotificationContent(notificationId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the view notification.
     * @param {number} notificationId DB notification id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchViewableContent(notificationId: number, options?: any) {
      return NotificationsApiFp(configuration).fetchViewableContent(
        notificationId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Mark notification as unread.
     * @param {number} notificationId The id of the target notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsUnread(notificationId: number, options?: any) {
      return NotificationsApiFp(configuration).markNotificationAsUnread(
        notificationId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
  /**
   *
   * @summary Delete a notification.
   * @param {number} notificationId The id of the target notification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public deleteNotification(notificationId: number, options?: any) {
    return NotificationsApiFp(this.configuration).deleteNotification(
      notificationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the number of read and unread notifications.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public fetchNotificationCounts(options?: any) {
    return NotificationsApiFp(this.configuration).fetchNotificationCounts(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get notifications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public fetchNotifications(options?: any) {
    return NotificationsApiFp(this.configuration).fetchNotifications(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the print notification.
   * @param {number} notificationId DB notification id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public fetchPrintableContent(notificationId: number, options?: any) {
    return NotificationsApiFp(this.configuration).fetchPrintableContent(
      notificationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the optional notification content displayed to the user on message receipt.
   * @param {number} notificationId DB notification id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public fetchProactiveNotificationContent(
    notificationId: number,
    options?: any
  ) {
    return NotificationsApiFp(
      this.configuration
    ).fetchProactiveNotificationContent(notificationId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the view notification.
   * @param {number} notificationId DB notification id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public fetchViewableContent(notificationId: number, options?: any) {
    return NotificationsApiFp(this.configuration).fetchViewableContent(
      notificationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Mark notification as unread.
   * @param {number} notificationId The id of the target notification
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationsApi
   */
  public markNotificationAsUnread(notificationId: number, options?: any) {
    return NotificationsApiFp(this.configuration).markNotificationAsUnread(
      notificationId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * PatientApi - fetch parameter creator
 * @export
 */
export const PatientApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Save a new patient.
     * @param {PatientSaveEditDto} patientDto The patient to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(patientDto: PatientSaveEditDto, options: any = {}): FetchArgs {
      // verify required parameter 'patientDto' is not null or undefined
      if (patientDto === null || patientDto === undefined) {
        throw new RequiredError(
          "patientDto",
          "Required parameter patientDto was null or undefined when calling create."
        );
      }
      const localVarPath = `/patient`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PatientSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(patientDto || {})
        : patientDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Edit an existing patient.
     * @param {number} patientId The id of the patient to edit.
     * @param {PatientSaveEditDto} patientDto The new patient data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      patientId: number,
      patientDto: PatientSaveEditDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling edit."
        );
      }
      // verify required parameter 'patientDto' is not null or undefined
      if (patientDto === null || patientDto === undefined) {
        throw new RequiredError(
          "patientDto",
          "Required parameter patientDto was null or undefined when calling edit."
        );
      }
      const localVarPath = `/patient/{patientId}`.replace(
        `{${"patientId"}}`,
        encodeURIComponent(String(patientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PatientSaveEditDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(patientDto || {})
        : patientDto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Checks if the proposed patient name edit will generate a duplicate for its associated client
     * @param {string} patientName The new (edited) patient Name.
     * @param {number} patientId The PK id of the patient being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingPatientNameWillGenerateDuplicate(
      patientName: string,
      patientId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'patientName' is not null or undefined
      if (patientName === null || patientName === undefined) {
        throw new RequiredError(
          "patientName",
          "Required parameter patientName was null or undefined when calling editingPatientNameWillGenerateDuplicate."
        );
      }
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling editingPatientNameWillGenerateDuplicate."
        );
      }
      const localVarPath =
        `/patient/{patientId}/editingPatientNameWillGenerateDuplicate`.replace(
          `{${"patientId"}}`,
          encodeURIComponent(String(patientId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientName !== undefined) {
        localVarQueryParameter["patientName"] = patientName;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch an existing patient.
     * @param {number} patientId The id of the patient to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPatient(patientId: number, options: any = {}): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling fetch."
        );
      }
      const localVarPath = `/patient/{patientId}`.replace(
        `{${"patientId"}}`,
        encodeURIComponent(String(patientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all genders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllGenders(options: any = {}): FetchArgs {
      const localVarPath = `/patient/genders`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Find patients by PIMs Patient ID
     * @param {string} pimsPatientId The PIMs ID of the patient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByPimsPatientsId(pimsPatientId: string, options: any = {}): FetchArgs {
      // verify required parameter 'pimsPatientId' is not null or undefined
      if (pimsPatientId === null || pimsPatientId === undefined) {
        throw new RequiredError(
          "pimsPatientId",
          "Required parameter pimsPatientId was null or undefined when calling findByPimsPatientsId."
        );
      }
      const localVarPath = `/patient/pimsPatients/{pimsPatientId}`.replace(
        `{${"pimsPatientId"}}`,
        encodeURIComponent(String(pimsPatientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all patients.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      patientName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/patient`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientName !== undefined) {
        localVarQueryParameter["patientName"] = patientName;
      }

      if (clientLastName !== undefined) {
        localVarQueryParameter["clientLastName"] = clientLastName;
      }

      if (clientIdentifier !== undefined) {
        localVarQueryParameter["clientIdentifier"] = clientIdentifier;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get lab request records for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabRequestRecords(patientId: number, options: any = {}): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling getLabRequestRecords."
        );
      }
      const localVarPath = `/patient/{patientId}/labRequestRecords`.replace(
        `{${"patientId"}}`,
        encodeURIComponent(String(patientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get most recent reference class for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentRefClass(patientId: number, options: any = {}): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling getMostRecentRefClass."
        );
      }
      const localVarPath = `/patient/{patientId}/mostRecentRefClass`.replace(
        `{${"patientId"}}`,
        encodeURIComponent(String(patientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get most recent weight for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentWeight(patientId: number, options: any = {}): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling getMostRecentWeight."
        );
      }
      const localVarPath = `/patient/{patientId}/mostRecentWeight`.replace(
        `{${"patientId"}}`,
        encodeURIComponent(String(patientId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all patients by species.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [speciesId] The id of the species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsForSpecies(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      speciesId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/patient/species`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientName !== undefined) {
        localVarQueryParameter["patientName"] = patientName;
      }

      if (clientLastName !== undefined) {
        localVarQueryParameter["clientLastName"] = clientLastName;
      }

      if (clientId !== undefined) {
        localVarQueryParameter["clientId"] = clientId;
      }

      if (speciesId !== undefined) {
        localVarQueryParameter["speciesId"] = speciesId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all patients with task for last n days.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [daysBack] The number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsWithRunTasks(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      daysBack?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/patient/history`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientName !== undefined) {
        localVarQueryParameter["patientName"] = patientName;
      }

      if (clientLastName !== undefined) {
        localVarQueryParameter["clientLastName"] = clientLastName;
      }

      if (clientId !== undefined) {
        localVarQueryParameter["clientId"] = clientId;
      }

      if (daysBack !== undefined) {
        localVarQueryParameter["daysBack"] = daysBack;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PatientApi - functional programming interface
 * @export
 */
export const PatientApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Save a new patient.
     * @param {PatientSaveEditDto} patientDto The patient to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      patientDto: PatientSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PatientDto> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).create(patientDto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Edit an existing patient.
     * @param {number} patientId The id of the patient to edit.
     * @param {PatientSaveEditDto} patientDto The new patient data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(
      patientId: number,
      patientDto: PatientSaveEditDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = PatientApiFetchParamCreator(configuration).edit(
        patientId,
        patientDto,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Checks if the proposed patient name edit will generate a duplicate for its associated client
     * @param {string} patientName The new (edited) patient Name.
     * @param {number} patientId The PK id of the patient being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingPatientNameWillGenerateDuplicate(
      patientName: string,
      patientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).editingPatientNameWillGenerateDuplicate(
        patientName,
        patientId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch an existing patient.
     * @param {number} patientId The id of the patient to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPatient(
      patientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PatientDto> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).fetchPatient(patientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all genders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllGenders(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GenderDto>> {
      const localVarFetchArgs =
        PatientApiFetchParamCreator(configuration).fetchAllGenders(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Find patients by PIMs Patient ID
     * @param {string} pimsPatientId The PIMs ID of the patient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByPimsPatientsId(
      pimsPatientId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PatientDto>> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).findByPimsPatientsId(pimsPatientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all patients.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      patientName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PatientDto>> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getAll(patientName, clientLastName, clientIdentifier, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get lab request records for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabRequestRecords(
      patientId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<LabRequestRecordDto>> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getLabRequestRecords(patientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get most recent reference class for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentRefClass(
      patientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RefClassDto> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getMostRecentRefClass(patientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get most recent weight for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentWeight(
      patientId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PatientWeightDto> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getMostRecentWeight(patientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all patients by species.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [speciesId] The id of the species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsForSpecies(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      speciesId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PatientDto>> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getPatientsForSpecies(
        patientName,
        clientLastName,
        clientId,
        speciesId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all patients with task for last n days.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [daysBack] The number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsWithRunTasks(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      daysBack?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PatientDto>> {
      const localVarFetchArgs = PatientApiFetchParamCreator(
        configuration
      ).getPatientsWithRunTasks(
        patientName,
        clientLastName,
        clientId,
        daysBack,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PatientApi - factory interface
 * @export
 */
export const PatientApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Save a new patient.
     * @param {PatientSaveEditDto} patientDto The patient to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(patientDto: PatientSaveEditDto, options?: any) {
      return PatientApiFp(configuration).create(patientDto, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Edit an existing patient.
     * @param {number} patientId The id of the patient to edit.
     * @param {PatientSaveEditDto} patientDto The new patient data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(patientId: number, patientDto: PatientSaveEditDto, options?: any) {
      return PatientApiFp(configuration).edit(
        patientId,
        patientDto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Checks if the proposed patient name edit will generate a duplicate for its associated client
     * @param {string} patientName The new (edited) patient Name.
     * @param {number} patientId The PK id of the patient being edited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editingPatientNameWillGenerateDuplicate(
      patientName: string,
      patientId: number,
      options?: any
    ) {
      return PatientApiFp(
        configuration
      ).editingPatientNameWillGenerateDuplicate(
        patientName,
        patientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch an existing patient.
     * @param {number} patientId The id of the patient to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPatient(patientId: number, options?: any) {
      return PatientApiFp(configuration).fetchPatient(patientId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get all genders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllGenders(options?: any) {
      return PatientApiFp(configuration).fetchAllGenders(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Find patients by PIMs Patient ID
     * @param {string} pimsPatientId The PIMs ID of the patient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findByPimsPatientsId(pimsPatientId: string, options?: any) {
      return PatientApiFp(configuration).findByPimsPatientsId(
        pimsPatientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all patients.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientIdentifier] The client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAll(
      patientName?: string,
      clientLastName?: string,
      clientIdentifier?: string,
      options?: any
    ) {
      return PatientApiFp(configuration).getAll(
        patientName,
        clientLastName,
        clientIdentifier,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get lab request records for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabRequestRecords(patientId: number, options?: any) {
      return PatientApiFp(configuration).getLabRequestRecords(
        patientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get most recent reference class for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentRefClass(patientId: number, options?: any) {
      return PatientApiFp(configuration).getMostRecentRefClass(
        patientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get most recent weight for patient.
     * @param {number} patientId The id of the patient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMostRecentWeight(patientId: number, options?: any) {
      return PatientApiFp(configuration).getMostRecentWeight(
        patientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all patients by species.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [speciesId] The id of the species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsForSpecies(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      speciesId?: number,
      options?: any
    ) {
      return PatientApiFp(configuration).getPatientsForSpecies(
        patientName,
        clientLastName,
        clientId,
        speciesId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get all patients with task for last n days.
     * @param {string} [patientName] The patient name.
     * @param {string} [clientLastName] The client last name.
     * @param {string} [clientId] The client Id.
     * @param {number} [daysBack] The number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPatientsWithRunTasks(
      patientName?: string,
      clientLastName?: string,
      clientId?: string,
      daysBack?: number,
      options?: any
    ) {
      return PatientApiFp(configuration).getPatientsWithRunTasks(
        patientName,
        clientLastName,
        clientId,
        daysBack,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * PatientApi - object-oriented interface
 * @export
 * @class PatientApi
 * @extends {BaseAPI}
 */
export class PatientApi extends BaseAPI {
  /**
   *
   * @summary Save a new patient.
   * @param {PatientSaveEditDto} patientDto The patient to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public create(patientDto: PatientSaveEditDto, options?: any) {
    return PatientApiFp(this.configuration).create(patientDto, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Edit an existing patient.
   * @param {number} patientId The id of the patient to edit.
   * @param {PatientSaveEditDto} patientDto The new patient data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public edit(
    patientId: number,
    patientDto: PatientSaveEditDto,
    options?: any
  ) {
    return PatientApiFp(this.configuration).edit(
      patientId,
      patientDto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Checks if the proposed patient name edit will generate a duplicate for its associated client
   * @param {string} patientName The new (edited) patient Name.
   * @param {number} patientId The PK id of the patient being edited
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public editingPatientNameWillGenerateDuplicate(
    patientName: string,
    patientId: number,
    options?: any
  ) {
    return PatientApiFp(
      this.configuration
    ).editingPatientNameWillGenerateDuplicate(
      patientName,
      patientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch an existing patient.
   * @param {number} patientId The id of the patient to fetch.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public fetchPatient(patientId: number, options?: any) {
    return PatientApiFp(this.configuration).fetchPatient(patientId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get all genders.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public fetchAllGenders(options?: any) {
    return PatientApiFp(this.configuration).fetchAllGenders(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Find patients by PIMs Patient ID
   * @param {string} pimsPatientId The PIMs ID of the patient
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public findByPimsPatientsId(pimsPatientId: string, options?: any) {
    return PatientApiFp(this.configuration).findByPimsPatientsId(
      pimsPatientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all patients.
   * @param {string} [patientName] The patient name.
   * @param {string} [clientLastName] The client last name.
   * @param {string} [clientIdentifier] The client Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getAll(
    patientName?: string,
    clientLastName?: string,
    clientIdentifier?: string,
    options?: any
  ) {
    return PatientApiFp(this.configuration).getAll(
      patientName,
      clientLastName,
      clientIdentifier,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get lab request records for patient.
   * @param {number} patientId The id of the patient.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getLabRequestRecords(patientId: number, options?: any) {
    return PatientApiFp(this.configuration).getLabRequestRecords(
      patientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get most recent reference class for patient.
   * @param {number} patientId The id of the patient.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getMostRecentRefClass(patientId: number, options?: any) {
    return PatientApiFp(this.configuration).getMostRecentRefClass(
      patientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get most recent weight for patient.
   * @param {number} patientId The id of the patient.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getMostRecentWeight(patientId: number, options?: any) {
    return PatientApiFp(this.configuration).getMostRecentWeight(
      patientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all patients by species.
   * @param {string} [patientName] The patient name.
   * @param {string} [clientLastName] The client last name.
   * @param {string} [clientId] The client Id.
   * @param {number} [speciesId] The id of the species.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getPatientsForSpecies(
    patientName?: string,
    clientLastName?: string,
    clientId?: string,
    speciesId?: number,
    options?: any
  ) {
    return PatientApiFp(this.configuration).getPatientsForSpecies(
      patientName,
      clientLastName,
      clientId,
      speciesId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get all patients with task for last n days.
   * @param {string} [patientName] The patient name.
   * @param {string} [clientLastName] The client last name.
   * @param {string} [clientId] The client Id.
   * @param {number} [daysBack] The number of days.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PatientApi
   */
  public getPatientsWithRunTasks(
    patientName?: string,
    clientLastName?: string,
    clientId?: string,
    daysBack?: number,
    options?: any
  ) {
    return PatientApiFp(this.configuration).getPatientsWithRunTasks(
      patientName,
      clientLastName,
      clientId,
      daysBack,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * PimsApi - fetch parameter creator
 * @export
 */
export const PimsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Adds a new PIMS request. Duplicates rejected.
     * @param {PimsRequestDto} body The PIMS request to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewPimsRequest(body: PimsRequestDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewPimsRequest."
        );
      }
      const localVarPath = `/pims`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PimsRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancels a pending PIMS request
     * @param {number} pimsRequestId The ID of the PIMS pending request to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPendingRequest(pimsRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'pimsRequestId' is not null or undefined
      if (pimsRequestId === null || pimsRequestId === undefined) {
        throw new RequiredError(
          "pimsRequestId",
          "Required parameter pimsRequestId was null or undefined when calling cancelPendingRequest."
        );
      }
      const localVarPath = `/pims/pending/{pimsRequestId}`.replace(
        `{${"pimsRequestId"}}`,
        encodeURIComponent(String(pimsRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Establishes new patient and client records from a PIMS request
     * @param {number} pimsRequestId PIMS request ID of record to create patient and client from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecords(pimsRequestId: number, options: any = {}): FetchArgs {
      // verify required parameter 'pimsRequestId' is not null or undefined
      if (pimsRequestId === null || pimsRequestId === undefined) {
        throw new RequiredError(
          "pimsRequestId",
          "Required parameter pimsRequestId was null or undefined when calling createRecords."
        );
      }
      const localVarPath =
        `/pims/pending/{pimsRequestId}/createRecords`.replace(
          `{${"pimsRequestId"}}`,
          encodeURIComponent(String(pimsRequestId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the census list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCensusList(options: any = {}): FetchArgs {
      const localVarPath = `/pims/census`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the name of the PIMS set up for this IVLS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDeviceName(options: any = {}): FetchArgs {
      const localVarPath = `/pims/deviceName`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch whether pims has ever been connected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEverHadPimsConnected(options: any = {}): FetchArgs {
      const localVarPath = `/pims/everHadPimsConnected`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the pending list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPendingList(options: any = {}): FetchArgs {
      const localVarPath = `/pims/pending`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the unsent run count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUnsentRunCount(options: any = {}): FetchArgs {
      const localVarPath = `/pims/unsentRunCount`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Matches PIMS request data to existing patient and client records
     * @param {number} pimsRequestId PIMS request ID of record to match patient and client with
     * @param {number} patientId Patient ID of record to match PIMS request with
     * @param {number} clientId Client ID of record to match PIMS request with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchRecords(
      pimsRequestId: number,
      patientId: number,
      clientId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'pimsRequestId' is not null or undefined
      if (pimsRequestId === null || pimsRequestId === undefined) {
        throw new RequiredError(
          "pimsRequestId",
          "Required parameter pimsRequestId was null or undefined when calling matchRecords."
        );
      }
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling matchRecords."
        );
      }
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling matchRecords."
        );
      }
      const localVarPath = `/pims/pending/{pimsRequestId}/matchRecords`.replace(
        `{${"pimsRequestId"}}`,
        encodeURIComponent(String(pimsRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (patientId !== undefined) {
        localVarQueryParameter["patientId"] = patientId;
      }

      if (clientId !== undefined) {
        localVarQueryParameter["clientId"] = clientId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request matching object for request id, will return match or list of suggestions
     * @param {number} id PIMs request ID of record to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveMatchingExecutePimsRequest(
      id: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling resolveMatchingExecutePimsRequest."
        );
      }
      const localVarPath = `/pims/pending/{id}/match`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the status of a pending PIMS request to processed
     * @param {number} pimsRequestId The ID of the PIMS pending request to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPendingRequestStatusToProcessed(
      pimsRequestId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'pimsRequestId' is not null or undefined
      if (pimsRequestId === null || pimsRequestId === undefined) {
        throw new RequiredError(
          "pimsRequestId",
          "Required parameter pimsRequestId was null or undefined when calling setPendingRequestStatusToProcessed."
        );
      }
      const localVarPath = `/pims/pending/{pimsRequestId}`.replace(
        `{${"pimsRequestId"}}`,
        encodeURIComponent(String(pimsRequestId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PimsApi - functional programming interface
 * @export
 */
export const PimsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Adds a new PIMS request. Duplicates rejected.
     * @param {PimsRequestDto} body The PIMS request to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewPimsRequest(
      body: PimsRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PimsRequestDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).addNewPimsRequest(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancels a pending PIMS request
     * @param {number} pimsRequestId The ID of the PIMS pending request to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPendingRequest(
      pimsRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PimsRequestDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).cancelPendingRequest(pimsRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Establishes new patient and client records from a PIMS request
     * @param {number} pimsRequestId PIMS request ID of record to create patient and client from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecords(
      pimsRequestId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PendingPimsRequestMatchDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).createRecords(pimsRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the census list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCensusList(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PimsRequestDto>> {
      const localVarFetchArgs =
        PimsApiFetchParamCreator(configuration).fetchCensusList(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the name of the PIMS set up for this IVLS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDeviceName(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        PimsApiFetchParamCreator(configuration).fetchDeviceName(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch whether pims has ever been connected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEverHadPimsConnected(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        PimsApiFetchParamCreator(configuration).fetchEverHadPimsConnected(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the pending list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPendingList(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PimsRequestDto>> {
      const localVarFetchArgs =
        PimsApiFetchParamCreator(configuration).fetchPendingList(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the unsent run count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUnsentRunCount(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs =
        PimsApiFetchParamCreator(configuration).fetchUnsentRunCount(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Matches PIMS request data to existing patient and client records
     * @param {number} pimsRequestId PIMS request ID of record to match patient and client with
     * @param {number} patientId Patient ID of record to match PIMS request with
     * @param {number} clientId Client ID of record to match PIMS request with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchRecords(
      pimsRequestId: number,
      patientId: number,
      clientId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PendingPimsRequestMatchDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).matchRecords(pimsRequestId, patientId, clientId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request matching object for request id, will return match or list of suggestions
     * @param {number} id PIMs request ID of record to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveMatchingExecutePimsRequest(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<PendingPimsRequestMatchDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).resolveMatchingExecutePimsRequest(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the status of a pending PIMS request to processed
     * @param {number} pimsRequestId The ID of the PIMS pending request to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPendingRequestStatusToProcessed(
      pimsRequestId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PimsRequestDto> {
      const localVarFetchArgs = PimsApiFetchParamCreator(
        configuration
      ).setPendingRequestStatusToProcessed(pimsRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PimsApi - factory interface
 * @export
 */
export const PimsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Adds a new PIMS request. Duplicates rejected.
     * @param {PimsRequestDto} body The PIMS request to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewPimsRequest(body: PimsRequestDto, options?: any) {
      return PimsApiFp(configuration).addNewPimsRequest(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Cancels a pending PIMS request
     * @param {number} pimsRequestId The ID of the PIMS pending request to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelPendingRequest(pimsRequestId: number, options?: any) {
      return PimsApiFp(configuration).cancelPendingRequest(
        pimsRequestId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Establishes new patient and client records from a PIMS request
     * @param {number} pimsRequestId PIMS request ID of record to create patient and client from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRecords(pimsRequestId: number, options?: any) {
      return PimsApiFp(configuration).createRecords(pimsRequestId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Gets the census list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCensusList(options?: any) {
      return PimsApiFp(configuration).fetchCensusList(options)(fetch, basePath);
    },
    /**
     *
     * @summary Gets the name of the PIMS set up for this IVLS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDeviceName(options?: any) {
      return PimsApiFp(configuration).fetchDeviceName(options)(fetch, basePath);
    },
    /**
     *
     * @summary Fetch whether pims has ever been connected
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEverHadPimsConnected(options?: any) {
      return PimsApiFp(configuration).fetchEverHadPimsConnected(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Gets the pending list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPendingList(options?: any) {
      return PimsApiFp(configuration).fetchPendingList(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Gets the unsent run count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUnsentRunCount(options?: any) {
      return PimsApiFp(configuration).fetchUnsentRunCount(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Matches PIMS request data to existing patient and client records
     * @param {number} pimsRequestId PIMS request ID of record to match patient and client with
     * @param {number} patientId Patient ID of record to match PIMS request with
     * @param {number} clientId Client ID of record to match PIMS request with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    matchRecords(
      pimsRequestId: number,
      patientId: number,
      clientId: number,
      options?: any
    ) {
      return PimsApiFp(configuration).matchRecords(
        pimsRequestId,
        patientId,
        clientId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request matching object for request id, will return match or list of suggestions
     * @param {number} id PIMs request ID of record to match
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveMatchingExecutePimsRequest(id: number, options?: any) {
      return PimsApiFp(configuration).resolveMatchingExecutePimsRequest(
        id,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the status of a pending PIMS request to processed
     * @param {number} pimsRequestId The ID of the PIMS pending request to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPendingRequestStatusToProcessed(pimsRequestId: number, options?: any) {
      return PimsApiFp(configuration).setPendingRequestStatusToProcessed(
        pimsRequestId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * PimsApi - object-oriented interface
 * @export
 * @class PimsApi
 * @extends {BaseAPI}
 */
export class PimsApi extends BaseAPI {
  /**
   *
   * @summary Adds a new PIMS request. Duplicates rejected.
   * @param {PimsRequestDto} body The PIMS request to add
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public addNewPimsRequest(body: PimsRequestDto, options?: any) {
    return PimsApiFp(this.configuration).addNewPimsRequest(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Cancels a pending PIMS request
   * @param {number} pimsRequestId The ID of the PIMS pending request to cancel
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public cancelPendingRequest(pimsRequestId: number, options?: any) {
    return PimsApiFp(this.configuration).cancelPendingRequest(
      pimsRequestId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Establishes new patient and client records from a PIMS request
   * @param {number} pimsRequestId PIMS request ID of record to create patient and client from
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public createRecords(pimsRequestId: number, options?: any) {
    return PimsApiFp(this.configuration).createRecords(pimsRequestId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets the census list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public fetchCensusList(options?: any) {
    return PimsApiFp(this.configuration).fetchCensusList(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets the name of the PIMS set up for this IVLS.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public fetchDeviceName(options?: any) {
    return PimsApiFp(this.configuration).fetchDeviceName(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch whether pims has ever been connected
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public fetchEverHadPimsConnected(options?: any) {
    return PimsApiFp(this.configuration).fetchEverHadPimsConnected(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets the pending list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public fetchPendingList(options?: any) {
    return PimsApiFp(this.configuration).fetchPendingList(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Gets the unsent run count.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public fetchUnsentRunCount(options?: any) {
    return PimsApiFp(this.configuration).fetchUnsentRunCount(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Matches PIMS request data to existing patient and client records
   * @param {number} pimsRequestId PIMS request ID of record to match patient and client with
   * @param {number} patientId Patient ID of record to match PIMS request with
   * @param {number} clientId Client ID of record to match PIMS request with
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public matchRecords(
    pimsRequestId: number,
    patientId: number,
    clientId: number,
    options?: any
  ) {
    return PimsApiFp(this.configuration).matchRecords(
      pimsRequestId,
      patientId,
      clientId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request matching object for request id, will return match or list of suggestions
   * @param {number} id PIMs request ID of record to match
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public resolveMatchingExecutePimsRequest(id: number, options?: any) {
    return PimsApiFp(this.configuration).resolveMatchingExecutePimsRequest(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the status of a pending PIMS request to processed
   * @param {number} pimsRequestId The ID of the PIMS pending request to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PimsApi
   */
  public setPendingRequestStatusToProcessed(
    pimsRequestId: number,
    options?: any
  ) {
    return PimsApiFp(this.configuration).setPendingRequestStatusToProcessed(
      pimsRequestId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * PprApi - fetch parameter creator
 * @export
 */
export const PprApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Disable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(options: any = {}): FetchArgs {
      const localVarPath = `/ppr/disable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Enable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(options: any = {}): FetchArgs {
      const localVarPath = `/ppr/enable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resets the disconnection date and warning state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(options: any = {}): FetchArgs {
      const localVarPath = `/ppr/reset`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restart the PPR monitor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(options: any = {}): FetchArgs {
      const localVarPath = `/ppr/restart`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the SS disconnection date
     * @param {Date} body The date to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDisconnectionDate(body: Date, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling setDisconnectionDate."
        );
      }
      const localVarPath = `/ppr/disconnectionDate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Date" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Change the monitoring interval for PPR
     * @param {number} body The new interval to use (seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMonitorInterval(body: number, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling setMonitorInterval."
        );
      }
      const localVarPath = `/ppr/monitorInterval`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"number" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Change the number of hours to wait before repopulating the alert
     * @param {number} body The number of seconds to wait before repopulating the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setReminderInterval(body: number, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling setReminderInterval."
        );
      }
      const localVarPath = `/ppr/reminderInterval`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"number" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PprApi - functional programming interface
 * @export
 */
export const PprApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Disable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        PprApiFetchParamCreator(configuration).disable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Enable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        PprApiFetchParamCreator(configuration).enable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resets the disconnection date and warning state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        PprApiFetchParamCreator(configuration).reset(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Restart the PPR monitor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        PprApiFetchParamCreator(configuration).restart(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set the SS disconnection date
     * @param {Date} body The date to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDisconnectionDate(
      body: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = PprApiFetchParamCreator(
        configuration
      ).setDisconnectionDate(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Change the monitoring interval for PPR
     * @param {number} body The new interval to use (seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMonitorInterval(
      body: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = PprApiFetchParamCreator(
        configuration
      ).setMonitorInterval(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Change the number of hours to wait before repopulating the alert
     * @param {number} body The number of seconds to wait before repopulating the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setReminderInterval(
      body: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = PprApiFetchParamCreator(
        configuration
      ).setReminderInterval(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * PprApi - factory interface
 * @export
 */
export const PprApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Disable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(options?: any) {
      return PprApiFp(configuration).disable(options)(fetch, basePath);
    },
    /**
     *
     * @summary Enable PPR
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(options?: any) {
      return PprApiFp(configuration).enable(options)(fetch, basePath);
    },
    /**
     *
     * @summary Resets the disconnection date and warning state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(options?: any) {
      return PprApiFp(configuration).reset(options)(fetch, basePath);
    },
    /**
     *
     * @summary Restart the PPR monitor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(options?: any) {
      return PprApiFp(configuration).restart(options)(fetch, basePath);
    },
    /**
     *
     * @summary Set the SS disconnection date
     * @param {Date} body The date to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDisconnectionDate(body: Date, options?: any) {
      return PprApiFp(configuration).setDisconnectionDate(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Change the monitoring interval for PPR
     * @param {number} body The new interval to use (seconds)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMonitorInterval(body: number, options?: any) {
      return PprApiFp(configuration).setMonitorInterval(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Change the number of hours to wait before repopulating the alert
     * @param {number} body The number of seconds to wait before repopulating the alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setReminderInterval(body: number, options?: any) {
      return PprApiFp(configuration).setReminderInterval(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * PprApi - object-oriented interface
 * @export
 * @class PprApi
 * @extends {BaseAPI}
 */
export class PprApi extends BaseAPI {
  /**
   *
   * @summary Disable PPR
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public disable(options?: any) {
    return PprApiFp(this.configuration).disable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Enable PPR
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public enable(options?: any) {
    return PprApiFp(this.configuration).enable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Resets the disconnection date and warning state
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public reset(options?: any) {
    return PprApiFp(this.configuration).reset(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Restart the PPR monitor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public restart(options?: any) {
    return PprApiFp(this.configuration).restart(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Set the SS disconnection date
   * @param {Date} body The date to set
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public setDisconnectionDate(body: Date, options?: any) {
    return PprApiFp(this.configuration).setDisconnectionDate(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Change the monitoring interval for PPR
   * @param {number} body The new interval to use (seconds)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public setMonitorInterval(body: number, options?: any) {
    return PprApiFp(this.configuration).setMonitorInterval(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Change the number of hours to wait before repopulating the alert
   * @param {number} body The number of seconds to wait before repopulating the alert
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PprApi
   */
  public setReminderInterval(body: number, options?: any) {
    return PprApiFp(this.configuration).setReminderInterval(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ProCyteApi - fetch parameter creator
 * @export
 */
export const ProCyteApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Execute instrument procedure request.
     * @param {number} instrumentId The id of connected device.
     * @param {"SETTING_SEQUENCE_REQUEST" | "AUTO_RINSE_REQUEST" | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST" | "DRAIN_REACTION_CHAMBER_REQUEST" | "RINSE_FLOWCELL_REQUEST" | "RINSE_WASTE_CHAMBER_REQUEST" | "MONTHLY_RINSE_REQUEST" | "DRAIN_WASTE_FLUID_REQUEST" | "AIR_PUMP_REQUEST" | "ASPIRATION_UNIT_MOTOR_REQUEST" | "SHEATH_MOTOR_REQUEST" | "TUBE_HOLDER_MOTOR_REQUEST" | "WB_MOTOR_REQUEST" | "REMOVE_CLOGS_REQUEST" | "PINCH_VALVE_REQUEST" | "SHUTDOWN_FOR_SHIPPING" | "SHUTDOWN" | "BACKUP" | "REAGENT_STATUS_QUERY"} instrumentProcedureRequest Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeProcedureRequest(
      instrumentId: number,
      instrumentProcedureRequest:
        | "SETTING_SEQUENCE_REQUEST"
        | "AUTO_RINSE_REQUEST"
        | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST"
        | "DRAIN_REACTION_CHAMBER_REQUEST"
        | "RINSE_FLOWCELL_REQUEST"
        | "RINSE_WASTE_CHAMBER_REQUEST"
        | "MONTHLY_RINSE_REQUEST"
        | "DRAIN_WASTE_FLUID_REQUEST"
        | "AIR_PUMP_REQUEST"
        | "ASPIRATION_UNIT_MOTOR_REQUEST"
        | "SHEATH_MOTOR_REQUEST"
        | "TUBE_HOLDER_MOTOR_REQUEST"
        | "WB_MOTOR_REQUEST"
        | "REMOVE_CLOGS_REQUEST"
        | "PINCH_VALVE_REQUEST"
        | "SHUTDOWN_FOR_SHIPPING"
        | "SHUTDOWN"
        | "BACKUP"
        | "REAGENT_STATUS_QUERY",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling executeProcedureRequest."
        );
      }
      // verify required parameter 'instrumentProcedureRequest' is not null or undefined
      if (
        instrumentProcedureRequest === null ||
        instrumentProcedureRequest === undefined
      ) {
        throw new RequiredError(
          "instrumentProcedureRequest",
          "Required parameter instrumentProcedureRequest was null or undefined when calling executeProcedureRequest."
        );
      }
      const localVarPath = `/proCyte/{instrumentId}/procedure/execute`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentProcedureRequest !== undefined) {
        localVarQueryParameter["instrumentProcedureRequest"] =
          instrumentProcedureRequest;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets the installed reagents.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstalledReagents(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstalledReagents."
        );
      }
      const localVarPath = `/proCyte/{instrumentId}/reagents`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Ejects CD-ROM in most cases.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeCd(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling initializeCd."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling initializeCd."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/initializeCd`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from CD and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromCd(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling installFromCd."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling installFromCd."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/installFromCd`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from local file system and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromLocal(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling installFromLocal."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling installFromLocal."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/installFromLocal`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from USB and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling installFromUsb."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling installFromUsb."
        );
      }
      // verify required parameter 'driveId' is not null or undefined
      if (driveId === null || driveId === undefined) {
        throw new RequiredError(
          "driveId",
          "Required parameter driveId was null or undefined when calling installFromUsb."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/installFromUsb`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      if (driveId !== undefined) {
        localVarQueryParameter["driveId"] = driveId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Replaces a reagent.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {CrimsonReplaceReagentDto} body The reagent to install.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceReagent(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: CrimsonReplaceReagentDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling replaceReagent."
        );
      }
      // verify required parameter 'reagent' is not null or undefined
      if (reagent === null || reagent === undefined) {
        throw new RequiredError(
          "reagent",
          "Required parameter reagent was null or undefined when calling replaceReagent."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling replaceReagent."
        );
      }
      const localVarPath = `/proCyte/{instrumentId}/reagents/{reagent}/replace`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"reagent"}}`, encodeURIComponent(String(reagent)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CrimsonReplaceReagentDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Execute replenish procedure on reagent.
     * @param {number} instrumentId The id of connected device.
     * @param {"EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS"} reagent Reagent name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replenishReagent(
      instrumentId: number,
      reagent: "EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling replenishReagent."
        );
      }
      // verify required parameter 'reagent' is not null or undefined
      if (reagent === null || reagent === undefined) {
        throw new RequiredError(
          "reagent",
          "Required parameter reagent was null or undefined when calling replenishReagent."
        );
      }
      const localVarPath = `/proCyte/{instrumentId}/reagents/replenish`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (reagent !== undefined) {
        localVarQueryParameter["reagent"] = reagent;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Start Shutdown procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestStartupQuery(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestStartupQuery."
        );
      }
      const localVarPath = `/proCyte/{instrumentId}/startupQuery`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {CrimsonQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(
      body: CrimsonQcBarcodeSaveRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveQcBarcodes."
        );
      }
      const localVarPath = `/proCyte/qc/barcodes/save`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CrimsonQcBarcodeSaveRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from CD.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromCd(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling transmitSerialNumberFromCd."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling transmitSerialNumberFromCd."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/transmitSerialNumberFromCd`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from local.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromLocal(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling transmitSerialNumberFromLocal."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling transmitSerialNumberFromLocal."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/transmitSerialNumberFromLocal`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from USB.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling transmitSerialNumberFromUsb."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling transmitSerialNumberFromUsb."
        );
      }
      // verify required parameter 'driveId' is not null or undefined
      if (driveId === null || driveId === undefined) {
        throw new RequiredError(
          "driveId",
          "Required parameter driveId was null or undefined when calling transmitSerialNumberFromUsb."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/transmitSerialNumberFromUsb`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      if (driveId !== undefined) {
        localVarQueryParameter["driveId"] = driveId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {CrimsonQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(
      body: CrimsonQcBarcodeValidateRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling validateQcBarcodes."
        );
      }
      const localVarPath = `/proCyte/qc/barcodes/validate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CrimsonQcBarcodeValidateRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validates a reagent barcode.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {string} body The encrypted reagent barcode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateReagentBarcode(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling validateReagentBarcode."
        );
      }
      // verify required parameter 'reagent' is not null or undefined
      if (reagent === null || reagent === undefined) {
        throw new RequiredError(
          "reagent",
          "Required parameter reagent was null or undefined when calling validateReagentBarcode."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling validateReagentBarcode."
        );
      }
      const localVarPath =
        `/proCyte/{instrumentId}/reagents/{reagent}/barcodes/validate`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(`{${"reagent"}}`, encodeURIComponent(String(reagent)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"string" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on CD based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCd(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling verifyCd."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling verifyCd."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/verifyCd`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on local file system.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyLocal(
      instrumentId: number,
      serialNumber: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling verifyLocal."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling verifyLocal."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/verifyLocal`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on USB based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling verifyUsb."
        );
      }
      // verify required parameter 'serialNumber' is not null or undefined
      if (serialNumber === null || serialNumber === undefined) {
        throw new RequiredError(
          "serialNumber",
          "Required parameter serialNumber was null or undefined when calling verifyUsb."
        );
      }
      // verify required parameter 'driveId' is not null or undefined
      if (driveId === null || driveId === undefined) {
        throw new RequiredError(
          "driveId",
          "Required parameter driveId was null or undefined when calling verifyUsb."
        );
      }
      const localVarPath =
        `/proCyte/installation/instrument/{instrumentId}/verifyUsb`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serialNumber !== undefined) {
        localVarQueryParameter["serialNumber"] = serialNumber;
      }

      if (driveId !== undefined) {
        localVarQueryParameter["driveId"] = driveId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProCyteApi - functional programming interface
 * @export
 */
export const ProCyteApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Execute instrument procedure request.
     * @param {number} instrumentId The id of connected device.
     * @param {"SETTING_SEQUENCE_REQUEST" | "AUTO_RINSE_REQUEST" | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST" | "DRAIN_REACTION_CHAMBER_REQUEST" | "RINSE_FLOWCELL_REQUEST" | "RINSE_WASTE_CHAMBER_REQUEST" | "MONTHLY_RINSE_REQUEST" | "DRAIN_WASTE_FLUID_REQUEST" | "AIR_PUMP_REQUEST" | "ASPIRATION_UNIT_MOTOR_REQUEST" | "SHEATH_MOTOR_REQUEST" | "TUBE_HOLDER_MOTOR_REQUEST" | "WB_MOTOR_REQUEST" | "REMOVE_CLOGS_REQUEST" | "PINCH_VALVE_REQUEST" | "SHUTDOWN_FOR_SHIPPING" | "SHUTDOWN" | "BACKUP" | "REAGENT_STATUS_QUERY"} instrumentProcedureRequest Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeProcedureRequest(
      instrumentId: number,
      instrumentProcedureRequest:
        | "SETTING_SEQUENCE_REQUEST"
        | "AUTO_RINSE_REQUEST"
        | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST"
        | "DRAIN_REACTION_CHAMBER_REQUEST"
        | "RINSE_FLOWCELL_REQUEST"
        | "RINSE_WASTE_CHAMBER_REQUEST"
        | "MONTHLY_RINSE_REQUEST"
        | "DRAIN_WASTE_FLUID_REQUEST"
        | "AIR_PUMP_REQUEST"
        | "ASPIRATION_UNIT_MOTOR_REQUEST"
        | "SHEATH_MOTOR_REQUEST"
        | "TUBE_HOLDER_MOTOR_REQUEST"
        | "WB_MOTOR_REQUEST"
        | "REMOVE_CLOGS_REQUEST"
        | "PINCH_VALVE_REQUEST"
        | "SHUTDOWN_FOR_SHIPPING"
        | "SHUTDOWN"
        | "BACKUP"
        | "REAGENT_STATUS_QUERY",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).executeProcedureRequest(
        instrumentId,
        instrumentProcedureRequest,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets the installed reagents.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstalledReagents(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<CrimsonInstalledReagentDto>> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).fetchInstalledReagents(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Ejects CD-ROM in most cases.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeCd(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).initializeCd(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from CD and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromCd(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).installFromCd(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from local file system and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromLocal(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).installFromLocal(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from USB and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).installFromUsb(instrumentId, serialNumber, driveId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Replaces a reagent.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {CrimsonReplaceReagentDto} body The reagent to install.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceReagent(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: CrimsonReplaceReagentDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).replaceReagent(instrumentId, reagent, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Execute replenish procedure on reagent.
     * @param {number} instrumentId The id of connected device.
     * @param {"EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS"} reagent Reagent name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replenishReagent(
      instrumentId: number,
      reagent: "EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).replenishReagent(instrumentId, reagent, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Start Shutdown procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestStartupQuery(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<InstrumentStartupResponseDto> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).requestStartupQuery(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {CrimsonQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(
      body: CrimsonQcBarcodeSaveRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).saveQcBarcodes(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from CD.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromCd(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).transmitSerialNumberFromCd(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from local.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromLocal(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).transmitSerialNumberFromLocal(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Transmits serial number to the device from USB.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).transmitSerialNumberFromUsb(
        instrumentId,
        serialNumber,
        driveId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {CrimsonQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(
      body: CrimsonQcBarcodeValidateRequestDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<CrimsonQcBarcodeValidateResponseDto> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).validateQcBarcodes(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validates a reagent barcode.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {string} body The encrypted reagent barcode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateReagentBarcode(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).validateReagentBarcode(instrumentId, reagent, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on CD based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCd(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).verifyCd(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on local file system.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyLocal(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).verifyLocal(instrumentId, serialNumber, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on USB based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ProCyteApiFetchParamCreator(
        configuration
      ).verifyUsb(instrumentId, serialNumber, driveId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ProCyteApi - factory interface
 * @export
 */
export const ProCyteApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Execute instrument procedure request.
     * @param {number} instrumentId The id of connected device.
     * @param {"SETTING_SEQUENCE_REQUEST" | "AUTO_RINSE_REQUEST" | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST" | "DRAIN_REACTION_CHAMBER_REQUEST" | "RINSE_FLOWCELL_REQUEST" | "RINSE_WASTE_CHAMBER_REQUEST" | "MONTHLY_RINSE_REQUEST" | "DRAIN_WASTE_FLUID_REQUEST" | "AIR_PUMP_REQUEST" | "ASPIRATION_UNIT_MOTOR_REQUEST" | "SHEATH_MOTOR_REQUEST" | "TUBE_HOLDER_MOTOR_REQUEST" | "WB_MOTOR_REQUEST" | "REMOVE_CLOGS_REQUEST" | "PINCH_VALVE_REQUEST" | "SHUTDOWN_FOR_SHIPPING" | "SHUTDOWN" | "BACKUP" | "REAGENT_STATUS_QUERY"} instrumentProcedureRequest Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeProcedureRequest(
      instrumentId: number,
      instrumentProcedureRequest:
        | "SETTING_SEQUENCE_REQUEST"
        | "AUTO_RINSE_REQUEST"
        | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST"
        | "DRAIN_REACTION_CHAMBER_REQUEST"
        | "RINSE_FLOWCELL_REQUEST"
        | "RINSE_WASTE_CHAMBER_REQUEST"
        | "MONTHLY_RINSE_REQUEST"
        | "DRAIN_WASTE_FLUID_REQUEST"
        | "AIR_PUMP_REQUEST"
        | "ASPIRATION_UNIT_MOTOR_REQUEST"
        | "SHEATH_MOTOR_REQUEST"
        | "TUBE_HOLDER_MOTOR_REQUEST"
        | "WB_MOTOR_REQUEST"
        | "REMOVE_CLOGS_REQUEST"
        | "PINCH_VALVE_REQUEST"
        | "SHUTDOWN_FOR_SHIPPING"
        | "SHUTDOWN"
        | "BACKUP"
        | "REAGENT_STATUS_QUERY",
      options?: any
    ) {
      return ProCyteApiFp(configuration).executeProcedureRequest(
        instrumentId,
        instrumentProcedureRequest,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets the installed reagents.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstalledReagents(instrumentId: number, options?: any) {
      return ProCyteApiFp(configuration).fetchInstalledReagents(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Ejects CD-ROM in most cases.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeCd(instrumentId: number, serialNumber: string, options?: any) {
      return ProCyteApiFp(configuration).initializeCd(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from CD and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromCd(instrumentId: number, serialNumber: string, options?: any) {
      return ProCyteApiFp(configuration).installFromCd(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from local file system and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromLocal(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).installFromLocal(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Installs calibration file onto the instrument from USB and transmits the serial number.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).installFromUsb(
        instrumentId,
        serialNumber,
        driveId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Replaces a reagent.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {CrimsonReplaceReagentDto} body The reagent to install.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceReagent(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: CrimsonReplaceReagentDto,
      options?: any
    ) {
      return ProCyteApiFp(configuration).replaceReagent(
        instrumentId,
        reagent,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Execute replenish procedure on reagent.
     * @param {number} instrumentId The id of connected device.
     * @param {"EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS"} reagent Reagent name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replenishReagent(
      instrumentId: number,
      reagent: "EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS",
      options?: any
    ) {
      return ProCyteApiFp(configuration).replenishReagent(
        instrumentId,
        reagent,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Start Shutdown procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestStartupQuery(instrumentId: number, options?: any) {
      return ProCyteApiFp(configuration).requestStartupQuery(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {CrimsonQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(body: CrimsonQcBarcodeSaveRequestDto, options?: any) {
      return ProCyteApiFp(configuration).saveQcBarcodes(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Transmits serial number to the device from CD.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromCd(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).transmitSerialNumberFromCd(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Transmits serial number to the device from local.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromLocal(
      instrumentId: number,
      serialNumber: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).transmitSerialNumberFromLocal(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Transmits serial number to the device from USB.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transmitSerialNumberFromUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).transmitSerialNumberFromUsb(
        instrumentId,
        serialNumber,
        driveId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {CrimsonQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(
      body: CrimsonQcBarcodeValidateRequestDto,
      options?: any
    ) {
      return ProCyteApiFp(configuration).validateQcBarcodes(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Validates a reagent barcode.
     * @param {number} instrumentId The instrument id.
     * @param {"REAGENT" | "STAIN"} reagent The reagent type.
     * @param {string} body The encrypted reagent barcode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateReagentBarcode(
      instrumentId: number,
      reagent: "REAGENT" | "STAIN",
      body: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).validateReagentBarcode(
        instrumentId,
        reagent,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on CD based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCd(instrumentId: number, serialNumber: string, options?: any) {
      return ProCyteApiFp(configuration).verifyCd(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on local file system.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyLocal(instrumentId: number, serialNumber: string, options?: any) {
      return ProCyteApiFp(configuration).verifyLocal(
        instrumentId,
        serialNumber,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Initial check of calibration files installation readiness on USB based media.
     * @param {number} instrumentId The id of connected device.
     * @param {string} serialNumber Serial number.
     * @param {string} driveId Drive ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUsb(
      instrumentId: number,
      serialNumber: string,
      driveId: string,
      options?: any
    ) {
      return ProCyteApiFp(configuration).verifyUsb(
        instrumentId,
        serialNumber,
        driveId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ProCyteApi - object-oriented interface
 * @export
 * @class ProCyteApi
 * @extends {BaseAPI}
 */
export class ProCyteApi extends BaseAPI {
  /**
   *
   * @summary Execute instrument procedure request.
   * @param {number} instrumentId The id of connected device.
   * @param {"SETTING_SEQUENCE_REQUEST" | "AUTO_RINSE_REQUEST" | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST" | "DRAIN_REACTION_CHAMBER_REQUEST" | "RINSE_FLOWCELL_REQUEST" | "RINSE_WASTE_CHAMBER_REQUEST" | "MONTHLY_RINSE_REQUEST" | "DRAIN_WASTE_FLUID_REQUEST" | "AIR_PUMP_REQUEST" | "ASPIRATION_UNIT_MOTOR_REQUEST" | "SHEATH_MOTOR_REQUEST" | "TUBE_HOLDER_MOTOR_REQUEST" | "WB_MOTOR_REQUEST" | "REMOVE_CLOGS_REQUEST" | "PINCH_VALVE_REQUEST" | "SHUTDOWN_FOR_SHIPPING" | "SHUTDOWN" | "BACKUP" | "REAGENT_STATUS_QUERY"} instrumentProcedureRequest Instrument procedure name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public executeProcedureRequest(
    instrumentId: number,
    instrumentProcedureRequest:
      | "SETTING_SEQUENCE_REQUEST"
      | "AUTO_RINSE_REQUEST"
      | "DRAIN_RBC_ISOLATION_CHAMBER_REQUEST"
      | "DRAIN_REACTION_CHAMBER_REQUEST"
      | "RINSE_FLOWCELL_REQUEST"
      | "RINSE_WASTE_CHAMBER_REQUEST"
      | "MONTHLY_RINSE_REQUEST"
      | "DRAIN_WASTE_FLUID_REQUEST"
      | "AIR_PUMP_REQUEST"
      | "ASPIRATION_UNIT_MOTOR_REQUEST"
      | "SHEATH_MOTOR_REQUEST"
      | "TUBE_HOLDER_MOTOR_REQUEST"
      | "WB_MOTOR_REQUEST"
      | "REMOVE_CLOGS_REQUEST"
      | "PINCH_VALVE_REQUEST"
      | "SHUTDOWN_FOR_SHIPPING"
      | "SHUTDOWN"
      | "BACKUP"
      | "REAGENT_STATUS_QUERY",
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).executeProcedureRequest(
      instrumentId,
      instrumentProcedureRequest,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets the installed reagents.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public fetchInstalledReagents(instrumentId: number, options?: any) {
    return ProCyteApiFp(this.configuration).fetchInstalledReagents(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Ejects CD-ROM in most cases.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public initializeCd(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).initializeCd(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Installs calibration file onto the instrument from CD and transmits the serial number.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public installFromCd(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).installFromCd(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Installs calibration file onto the instrument from local file system and transmits the serial number.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public installFromLocal(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).installFromLocal(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Installs calibration file onto the instrument from USB and transmits the serial number.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {string} driveId Drive ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public installFromUsb(
    instrumentId: number,
    serialNumber: string,
    driveId: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).installFromUsb(
      instrumentId,
      serialNumber,
      driveId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Replaces a reagent.
   * @param {number} instrumentId The instrument id.
   * @param {"REAGENT" | "STAIN"} reagent The reagent type.
   * @param {CrimsonReplaceReagentDto} body The reagent to install.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public replaceReagent(
    instrumentId: number,
    reagent: "REAGENT" | "STAIN",
    body: CrimsonReplaceReagentDto,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).replaceReagent(
      instrumentId,
      reagent,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Execute replenish procedure on reagent.
   * @param {number} instrumentId The id of connected device.
   * @param {"EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS"} reagent Reagent name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public replenishReagent(
    instrumentId: number,
    reagent: "EPK" | "SLS" | "FFD" | "RED" | "RES" | "FFS",
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).replenishReagent(
      instrumentId,
      reagent,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Start Shutdown procedure.
   * @param {number} instrumentId The id of connected device.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public requestStartupQuery(instrumentId: number, options?: any) {
    return ProCyteApiFp(this.configuration).requestStartupQuery(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Saves quality control barcodes.
   * @param {CrimsonQcBarcodeSaveRequestDto} body The quality control barcodes to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public saveQcBarcodes(body: CrimsonQcBarcodeSaveRequestDto, options?: any) {
    return ProCyteApiFp(this.configuration).saveQcBarcodes(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Transmits serial number to the device from CD.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public transmitSerialNumberFromCd(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).transmitSerialNumberFromCd(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Transmits serial number to the device from local.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public transmitSerialNumberFromLocal(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).transmitSerialNumberFromLocal(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Transmits serial number to the device from USB.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {string} driveId Drive ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public transmitSerialNumberFromUsb(
    instrumentId: number,
    serialNumber: string,
    driveId: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).transmitSerialNumberFromUsb(
      instrumentId,
      serialNumber,
      driveId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Validates quality control barcodes.
   * @param {CrimsonQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public validateQcBarcodes(
    body: CrimsonQcBarcodeValidateRequestDto,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).validateQcBarcodes(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Validates a reagent barcode.
   * @param {number} instrumentId The instrument id.
   * @param {"REAGENT" | "STAIN"} reagent The reagent type.
   * @param {string} body The encrypted reagent barcode.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public validateReagentBarcode(
    instrumentId: number,
    reagent: "REAGENT" | "STAIN",
    body: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).validateReagentBarcode(
      instrumentId,
      reagent,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Initial check of calibration files installation readiness on CD based media.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public verifyCd(instrumentId: number, serialNumber: string, options?: any) {
    return ProCyteApiFp(this.configuration).verifyCd(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Initial check of calibration files installation readiness on local file system.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public verifyLocal(
    instrumentId: number,
    serialNumber: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).verifyLocal(
      instrumentId,
      serialNumber,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Initial check of calibration files installation readiness on USB based media.
   * @param {number} instrumentId The id of connected device.
   * @param {string} serialNumber Serial number.
   * @param {string} driveId Drive ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProCyteApi
   */
  public verifyUsb(
    instrumentId: number,
    serialNumber: string,
    driveId: string,
    options?: any
  ) {
    return ProCyteApiFp(this.configuration).verifyUsb(
      instrumentId,
      serialNumber,
      driveId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ProceduresApi - fetch parameter creator
 * @export
 */
export const ProceduresApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Cancel procedure for the given instrument.
     * @param {string} procedureName The procedure to be canceled.
     * @param {number} [instrumentId] The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProcedure(
      procedureName: string,
      instrumentId?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'procedureName' is not null or undefined
      if (procedureName === null || procedureName === undefined) {
        throw new RequiredError(
          "procedureName",
          "Required parameter procedureName was null or undefined when calling cancelProcedure."
        );
      }
      const localVarPath = `/procedures/{procedureName}/cancel`.replace(
        `{${"procedureName"}}`,
        encodeURIComponent(String(procedureName))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProceduresApi - functional programming interface
 * @export
 */
export const ProceduresApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel procedure for the given instrument.
     * @param {string} procedureName The procedure to be canceled.
     * @param {number} [instrumentId] The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProcedure(
      procedureName: string,
      instrumentId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ProceduresApiFetchParamCreator(
        configuration
      ).cancelProcedure(procedureName, instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ProceduresApi - factory interface
 * @export
 */
export const ProceduresApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Cancel procedure for the given instrument.
     * @param {string} procedureName The procedure to be canceled.
     * @param {number} [instrumentId] The id of the target instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelProcedure(
      procedureName: string,
      instrumentId?: number,
      options?: any
    ) {
      return ProceduresApiFp(configuration).cancelProcedure(
        procedureName,
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ProceduresApi - object-oriented interface
 * @export
 * @class ProceduresApi
 * @extends {BaseAPI}
 */
export class ProceduresApi extends BaseAPI {
  /**
   *
   * @summary Cancel procedure for the given instrument.
   * @param {string} procedureName The procedure to be canceled.
   * @param {number} [instrumentId] The id of the target instrument.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProceduresApi
   */
  public cancelProcedure(
    procedureName: string,
    instrumentId?: number,
    options?: any
  ) {
    return ProceduresApiFp(this.configuration).cancelProcedure(
      procedureName,
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * QualityControlApi - fetch parameter creator
 * @export
 */
export const QualityControlApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary execute a quality control run in line with the data supplied in the request object
     * @param {QualityControlRunRequestDto} body Properties of the requested quality control run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl(
      body: QualityControlRunRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeQualityControl."
        );
      }
      const localVarPath = `/qualityControl`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"QualityControlRunRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary execute a quality control run on the instrument with the specified ID
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl_1(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling executeQualityControl_1."
        );
      }
      const localVarPath = `/qualityControl/{instrumentId}`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets CO/CDx QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {"Offsets" | "QualityControl"} filter The QC lots filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatalystQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      filter: "Offsets" | "QualityControl",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchCatalystQualityControlLots."
        );
      }
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling fetchCatalystQualityControlLots."
        );
      }
      // verify required parameter 'filter' is not null or undefined
      if (filter === null || filter === undefined) {
        throw new RequiredError(
          "filter",
          "Required parameter filter was null or undefined when calling fetchCatalystQualityControlLots."
        );
      }
      const localVarPath = `/qualityControl/catalyst/lots`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      if (instrumentType !== undefined) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      if (filter !== undefined) {
        localVarQueryParameter["filter"] = filter;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchQualityControlLots."
        );
      }
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling fetchQualityControlLots."
        );
      }
      const localVarPath = `/qualityControl/lots`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      if (instrumentType !== undefined) {
        localVarQueryParameter["instrumentType"] = instrumentType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save the provided trend.
     * @param {number} qualityControlRunId The Quality Control Run ID.
     * @param {QualityControlTrendDto} [body] The trend to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQualityControlTrendingReason(
      qualityControlRunId: number,
      body?: QualityControlTrendDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'qualityControlRunId' is not null or undefined
      if (qualityControlRunId === null || qualityControlRunId === undefined) {
        throw new RequiredError(
          "qualityControlRunId",
          "Required parameter qualityControlRunId was null or undefined when calling updateQualityControlTrendingReason."
        );
      }
      const localVarPath =
        `/qualityControl/{qualityControlRunId}/trends`.replace(
          `{${"qualityControlRunId"}}`,
          encodeURIComponent(String(qualityControlRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"QualityControlTrendDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QualityControlApi - functional programming interface
 * @export
 */
export const QualityControlApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary execute a quality control run in line with the data supplied in the request object
     * @param {QualityControlRunRequestDto} body Properties of the requested quality control run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl(
      body: QualityControlRunRequestDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ExecuteQualityControlRunResponseDto> {
      const localVarFetchArgs = QualityControlApiFetchParamCreator(
        configuration
      ).executeQualityControl(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary execute a quality control run on the instrument with the specified ID
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl_1(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ExecuteQualityControlRunResponseDto> {
      const localVarFetchArgs = QualityControlApiFetchParamCreator(
        configuration
      ).executeQualityControl_1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets CO/CDx QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {"Offsets" | "QualityControl"} filter The QC lots filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatalystQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      filter: "Offsets" | "QualityControl",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<QualityControlDto>> {
      const localVarFetchArgs = QualityControlApiFetchParamCreator(
        configuration
      ).fetchCatalystQualityControlLots(
        instrumentId,
        instrumentType,
        filter,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<QualityControlDto>> {
      const localVarFetchArgs = QualityControlApiFetchParamCreator(
        configuration
      ).fetchQualityControlLots(instrumentId, instrumentType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save the provided trend.
     * @param {number} qualityControlRunId The Quality Control Run ID.
     * @param {QualityControlTrendDto} [body] The trend to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQualityControlTrendingReason(
      qualityControlRunId: number,
      body?: QualityControlTrendDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = QualityControlApiFetchParamCreator(
        configuration
      ).updateQualityControlTrendingReason(qualityControlRunId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * QualityControlApi - factory interface
 * @export
 */
export const QualityControlApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary execute a quality control run in line with the data supplied in the request object
     * @param {QualityControlRunRequestDto} body Properties of the requested quality control run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl(body: QualityControlRunRequestDto, options?: any) {
      return QualityControlApiFp(configuration).executeQualityControl(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary execute a quality control run on the instrument with the specified ID
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeQualityControl_1(instrumentId: number, options?: any) {
      return QualityControlApiFp(configuration).executeQualityControl_1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets CO/CDx QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {"Offsets" | "QualityControl"} filter The QC lots filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCatalystQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      filter: "Offsets" | "QualityControl",
      options?: any
    ) {
      return QualityControlApiFp(configuration).fetchCatalystQualityControlLots(
        instrumentId,
        instrumentType,
        filter,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets QC lots.
     * @param {number} instrumentId The instrument id.
     * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchQualityControlLots(
      instrumentId: number,
      instrumentType:
        | "LASERCYTE"
        | "VETTEST"
        | "AUTOREADER"
        | "SNAPREADER"
        | "VETLYTE"
        | "SERIAL_PIMS"
        | "VETSTAT"
        | "UA_ANALYZER"
        | "SNAP"
        | "CATALYST_DX"
        | "SNAPSHOT_DX"
        | "COAG_DX"
        | "CRIMSON"
        | "SMARTLINK_PIMS"
        | "INTERLINK_PIMS"
        | "LASERCYTE_DX"
        | "SNAPPRO"
        | "CATONE"
        | "URISED"
        | "MANUAL_UA"
        | "MANUAL_CRP"
        | "ACADIA_DX"
        | "URISYS_DX"
        | "THEIA"
        | "TENSEI",
      options?: any
    ) {
      return QualityControlApiFp(configuration).fetchQualityControlLots(
        instrumentId,
        instrumentType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save the provided trend.
     * @param {number} qualityControlRunId The Quality Control Run ID.
     * @param {QualityControlTrendDto} [body] The trend to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQualityControlTrendingReason(
      qualityControlRunId: number,
      body?: QualityControlTrendDto,
      options?: any
    ) {
      return QualityControlApiFp(
        configuration
      ).updateQualityControlTrendingReason(
        qualityControlRunId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * QualityControlApi - object-oriented interface
 * @export
 * @class QualityControlApi
 * @extends {BaseAPI}
 */
export class QualityControlApi extends BaseAPI {
  /**
   *
   * @summary execute a quality control run in line with the data supplied in the request object
   * @param {QualityControlRunRequestDto} body Properties of the requested quality control run.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QualityControlApi
   */
  public executeQualityControl(
    body: QualityControlRunRequestDto,
    options?: any
  ) {
    return QualityControlApiFp(this.configuration).executeQualityControl(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary execute a quality control run on the instrument with the specified ID
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QualityControlApi
   */
  public executeQualityControl_1(instrumentId: number, options?: any) {
    return QualityControlApiFp(this.configuration).executeQualityControl_1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets CO/CDx QC lots.
   * @param {number} instrumentId The instrument id.
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
   * @param {"Offsets" | "QualityControl"} filter The QC lots filter.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QualityControlApi
   */
  public fetchCatalystQualityControlLots(
    instrumentId: number,
    instrumentType:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    filter: "Offsets" | "QualityControl",
    options?: any
  ) {
    return QualityControlApiFp(
      this.configuration
    ).fetchCatalystQualityControlLots(
      instrumentId,
      instrumentType,
      filter,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets QC lots.
   * @param {number} instrumentId The instrument id.
   * @param {"LASERCYTE" | "VETTEST" | "AUTOREADER" | "SNAPREADER" | "VETLYTE" | "SERIAL_PIMS" | "VETSTAT" | "UA_ANALYZER" | "SNAP" | "CATALYST_DX" | "SNAPSHOT_DX" | "COAG_DX" | "CRIMSON" | "SMARTLINK_PIMS" | "INTERLINK_PIMS" | "LASERCYTE_DX" | "SNAPPRO" | "CATONE" | "URISED" | "MANUAL_UA" | "MANUAL_CRP" | "ACADIA_DX" | "URISYS_DX" | "THEIA" | "TENSEI"} instrumentType The instrument type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QualityControlApi
   */
  public fetchQualityControlLots(
    instrumentId: number,
    instrumentType:
      | "LASERCYTE"
      | "VETTEST"
      | "AUTOREADER"
      | "SNAPREADER"
      | "VETLYTE"
      | "SERIAL_PIMS"
      | "VETSTAT"
      | "UA_ANALYZER"
      | "SNAP"
      | "CATALYST_DX"
      | "SNAPSHOT_DX"
      | "COAG_DX"
      | "CRIMSON"
      | "SMARTLINK_PIMS"
      | "INTERLINK_PIMS"
      | "LASERCYTE_DX"
      | "SNAPPRO"
      | "CATONE"
      | "URISED"
      | "MANUAL_UA"
      | "MANUAL_CRP"
      | "ACADIA_DX"
      | "URISYS_DX"
      | "THEIA"
      | "TENSEI",
    options?: any
  ) {
    return QualityControlApiFp(this.configuration).fetchQualityControlLots(
      instrumentId,
      instrumentType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save the provided trend.
   * @param {number} qualityControlRunId The Quality Control Run ID.
   * @param {QualityControlTrendDto} [body] The trend to be saved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QualityControlApi
   */
  public updateQualityControlTrendingReason(
    qualityControlRunId: number,
    body?: QualityControlTrendDto,
    options?: any
  ) {
    return QualityControlApiFp(
      this.configuration
    ).updateQualityControlTrendingReason(
      qualityControlRunId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ReferenceLabMonitorApi - fetch parameter creator
 * @export
 */
export const ReferenceLabMonitorApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch ref lab monitor status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsRunning(options: any = {}): FetchArgs {
      const localVarPath = `/referenceLab/monitor/running`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Start ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startRefLabMonitor(options: any = {}): FetchArgs {
      const localVarPath = `/referenceLab/monitor/start`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Stop ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopRefLabMonitor(options: any = {}): FetchArgs {
      const localVarPath = `/referenceLab/monitor/stop`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReferenceLabMonitorApi - functional programming interface
 * @export
 */
export const ReferenceLabMonitorApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch ref lab monitor status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsRunning(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        ReferenceLabMonitorApiFetchParamCreator(configuration).fetchIsRunning(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Start ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startRefLabMonitor(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        ReferenceLabMonitorApiFetchParamCreator(
          configuration
        ).startRefLabMonitor(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Stop ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopRefLabMonitor(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        ReferenceLabMonitorApiFetchParamCreator(
          configuration
        ).stopRefLabMonitor(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ReferenceLabMonitorApi - factory interface
 * @export
 */
export const ReferenceLabMonitorApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch ref lab monitor status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsRunning(options?: any) {
      return ReferenceLabMonitorApiFp(configuration).fetchIsRunning(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Start ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startRefLabMonitor(options?: any) {
      return ReferenceLabMonitorApiFp(configuration).startRefLabMonitor(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Stop ref lab monitor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopRefLabMonitor(options?: any) {
      return ReferenceLabMonitorApiFp(configuration).stopRefLabMonitor(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * ReferenceLabMonitorApi - object-oriented interface
 * @export
 * @class ReferenceLabMonitorApi
 * @extends {BaseAPI}
 */
export class ReferenceLabMonitorApi extends BaseAPI {
  /**
   *
   * @summary Fetch ref lab monitor status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabMonitorApi
   */
  public fetchIsRunning(options?: any) {
    return ReferenceLabMonitorApiFp(this.configuration).fetchIsRunning(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Start ref lab monitor.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabMonitorApi
   */
  public startRefLabMonitor(options?: any) {
    return ReferenceLabMonitorApiFp(this.configuration).startRefLabMonitor(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Stop ref lab monitor.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabMonitorApi
   */
  public stopRefLabMonitor(options?: any) {
    return ReferenceLabMonitorApiFp(this.configuration).stopRefLabMonitor(
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ReferenceLabResultsApi - fetch parameter creator
 * @export
 */
export const ReferenceLabResultsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary For a specific VC+ result ID, get the delayed notification PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDelayedNotification(
      vcpResultId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'vcpResultId' is not null or undefined
      if (vcpResultId === null || vcpResultId === undefined) {
        throw new RequiredError(
          "vcpResultId",
          "Required parameter vcpResultId was null or undefined when calling fetchDelayedNotification."
        );
      }
      const localVarPath =
        `/referenceLab/result/{vcpResultId}/delayedNotification`.replace(
          `{${"vcpResultId"}}`,
          encodeURIComponent(String(vcpResultId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if this IVLS is configured for retrieval of Reference Lab results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsConfigured(options: any = {}): FetchArgs {
      const localVarPath = `/referenceLab/isConfigured`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list summaries of recently received reference lab results
     * @param {"INPROCESS" | "COMPLETE" | "CANCELLED"} [orderStatus] The desired status of the orders to be fetched
     * @param {number} [days] The desired days worth of recent results relative to the current date to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResults(
      orderStatus?: "INPROCESS" | "COMPLETE" | "CANCELLED",
      days?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/referenceLab/result/recent`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (orderStatus !== undefined) {
        localVarQueryParameter["orderStatus"] = orderStatus;
      }

      if (days !== undefined) {
        localVarQueryParameter["days"] = days;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary For a specific VC+ result ID, get the result PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResultsPdf(vcpResultId: string, options: any = {}): FetchArgs {
      // verify required parameter 'vcpResultId' is not null or undefined
      if (vcpResultId === null || vcpResultId === undefined) {
        throw new RequiredError(
          "vcpResultId",
          "Required parameter vcpResultId was null or undefined when calling fetchRefLabResultsPdf."
        );
      }
      const localVarPath = `/referenceLab/result/{vcpResultId}/pdf`.replace(
        `{${"vcpResultId"}}`,
        encodeURIComponent(String(vcpResultId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReferenceLabResultsApi - functional programming interface
 * @export
 */
export const ReferenceLabResultsApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary For a specific VC+ result ID, get the delayed notification PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDelayedNotification(
      vcpResultId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReferenceLabResultsApiFetchParamCreator(
        configuration
      ).fetchDelayedNotification(vcpResultId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Check if this IVLS is configured for retrieval of Reference Lab results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsConfigured(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        ReferenceLabResultsApiFetchParamCreator(
          configuration
        ).fetchIsConfigured(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get a list summaries of recently received reference lab results
     * @param {"INPROCESS" | "COMPLETE" | "CANCELLED"} [orderStatus] The desired status of the orders to be fetched
     * @param {number} [days] The desired days worth of recent results relative to the current date to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResults(
      orderStatus?: "INPROCESS" | "COMPLETE" | "CANCELLED",
      days?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RefLabResultDto>> {
      const localVarFetchArgs = ReferenceLabResultsApiFetchParamCreator(
        configuration
      ).fetchRefLabResults(orderStatus, days, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary For a specific VC+ result ID, get the result PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResultsPdf(
      vcpResultId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReferenceLabResultsApiFetchParamCreator(
        configuration
      ).fetchRefLabResultsPdf(vcpResultId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ReferenceLabResultsApi - factory interface
 * @export
 */
export const ReferenceLabResultsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary For a specific VC+ result ID, get the delayed notification PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDelayedNotification(vcpResultId: string, options?: any) {
      return ReferenceLabResultsApiFp(configuration).fetchDelayedNotification(
        vcpResultId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Check if this IVLS is configured for retrieval of Reference Lab results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsConfigured(options?: any) {
      return ReferenceLabResultsApiFp(configuration).fetchIsConfigured(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get a list summaries of recently received reference lab results
     * @param {"INPROCESS" | "COMPLETE" | "CANCELLED"} [orderStatus] The desired status of the orders to be fetched
     * @param {number} [days] The desired days worth of recent results relative to the current date to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResults(
      orderStatus?: "INPROCESS" | "COMPLETE" | "CANCELLED",
      days?: number,
      options?: any
    ) {
      return ReferenceLabResultsApiFp(configuration).fetchRefLabResults(
        orderStatus,
        days,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary For a specific VC+ result ID, get the result PDF
     * @param {string} vcpResultId The unique result ID assigned by VC+
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRefLabResultsPdf(vcpResultId: string, options?: any) {
      return ReferenceLabResultsApiFp(configuration).fetchRefLabResultsPdf(
        vcpResultId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ReferenceLabResultsApi - object-oriented interface
 * @export
 * @class ReferenceLabResultsApi
 * @extends {BaseAPI}
 */
export class ReferenceLabResultsApi extends BaseAPI {
  /**
   *
   * @summary For a specific VC+ result ID, get the delayed notification PDF
   * @param {string} vcpResultId The unique result ID assigned by VC+
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabResultsApi
   */
  public fetchDelayedNotification(vcpResultId: string, options?: any) {
    return ReferenceLabResultsApiFp(
      this.configuration
    ).fetchDelayedNotification(vcpResultId, options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Check if this IVLS is configured for retrieval of Reference Lab results
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabResultsApi
   */
  public fetchIsConfigured(options?: any) {
    return ReferenceLabResultsApiFp(this.configuration).fetchIsConfigured(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get a list summaries of recently received reference lab results
   * @param {"INPROCESS" | "COMPLETE" | "CANCELLED"} [orderStatus] The desired status of the orders to be fetched
   * @param {number} [days] The desired days worth of recent results relative to the current date to be fetched
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabResultsApi
   */
  public fetchRefLabResults(
    orderStatus?: "INPROCESS" | "COMPLETE" | "CANCELLED",
    days?: number,
    options?: any
  ) {
    return ReferenceLabResultsApiFp(this.configuration).fetchRefLabResults(
      orderStatus,
      days,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary For a specific VC+ result ID, get the result PDF
   * @param {string} vcpResultId The unique result ID assigned by VC+
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReferenceLabResultsApi
   */
  public fetchRefLabResultsPdf(vcpResultId: string, options?: any) {
    return ReferenceLabResultsApiFp(this.configuration).fetchRefLabResultsPdf(
      vcpResultId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ReportApi - fetch parameter creator
 * @export
 */
export const ReportApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create acadia quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAcadiaQualityControlReport(options: any = {}): FetchArgs {
      const localVarPath = `/report/acadiaQualityReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Catalyst One smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatOneSmartQCReport(options: any = {}): FetchArgs {
      const localVarPath = `/report/catOneSmartQCReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create Catalyst Dx smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatalystDxSmartQCReport(options: any = {}): FetchArgs {
      const localVarPath = `/report/catalystDxSmartQCReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create crimson quality control trending report.
     * @param {number} [instrumentId] The instrument id.
     * @param {number} [qualityControlId] The quality control id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrimsonQualityControlTrendingReport(
      instrumentId?: number,
      qualityControlId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/crimsonQualityReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentId !== undefined) {
        localVarQueryParameter["instrumentId"] = instrumentId;
      }

      if (qualityControlId !== undefined) {
        localVarQueryParameter["qualityControlId"] = qualityControlId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create new lab report.
     * @param {number} [labRequestId] The lab request id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReport(labRequestId?: number, options: any = {}): FetchArgs {
      const localVarPath = `/report/labReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (labRequestId !== undefined) {
        localVarQueryParameter["labRequestId"] = labRequestId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is used for the preview/print of the cropped image report, through the SediVue HPF image view screen.
     * @summary Create new lab report with image data.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReportWithImageData(
      labRequestId?: number,
      imageData?: any,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/labReportWithImageData`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (labRequestId !== undefined) {
        localVarQueryParameter["labRequestId"] = labRequestId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"any" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(imageData || {})
        : imageData || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create results trending report.
     * @param {ResultsTrendingDto} [reportData] Data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResultsTrendingReport(
      reportData?: ResultsTrendingDto,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/resultsTrendingReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ResultsTrendingDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(reportData || {})
        : reportData || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create snap log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapLogReport(
      startDate?: string,
      endDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/snapLogReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create snap summary log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapSummaryLogReport(
      startDate?: string,
      endDate?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/snapSummaryReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create urised quality control trending report.
     * @param {string} [instrumentSerialNumber] The instrument serial number.
     * @param {"LEVEL1" | "LEVEL2"} [fluidType] The fluid type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrisedQualityControlTrendingReport(
      instrumentSerialNumber?: string,
      fluidType?: "LEVEL1" | "LEVEL2",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/urisedQualityReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentSerialNumber !== undefined) {
        localVarQueryParameter["instrumentSerialNumber"] =
          instrumentSerialNumber;
      }

      if (fluidType !== undefined) {
        localVarQueryParameter["fluidType"] = fluidType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used for sending a cropped image to PIMS.  Available through the SediVue HPF image view screen.
     * @summary Send report with image to pims.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReportWithImageToPims(
      labRequestId?: number,
      imageData?: any,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report/sendReportWithImageToPims`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (labRequestId !== undefined) {
        localVarQueryParameter["labRequestId"] = labRequestId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"any" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(imageData || {})
        : imageData || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create acadia quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAcadiaQualityControlReport(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        ReportApiFetchParamCreator(
          configuration
        ).createAcadiaQualityControlReport(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create Catalyst One smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatOneSmartQCReport(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        ReportApiFetchParamCreator(configuration).createCatOneSmartQCReport(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create Catalyst Dx smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatalystDxSmartQCReport(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        ReportApiFetchParamCreator(configuration).createCatalystDxSmartQCReport(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create crimson quality control trending report.
     * @param {number} [instrumentId] The instrument id.
     * @param {number} [qualityControlId] The quality control id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrimsonQualityControlTrendingReport(
      instrumentId?: number,
      qualityControlId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getCrimsonQualityControlTrendingReport(
        instrumentId,
        qualityControlId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create new lab report.
     * @param {number} [labRequestId] The lab request id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReport(
      labRequestId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getLabReport(labRequestId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This is used for the preview/print of the cropped image report, through the SediVue HPF image view screen.
     * @summary Create new lab report with image data.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReportWithImageData(
      labRequestId?: number,
      imageData?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getLabReportWithImageData(labRequestId, imageData, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create results trending report.
     * @param {ResultsTrendingDto} [reportData] Data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResultsTrendingReport(
      reportData?: ResultsTrendingDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getResultsTrendingReport(reportData, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create snap log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapLogReport(
      startDate?: string,
      endDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getSnapLogReport(startDate, endDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create snap summary log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapSummaryLogReport(
      startDate?: string,
      endDate?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getSnapSummaryLogReport(startDate, endDate, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Create urised quality control trending report.
     * @param {string} [instrumentSerialNumber] The instrument serial number.
     * @param {"LEVEL1" | "LEVEL2"} [fluidType] The fluid type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrisedQualityControlTrendingReport(
      instrumentSerialNumber?: string,
      fluidType?: "LEVEL1" | "LEVEL2",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getUrisedQualityControlTrendingReport(
        instrumentSerialNumber,
        fluidType,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Used for sending a cropped image to PIMS.  Available through the SediVue HPF image view screen.
     * @summary Send report with image to pims.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReportWithImageToPims(
      labRequestId?: number,
      imageData?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).sendReportWithImageToPims(labRequestId, imageData, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Create acadia quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAcadiaQualityControlReport(options?: any) {
      return ReportApiFp(configuration).createAcadiaQualityControlReport(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create Catalyst One smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatOneSmartQCReport(options?: any) {
      return ReportApiFp(configuration).createCatOneSmartQCReport(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Create Catalyst Dx smart quality control report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCatalystDxSmartQCReport(options?: any) {
      return ReportApiFp(configuration).createCatalystDxSmartQCReport(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Create crimson quality control trending report.
     * @param {number} [instrumentId] The instrument id.
     * @param {number} [qualityControlId] The quality control id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCrimsonQualityControlTrendingReport(
      instrumentId?: number,
      qualityControlId?: number,
      options?: any
    ) {
      return ReportApiFp(configuration).getCrimsonQualityControlTrendingReport(
        instrumentId,
        qualityControlId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create new lab report.
     * @param {number} [labRequestId] The lab request id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReport(labRequestId?: number, options?: any) {
      return ReportApiFp(configuration).getLabReport(labRequestId, options)(
        fetch,
        basePath
      );
    },
    /**
     * This is used for the preview/print of the cropped image report, through the SediVue HPF image view screen.
     * @summary Create new lab report with image data.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabReportWithImageData(
      labRequestId?: number,
      imageData?: any,
      options?: any
    ) {
      return ReportApiFp(configuration).getLabReportWithImageData(
        labRequestId,
        imageData,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create results trending report.
     * @param {ResultsTrendingDto} [reportData] Data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResultsTrendingReport(reportData?: ResultsTrendingDto, options?: any) {
      return ReportApiFp(configuration).getResultsTrendingReport(
        reportData,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create snap log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapLogReport(startDate?: string, endDate?: string, options?: any) {
      return ReportApiFp(configuration).getSnapLogReport(
        startDate,
        endDate,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create snap summary log report.
     * @param {string} [startDate] The start date.   yyyy-MM-dd
     * @param {string} [endDate] The end date.   yyyy-MM-dd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapSummaryLogReport(
      startDate?: string,
      endDate?: string,
      options?: any
    ) {
      return ReportApiFp(configuration).getSnapSummaryLogReport(
        startDate,
        endDate,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Create urised quality control trending report.
     * @param {string} [instrumentSerialNumber] The instrument serial number.
     * @param {"LEVEL1" | "LEVEL2"} [fluidType] The fluid type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUrisedQualityControlTrendingReport(
      instrumentSerialNumber?: string,
      fluidType?: "LEVEL1" | "LEVEL2",
      options?: any
    ) {
      return ReportApiFp(configuration).getUrisedQualityControlTrendingReport(
        instrumentSerialNumber,
        fluidType,
        options
      )(fetch, basePath);
    },
    /**
     * Used for sending a cropped image to PIMS.  Available through the SediVue HPF image view screen.
     * @summary Send report with image to pims.
     * @param {number} [labRequestId] The lab request id.
     * @param {any} [imageData] Image data for report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReportWithImageToPims(
      labRequestId?: number,
      imageData?: any,
      options?: any
    ) {
      return ReportApiFp(configuration).sendReportWithImageToPims(
        labRequestId,
        imageData,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
  /**
   *
   * @summary Create acadia quality control report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public createAcadiaQualityControlReport(options?: any) {
    return ReportApiFp(this.configuration).createAcadiaQualityControlReport(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create Catalyst One smart quality control report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public createCatOneSmartQCReport(options?: any) {
    return ReportApiFp(this.configuration).createCatOneSmartQCReport(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Create Catalyst Dx smart quality control report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public createCatalystDxSmartQCReport(options?: any) {
    return ReportApiFp(this.configuration).createCatalystDxSmartQCReport(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create crimson quality control trending report.
   * @param {number} [instrumentId] The instrument id.
   * @param {number} [qualityControlId] The quality control id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getCrimsonQualityControlTrendingReport(
    instrumentId?: number,
    qualityControlId?: number,
    options?: any
  ) {
    return ReportApiFp(
      this.configuration
    ).getCrimsonQualityControlTrendingReport(
      instrumentId,
      qualityControlId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create new lab report.
   * @param {number} [labRequestId] The lab request id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getLabReport(labRequestId?: number, options?: any) {
    return ReportApiFp(this.configuration).getLabReport(labRequestId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * This is used for the preview/print of the cropped image report, through the SediVue HPF image view screen.
   * @summary Create new lab report with image data.
   * @param {number} [labRequestId] The lab request id.
   * @param {any} [imageData] Image data for report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getLabReportWithImageData(
    labRequestId?: number,
    imageData?: any,
    options?: any
  ) {
    return ReportApiFp(this.configuration).getLabReportWithImageData(
      labRequestId,
      imageData,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create results trending report.
   * @param {ResultsTrendingDto} [reportData] Data for report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getResultsTrendingReport(
    reportData?: ResultsTrendingDto,
    options?: any
  ) {
    return ReportApiFp(this.configuration).getResultsTrendingReport(
      reportData,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create snap log report.
   * @param {string} [startDate] The start date.   yyyy-MM-dd
   * @param {string} [endDate] The end date.   yyyy-MM-dd
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getSnapLogReport(startDate?: string, endDate?: string, options?: any) {
    return ReportApiFp(this.configuration).getSnapLogReport(
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create snap summary log report.
   * @param {string} [startDate] The start date.   yyyy-MM-dd
   * @param {string} [endDate] The end date.   yyyy-MM-dd
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getSnapSummaryLogReport(
    startDate?: string,
    endDate?: string,
    options?: any
  ) {
    return ReportApiFp(this.configuration).getSnapSummaryLogReport(
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Create urised quality control trending report.
   * @param {string} [instrumentSerialNumber] The instrument serial number.
   * @param {"LEVEL1" | "LEVEL2"} [fluidType] The fluid type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getUrisedQualityControlTrendingReport(
    instrumentSerialNumber?: string,
    fluidType?: "LEVEL1" | "LEVEL2",
    options?: any
  ) {
    return ReportApiFp(
      this.configuration
    ).getUrisedQualityControlTrendingReport(
      instrumentSerialNumber,
      fluidType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Used for sending a cropped image to PIMS.  Available through the SediVue HPF image view screen.
   * @summary Send report with image to pims.
   * @param {number} [labRequestId] The lab request id.
   * @param {any} [imageData] Image data for report.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public sendReportWithImageToPims(
    labRequestId?: number,
    imageData?: any,
    options?: any
  ) {
    return ReportApiFp(this.configuration).sendReportWithImageToPims(
      labRequestId,
      imageData,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * RestoreApi - fetch parameter creator
 * @export
 */
export const RestoreApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Copy USB restore files to temp folder.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbRestoreFiles(dto?: RestoreFileDto, options: any = {}): FetchArgs {
      const localVarPath = `/restore/copyUsbRestoreFiles`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RestoreFileDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(dto || {})
        : dto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get file system backup restore file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFileSystemBackup(options: any = {}): FetchArgs {
      const localVarPath = `/restore/hasFileSystemBackup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get available restore files.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRestoreFiles(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'source' is not null or undefined
      if (source === null || source === undefined) {
        throw new RequiredError(
          "source",
          "Required parameter source was null or undefined when calling getRestoreFiles."
        );
      }
      // verify required parameter 'mode' is not null or undefined
      if (mode === null || mode === undefined) {
        throw new RequiredError(
          "mode",
          "Required parameter mode was null or undefined when calling getRestoreFiles."
        );
      }
      const localVarPath = `/restore/restoreFiles/{source}/{mode}`
        .replace(`{${"source"}}`, encodeURIComponent(String(source)))
        .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get available restore files on USB by restore mode.
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbRestoreFiles(usbId: string, options: any = {}): FetchArgs {
      // verify required parameter 'usbId' is not null or undefined
      if (usbId === null || usbId === undefined) {
        throw new RequiredError(
          "usbId",
          "Required parameter usbId was null or undefined when calling getUsbRestoreFiles."
        );
      }
      const localVarPath = `/restore/usbRestoreFiles`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform restore.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performRestore(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      dto?: RestoreFileDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'source' is not null or undefined
      if (source === null || source === undefined) {
        throw new RequiredError(
          "source",
          "Required parameter source was null or undefined when calling performRestore."
        );
      }
      // verify required parameter 'mode' is not null or undefined
      if (mode === null || mode === undefined) {
        throw new RequiredError(
          "mode",
          "Required parameter mode was null or undefined when calling performRestore."
        );
      }
      const localVarPath = `/restore/performRestore/{source}/{mode}`
        .replace(`{${"source"}}`, encodeURIComponent(String(source)))
        .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RestoreFileDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(dto || {})
        : dto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Responds to a remote restore request
     * @param {string} backupId The Restore request backup ID
     * @param {boolean} [accepted] TRUE for user accepted, FALSE for user declined
     * @param {string} [reason] Optional param for accepted &#x3D; false, indicating reason for rejection
     * @param {string} [restoreEventId] Required query param to correlate SS mission request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToRemoteRestore(
      backupId: string,
      accepted?: boolean,
      reason?: string,
      restoreEventId?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'backupId' is not null or undefined
      if (backupId === null || backupId === undefined) {
        throw new RequiredError(
          "backupId",
          "Required parameter backupId was null or undefined when calling respondToRemoteRestore."
        );
      }
      const localVarPath = `/restore/remoteRestore/response/{backupId}`.replace(
        `{${"backupId"}}`,
        encodeURIComponent(String(backupId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (accepted !== undefined) {
        localVarQueryParameter["accepted"] = accepted;
      }

      if (reason !== undefined) {
        localVarQueryParameter["reason"] = reason;
      }

      if (restoreEventId !== undefined) {
        localVarQueryParameter["restoreEventId"] = restoreEventId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validates a restore package
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRestore(dto?: RestoreFileDto, options: any = {}): FetchArgs {
      const localVarPath = `/restore/validate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"RestoreFileDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(dto || {})
        : dto || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RestoreApi - functional programming interface
 * @export
 */
export const RestoreApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Copy USB restore files to temp folder.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbRestoreFiles(
      dto?: RestoreFileDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).copyUsbRestoreFiles(dto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get file system backup restore file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFileSystemBackup(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RestoreFileDto> {
      const localVarFetchArgs =
        RestoreApiFetchParamCreator(configuration).fetchFileSystemBackup(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get available restore files.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRestoreFiles(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RestoreFileDto>> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).getRestoreFiles(source, mode, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get available restore files on USB by restore mode.
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbRestoreFiles(
      usbId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RestoreFileDto>> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).getUsbRestoreFiles(usbId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform restore.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performRestore(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      dto?: RestoreFileDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).performRestore(source, mode, dto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Responds to a remote restore request
     * @param {string} backupId The Restore request backup ID
     * @param {boolean} [accepted] TRUE for user accepted, FALSE for user declined
     * @param {string} [reason] Optional param for accepted &#x3D; false, indicating reason for rejection
     * @param {string} [restoreEventId] Required query param to correlate SS mission request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToRemoteRestore(
      backupId: string,
      accepted?: boolean,
      reason?: string,
      restoreEventId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).respondToRemoteRestore(
        backupId,
        accepted,
        reason,
        restoreEventId,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validates a restore package
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRestore(
      dto?: RestoreFileDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = RestoreApiFetchParamCreator(
        configuration
      ).validateRestore(dto, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RestoreApi - factory interface
 * @export
 */
export const RestoreApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Copy USB restore files to temp folder.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbRestoreFiles(dto?: RestoreFileDto, options?: any) {
      return RestoreApiFp(configuration).copyUsbRestoreFiles(dto, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get file system backup restore file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFileSystemBackup(options?: any) {
      return RestoreApiFp(configuration).fetchFileSystemBackup(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get available restore files.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRestoreFiles(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      options?: any
    ) {
      return RestoreApiFp(configuration).getRestoreFiles(
        source,
        mode,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get available restore files on USB by restore mode.
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbRestoreFiles(usbId: string, options?: any) {
      return RestoreApiFp(configuration).getUsbRestoreFiles(usbId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Perform restore.
     * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
     * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performRestore(
      source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
      mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
      dto?: RestoreFileDto,
      options?: any
    ) {
      return RestoreApiFp(configuration).performRestore(
        source,
        mode,
        dto,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Responds to a remote restore request
     * @param {string} backupId The Restore request backup ID
     * @param {boolean} [accepted] TRUE for user accepted, FALSE for user declined
     * @param {string} [reason] Optional param for accepted &#x3D; false, indicating reason for rejection
     * @param {string} [restoreEventId] Required query param to correlate SS mission request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondToRemoteRestore(
      backupId: string,
      accepted?: boolean,
      reason?: string,
      restoreEventId?: string,
      options?: any
    ) {
      return RestoreApiFp(configuration).respondToRemoteRestore(
        backupId,
        accepted,
        reason,
        restoreEventId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Validates a restore package
     * @param {RestoreFileDto} [dto] The restore file information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateRestore(dto?: RestoreFileDto, options?: any) {
      return RestoreApiFp(configuration).validateRestore(dto, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * RestoreApi - object-oriented interface
 * @export
 * @class RestoreApi
 * @extends {BaseAPI}
 */
export class RestoreApi extends BaseAPI {
  /**
   *
   * @summary Copy USB restore files to temp folder.
   * @param {RestoreFileDto} [dto] The restore file information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public copyUsbRestoreFiles(dto?: RestoreFileDto, options?: any) {
    return RestoreApiFp(this.configuration).copyUsbRestoreFiles(dto, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get file system backup restore file.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public fetchFileSystemBackup(options?: any) {
    return RestoreApiFp(this.configuration).fetchFileSystemBackup(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get available restore files.
   * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
   * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public getRestoreFiles(
    source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
    mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
    options?: any
  ) {
    return RestoreApiFp(this.configuration).getRestoreFiles(
      source,
      mode,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get available restore files on USB by restore mode.
   * @param {string} usbId The USB ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public getUsbRestoreFiles(usbId: string, options?: any) {
    return RestoreApiFp(this.configuration).getUsbRestoreFiles(usbId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Perform restore.
   * @param {"CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE"} source The restore source.
   * @param {"ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS"} mode The restore mode.
   * @param {RestoreFileDto} [dto] The restore file information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public performRestore(
    source: "CD" | "FILESYSTEM" | "USB" | "SMARTSERVICE",
    mode: "ALL" | "PATIENT" | "CALIBRATION" | "SETTINGS",
    dto?: RestoreFileDto,
    options?: any
  ) {
    return RestoreApiFp(this.configuration).performRestore(
      source,
      mode,
      dto,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Responds to a remote restore request
   * @param {string} backupId The Restore request backup ID
   * @param {boolean} [accepted] TRUE for user accepted, FALSE for user declined
   * @param {string} [reason] Optional param for accepted &#x3D; false, indicating reason for rejection
   * @param {string} [restoreEventId] Required query param to correlate SS mission request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public respondToRemoteRestore(
    backupId: string,
    accepted?: boolean,
    reason?: string,
    restoreEventId?: string,
    options?: any
  ) {
    return RestoreApiFp(this.configuration).respondToRemoteRestore(
      backupId,
      accepted,
      reason,
      restoreEventId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Validates a restore package
   * @param {RestoreFileDto} [dto] The restore file information.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RestoreApi
   */
  public validateRestore(dto?: RestoreFileDto, options?: any) {
    return RestoreApiFp(this.configuration).validateRestore(dto, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ResultApi - fetch parameter creator
 * @export
 */
export const ResultApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get recent results.
     * @param {number} days Since number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentResults(days: number, options: any = {}): FetchArgs {
      // verify required parameter 'days' is not null or undefined
      if (days === null || days === undefined) {
        throw new RequiredError(
          "days",
          "Required parameter days was null or undefined when calling getRecentResults."
        );
      }
      const localVarPath = `/result/recent`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (days !== undefined) {
        localVarQueryParameter["days"] = days;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get recent results by row number.
     * @param {number} [startingRowNum] The row number to start searching for results.
     * @param {number} [numResults] Maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resultsByRow(
      startingRowNum?: number,
      numResults?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/result/recent/row`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (startingRowNum !== undefined) {
        localVarQueryParameter["startingRowNum"] = startingRowNum;
      }

      if (numResults !== undefined) {
        localVarQueryParameter["numResults"] = numResults;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a results assay type.
     * @param {number} instrumentRunId The Id of the instrument run being updated
     * @param {number} instrumentResultId The Id of the instrument result being updated
     * @param {number} body The Id of the updated assay type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResultAssayType(
      instrumentRunId: number,
      instrumentResultId: number,
      body: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling updateResultAssayType."
        );
      }
      // verify required parameter 'instrumentResultId' is not null or undefined
      if (instrumentResultId === null || instrumentResultId === undefined) {
        throw new RequiredError(
          "instrumentResultId",
          "Required parameter instrumentResultId was null or undefined when calling updateResultAssayType."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateResultAssayType."
        );
      }
      const localVarPath =
        `/result/instrumentRun/{instrumentRunId}/instrumentResult/{instrumentResultId}/updateResultAssayType`
          .replace(
            `{${"instrumentRunId"}}`,
            encodeURIComponent(String(instrumentRunId))
          )
          .replace(
            `{${"instrumentResultId"}}`,
            encodeURIComponent(String(instrumentResultId))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"number" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ResultApi - functional programming interface
 * @export
 */
export const ResultApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get recent results.
     * @param {number} days Since number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentResults(
      days: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RecentResultDto>> {
      const localVarFetchArgs = ResultApiFetchParamCreator(
        configuration
      ).getRecentResults(days, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get recent results by row number.
     * @param {number} [startingRowNum] The row number to start searching for results.
     * @param {number} [numResults] Maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resultsByRow(
      startingRowNum?: number,
      numResults?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RecentResultDto>> {
      const localVarFetchArgs = ResultApiFetchParamCreator(
        configuration
      ).resultsByRow(startingRowNum, numResults, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update a results assay type.
     * @param {number} instrumentRunId The Id of the instrument run being updated
     * @param {number} instrumentResultId The Id of the instrument result being updated
     * @param {number} body The Id of the updated assay type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResultAssayType(
      instrumentRunId: number,
      instrumentResultId: number,
      body: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ResultApiFetchParamCreator(
        configuration
      ).updateResultAssayType(
        instrumentRunId,
        instrumentResultId,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ResultApi - factory interface
 * @export
 */
export const ResultApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get recent results.
     * @param {number} days Since number of days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentResults(days: number, options?: any) {
      return ResultApiFp(configuration).getRecentResults(days, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get recent results by row number.
     * @param {number} [startingRowNum] The row number to start searching for results.
     * @param {number} [numResults] Maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resultsByRow(startingRowNum?: number, numResults?: number, options?: any) {
      return ResultApiFp(configuration).resultsByRow(
        startingRowNum,
        numResults,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update a results assay type.
     * @param {number} instrumentRunId The Id of the instrument run being updated
     * @param {number} instrumentResultId The Id of the instrument result being updated
     * @param {number} body The Id of the updated assay type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResultAssayType(
      instrumentRunId: number,
      instrumentResultId: number,
      body: number,
      options?: any
    ) {
      return ResultApiFp(configuration).updateResultAssayType(
        instrumentRunId,
        instrumentResultId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ResultApi - object-oriented interface
 * @export
 * @class ResultApi
 * @extends {BaseAPI}
 */
export class ResultApi extends BaseAPI {
  /**
   *
   * @summary Get recent results.
   * @param {number} days Since number of days.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResultApi
   */
  public getRecentResults(days: number, options?: any) {
    return ResultApiFp(this.configuration).getRecentResults(days, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get recent results by row number.
   * @param {number} [startingRowNum] The row number to start searching for results.
   * @param {number} [numResults] Maximum number of results to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResultApi
   */
  public resultsByRow(
    startingRowNum?: number,
    numResults?: number,
    options?: any
  ) {
    return ResultApiFp(this.configuration).resultsByRow(
      startingRowNum,
      numResults,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update a results assay type.
   * @param {number} instrumentRunId The Id of the instrument run being updated
   * @param {number} instrumentResultId The Id of the instrument result being updated
   * @param {number} body The Id of the updated assay type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResultApi
   */
  public updateResultAssayType(
    instrumentRunId: number,
    instrumentResultId: number,
    body: number,
    options?: any
  ) {
    return ResultApiFp(this.configuration).updateResultAssayType(
      instrumentRunId,
      instrumentResultId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * RouterApi - fetch parameter creator
 * @export
 */
export const RouterApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get a snapshot of the Router
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRouter(options: any = {}): FetchArgs {
      const localVarPath = `/router`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the update status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(options: any = {}): FetchArgs {
      const localVarPath = `/router/upgrade/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Initialize client listener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeRouterListener(options: any = {}): FetchArgs {
      const localVarPath = `/router/upgrade/initializeListener`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform a save or restore action on the router configuration.
     * @param {"SAVE" | "RESTORE"} [action]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performConfigAction(
      action?: "SAVE" | "RESTORE",
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/router/configuration`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (action !== undefined) {
        localVarQueryParameter["action"] = action;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the routers wired configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWiredConfiguration(reboot?: boolean, options: any = {}): FetchArgs {
      const localVarPath = `/router/configuration/wired`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (reboot !== undefined) {
        localVarQueryParameter["reboot"] = reboot;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the routers wireless configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWirelessConfiguration(
      reboot?: boolean,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/router/configuration/wireless`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (reboot !== undefined) {
        localVarQueryParameter["reboot"] = reboot;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform a router upgrade.
     * @param {"LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME"} action The upgrade router action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgrade(
      action: "LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'action' is not null or undefined
      if (action === null || action === undefined) {
        throw new RequiredError(
          "action",
          "Required parameter action was null or undefined when calling upgrade."
        );
      }
      const localVarPath = `/router/upgrade/upgrade/{action}`.replace(
        `{${"action"}}`,
        encodeURIComponent(String(action))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RouterApi - functional programming interface
 * @export
 */
export const RouterApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a snapshot of the Router
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRouter(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IvlsRouterDto> {
      const localVarFetchArgs =
        RouterApiFetchParamCreator(configuration).fetchRouter(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the update status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<UpgradeRouterStatusDto> {
      const localVarFetchArgs =
        RouterApiFetchParamCreator(configuration).fetchStatus(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Initialize client listener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeRouterListener(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        RouterApiFetchParamCreator(configuration).initializeRouterListener(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform a save or restore action on the router configuration.
     * @param {"SAVE" | "RESTORE"} [action]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performConfigAction(
      action?: "SAVE" | "RESTORE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = RouterApiFetchParamCreator(
        configuration
      ).performConfigAction(action, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the routers wired configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWiredConfiguration(
      reboot?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RouterApiFetchParamCreator(
        configuration
      ).updateWiredConfiguration(reboot, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the routers wireless configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWirelessConfiguration(
      reboot?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RouterApiFetchParamCreator(
        configuration
      ).updateWirelessConfiguration(reboot, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform a router upgrade.
     * @param {"LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME"} action The upgrade router action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgrade(
      action: "LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = RouterApiFetchParamCreator(
        configuration
      ).upgrade(action, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RouterApi - factory interface
 * @export
 */
export const RouterApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get a snapshot of the Router
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRouter(options?: any) {
      return RouterApiFp(configuration).fetchRouter(options)(fetch, basePath);
    },
    /**
     *
     * @summary Get the update status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(options?: any) {
      return RouterApiFp(configuration).fetchStatus(options)(fetch, basePath);
    },
    /**
     *
     * @summary Initialize client listener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializeRouterListener(options?: any) {
      return RouterApiFp(configuration).initializeRouterListener(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Perform a save or restore action on the router configuration.
     * @param {"SAVE" | "RESTORE"} [action]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    performConfigAction(action?: "SAVE" | "RESTORE", options?: any) {
      return RouterApiFp(configuration).performConfigAction(action, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Update the routers wired configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWiredConfiguration(reboot?: boolean, options?: any) {
      return RouterApiFp(configuration).updateWiredConfiguration(
        reboot,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the routers wireless configuration
     * @param {boolean} [reboot]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWirelessConfiguration(reboot?: boolean, options?: any) {
      return RouterApiFp(configuration).updateWirelessConfiguration(
        reboot,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Perform a router upgrade.
     * @param {"LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME"} action The upgrade router action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgrade(
      action: "LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME",
      options?: any
    ) {
      return RouterApiFp(configuration).upgrade(action, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * RouterApi - object-oriented interface
 * @export
 * @class RouterApi
 * @extends {BaseAPI}
 */
export class RouterApi extends BaseAPI {
  /**
   *
   * @summary Get a snapshot of the Router
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public fetchRouter(options?: any) {
    return RouterApiFp(this.configuration).fetchRouter(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the update status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public fetchStatus(options?: any) {
    return RouterApiFp(this.configuration).fetchStatus(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Initialize client listener.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public initializeRouterListener(options?: any) {
    return RouterApiFp(this.configuration).initializeRouterListener(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Perform a save or restore action on the router configuration.
   * @param {"SAVE" | "RESTORE"} [action]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public performConfigAction(action?: "SAVE" | "RESTORE", options?: any) {
    return RouterApiFp(this.configuration).performConfigAction(action, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Update the routers wired configuration
   * @param {boolean} [reboot]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public updateWiredConfiguration(reboot?: boolean, options?: any) {
    return RouterApiFp(this.configuration).updateWiredConfiguration(
      reboot,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the routers wireless configuration
   * @param {boolean} [reboot]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public updateWirelessConfiguration(reboot?: boolean, options?: any) {
    return RouterApiFp(this.configuration).updateWirelessConfiguration(
      reboot,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Perform a router upgrade.
   * @param {"LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME"} action The upgrade router action.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RouterApi
   */
  public upgrade(
    action: "LATER" | "UPGRADE" | "UPGRADE_MANUAL" | "UPGRADE_AT_TIME",
    options?: any
  ) {
    return RouterApiFp(this.configuration).upgrade(action, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * SediVueApi - fetch parameter creator
 * @export
 */
export const SediVueApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Save the provided lots.
     * @param {QualityControlBarcodesDto} [body] The codes to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLotsForSediVue(
      body?: QualityControlBarcodesDto,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/sediVue/lots`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"QualityControlBarcodesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling executeMaintenanceProcedure."
        );
      }
      // verify required parameter 'instrumentMaintenanceProcedure' is not null or undefined
      if (
        instrumentMaintenanceProcedure === null ||
        instrumentMaintenanceProcedure === undefined
      ) {
        throw new RequiredError(
          "instrumentMaintenanceProcedure",
          "Required parameter instrumentMaintenanceProcedure was null or undefined when calling executeMaintenanceProcedure."
        );
      }
      const localVarPath = `/sediVue/{instrumentId}/procedure/execute`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentMaintenanceProcedure !== undefined) {
        localVarQueryParameter["instrumentMaintenanceProcedure"] =
          instrumentMaintenanceProcedure;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch cuvette status asynchronously. Will return result via push message.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAsync(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchCuvetteStatusAsync."
        );
      }
      const localVarPath = `/sediVue/{instrumentId}/cuvettes/async`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get images for urised run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForUrisedRun(
      instrumentRunId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getImagesForUrisedRun."
        );
      }
      const localVarPath =
        `/sediVue/instrumentRun/{instrumentRunId}/images`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set instrument run comment.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {string} [comment] The comment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInstrumentRunComment(
      instrumentRunId: number,
      comment?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling setInstrumentRunComment."
        );
      }
      const localVarPath =
        `/sediVue/instrumentRun/{instrumentRunId}/comment`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (comment !== undefined) {
        localVarQueryParameter["comment"] = comment;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user images selection status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {any} [userSelectedUUIDs] The mapping image uuid - selected flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserImageSelectionStatus(
      instrumentRunId: number,
      userSelectedUUIDs?: any,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling updateUserImageSelectionStatus."
        );
      }
      const localVarPath =
        `/sediVue/instrumentRun/{instrumentRunId}/userImageSelectionStatus`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"any" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(userSelectedUUIDs || {})
        : userSelectedUUIDs || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validate barcodes.
     * @param {QualityControlBarcodesDto} [body] The codes to be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSediVueQCBarcodes(
      body?: QualityControlBarcodesDto,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/sediVue/barcodes/validate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"QualityControlBarcodesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SediVueApi - functional programming interface
 * @export
 */
export const SediVueApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Save the provided lots.
     * @param {QualityControlBarcodesDto} [body] The codes to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLotsForSediVue(
      body?: QualityControlBarcodesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).createLotsForSediVue(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).executeMaintenanceProcedure(
        instrumentId,
        instrumentMaintenanceProcedure,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch cuvette status asynchronously. Will return result via push message.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAsync(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).fetchCuvetteStatusAsync(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get images for urised run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForUrisedRun(
      instrumentRunId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UriSedImageDto>> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).getImagesForUrisedRun(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set instrument run comment.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {string} [comment] The comment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInstrumentRunComment(
      instrumentRunId: number,
      comment?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).setInstrumentRunComment(instrumentRunId, comment, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update user images selection status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {any} [userSelectedUUIDs] The mapping image uuid - selected flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserImageSelectionStatus(
      instrumentRunId: number,
      userSelectedUUIDs?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UriSedImageDto>> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).updateUserImageSelectionStatus(
        instrumentRunId,
        userSelectedUUIDs,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validate barcodes.
     * @param {QualityControlBarcodesDto} [body] The codes to be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSediVueQCBarcodes(
      body?: QualityControlBarcodesDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<QualityControlBarcodeSetDto> {
      const localVarFetchArgs = SediVueApiFetchParamCreator(
        configuration
      ).validateSediVueQCBarcodes(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SediVueApi - factory interface
 * @export
 */
export const SediVueApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Save the provided lots.
     * @param {QualityControlBarcodesDto} [body] The codes to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLotsForSediVue(body?: QualityControlBarcodesDto, options?: any) {
      return SediVueApiFp(configuration).createLotsForSediVue(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options?: any
    ) {
      return SediVueApiFp(configuration).executeMaintenanceProcedure(
        instrumentId,
        instrumentMaintenanceProcedure,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch cuvette status asynchronously. Will return result via push message.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAsync(instrumentId: number, options?: any) {
      return SediVueApiFp(configuration).fetchCuvetteStatusAsync(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get images for urised run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForUrisedRun(instrumentRunId: number, options?: any) {
      return SediVueApiFp(configuration).getImagesForUrisedRun(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Set instrument run comment.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {string} [comment] The comment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setInstrumentRunComment(
      instrumentRunId: number,
      comment?: string,
      options?: any
    ) {
      return SediVueApiFp(configuration).setInstrumentRunComment(
        instrumentRunId,
        comment,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update user images selection status.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {any} [userSelectedUUIDs] The mapping image uuid - selected flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserImageSelectionStatus(
      instrumentRunId: number,
      userSelectedUUIDs?: any,
      options?: any
    ) {
      return SediVueApiFp(configuration).updateUserImageSelectionStatus(
        instrumentRunId,
        userSelectedUUIDs,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Validate barcodes.
     * @param {QualityControlBarcodesDto} [body] The codes to be validated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateSediVueQCBarcodes(body?: QualityControlBarcodesDto, options?: any) {
      return SediVueApiFp(configuration).validateSediVueQCBarcodes(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SediVueApi - object-oriented interface
 * @export
 * @class SediVueApi
 * @extends {BaseAPI}
 */
export class SediVueApi extends BaseAPI {
  /**
   *
   * @summary Save the provided lots.
   * @param {QualityControlBarcodesDto} [body] The codes to be saved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public createLotsForSediVue(body?: QualityControlBarcodesDto, options?: any) {
    return SediVueApiFp(this.configuration).createLotsForSediVue(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Execute instrument maintenance procedure.
   * @param {number} instrumentId The id of connected device.
   * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public executeMaintenanceProcedure(
    instrumentId: number,
    instrumentMaintenanceProcedure:
      | "GENERAL_CLEAN"
      | "OPTICS_CALIBRATION"
      | "DROP_CUVETTE"
      | "INITIALIZE"
      | "OFFSETS"
      | "SHUTDOWN"
      | "RESTART"
      | "FULL_SYSTEM_PRIME"
      | "FLOW_CELL_SOAK"
      | "DRAIN_MIX_CHAMBERS"
      | "SYSTEM_FLUSH"
      | "PRIME_REAGENT"
      | "PRIME_SHEATH"
      | "REPLACE_REAGENT"
      | "REPLACE_SHEATH"
      | "REPLACE_OBC"
      | "BLEACH_CLEAN"
      | "OPTIMIZE"
      | "DRAIN_RBC_ISOLATION_CHAMBER"
      | "DRAIN_REACTION_CHAMBER"
      | "DRAIN_WASTE_CHAMBER"
      | "AUTO_RINSE"
      | "MONTHLY_RINSE"
      | "FLOW_CELL_RINSE"
      | "WASTE_CHAMBER_RINSE"
      | "CLEAR_PINCH_VALVE"
      | "REMOVE_CLOG"
      | "RESET_AIR_PUMP"
      | "RESET_ASPIRATION_MOTOR"
      | "RESET_SHEATH_MOTOR"
      | "RESET_TUBE_MOTOR"
      | "RESET_WB_MOTOR"
      | "REPLENISH_REAGENT"
      | "REPLENISH_STAIN"
      | "MAINTENANCE_1"
      | "MAINTENANCE_2"
      | "MAINTENANCE_3"
      | "MAINTENANCE_4"
      | "MAINTENANCE_5"
      | "MAINTENANCE_6",
    options?: any
  ) {
    return SediVueApiFp(this.configuration).executeMaintenanceProcedure(
      instrumentId,
      instrumentMaintenanceProcedure,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch cuvette status asynchronously. Will return result via push message.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public fetchCuvetteStatusAsync(instrumentId: number, options?: any) {
    return SediVueApiFp(this.configuration).fetchCuvetteStatusAsync(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get images for urised run.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public getImagesForUrisedRun(instrumentRunId: number, options?: any) {
    return SediVueApiFp(this.configuration).getImagesForUrisedRun(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Set instrument run comment.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {string} [comment] The comment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public setInstrumentRunComment(
    instrumentRunId: number,
    comment?: string,
    options?: any
  ) {
    return SediVueApiFp(this.configuration).setInstrumentRunComment(
      instrumentRunId,
      comment,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update user images selection status.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {any} [userSelectedUUIDs] The mapping image uuid - selected flag.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public updateUserImageSelectionStatus(
    instrumentRunId: number,
    userSelectedUUIDs?: any,
    options?: any
  ) {
    return SediVueApiFp(this.configuration).updateUserImageSelectionStatus(
      instrumentRunId,
      userSelectedUUIDs,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Validate barcodes.
   * @param {QualityControlBarcodesDto} [body] The codes to be validated
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SediVueApi
   */
  public validateSediVueQCBarcodes(
    body?: QualityControlBarcodesDto,
    options?: any
  ) {
    return SediVueApiFp(this.configuration).validateSediVueQCBarcodes(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ServerResourceApi - fetch parameter creator
 * @export
 */
export const ServerResourceApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the content of a EULA.
     * @param {"ANTLR" | "AOPALLIANCE" | "APACHE" | "BOUNCY_CASTLE" | "CDDL" | "CPL" | "CPOL" | "CRIMSON" | "DOM4J" | "ECLIPSE" | "HAMCREST" | "JSOUP" | "LGPL" | "MOCKITO" | "MOZILLA" | "OBJENESIS" | "ORACLE_BCL" | "SLF4J" | "SPRING_TEMPLATE" | "VCPLUS" | "XMLPULL" | "XPP3" | "XSTREAM" | "SQL_SERVER" | "SYBASE" | "TEAMDEV" | "MIG_LAYOUT" | "R7000"} eulaType The EULA type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEulaContent(
      eulaType:
        | "ANTLR"
        | "AOPALLIANCE"
        | "APACHE"
        | "BOUNCY_CASTLE"
        | "CDDL"
        | "CPL"
        | "CPOL"
        | "CRIMSON"
        | "DOM4J"
        | "ECLIPSE"
        | "HAMCREST"
        | "JSOUP"
        | "LGPL"
        | "MOCKITO"
        | "MOZILLA"
        | "OBJENESIS"
        | "ORACLE_BCL"
        | "SLF4J"
        | "SPRING_TEMPLATE"
        | "VCPLUS"
        | "XMLPULL"
        | "XPP3"
        | "XSTREAM"
        | "SQL_SERVER"
        | "SYBASE"
        | "TEAMDEV"
        | "MIG_LAYOUT"
        | "R7000",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'eulaType' is not null or undefined
      if (eulaType === null || eulaType === undefined) {
        throw new RequiredError(
          "eulaType",
          "Required parameter eulaType was null or undefined when calling fetchEulaContent."
        );
      }
      const localVarPath = `/serverResource/eula/{eulaType}`.replace(
        `{${"eulaType"}}`,
        encodeURIComponent(String(eulaType))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEula(options: any = {}): FetchArgs {
      const localVarPath = `/serverResource/eula/smartservice`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by language and country.
     * @param {"en" | "fr" | "es" | "it" | "de" | "ja" | "ko" | "zh_CN" | "zh_TW" | "ru" | "tr" | "cs" | "pt" | "pl" | "nl"} language The language code.
     * @param {"AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AN" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW"} country The country code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename(
      language:
        | "en"
        | "fr"
        | "es"
        | "it"
        | "de"
        | "ja"
        | "ko"
        | "zh_CN"
        | "zh_TW"
        | "ru"
        | "tr"
        | "cs"
        | "pt"
        | "pl"
        | "nl",
      country:
        | "AD"
        | "AE"
        | "AF"
        | "AG"
        | "AI"
        | "AL"
        | "AM"
        | "AN"
        | "AO"
        | "AQ"
        | "AR"
        | "AS"
        | "AT"
        | "AU"
        | "AW"
        | "AX"
        | "AZ"
        | "BA"
        | "BB"
        | "BD"
        | "BE"
        | "BF"
        | "BG"
        | "BH"
        | "BI"
        | "BJ"
        | "BL"
        | "BM"
        | "BN"
        | "BO"
        | "BQ"
        | "BR"
        | "BS"
        | "BT"
        | "BV"
        | "BW"
        | "BY"
        | "BZ"
        | "CA"
        | "CC"
        | "CD"
        | "CF"
        | "CG"
        | "CH"
        | "CI"
        | "CK"
        | "CL"
        | "CM"
        | "CN"
        | "CO"
        | "CR"
        | "CU"
        | "CV"
        | "CW"
        | "CX"
        | "CY"
        | "CZ"
        | "DE"
        | "DJ"
        | "DK"
        | "DM"
        | "DO"
        | "DZ"
        | "EC"
        | "EE"
        | "EG"
        | "EH"
        | "ER"
        | "ES"
        | "ET"
        | "FI"
        | "FJ"
        | "FK"
        | "FM"
        | "FO"
        | "FR"
        | "GA"
        | "GB"
        | "GD"
        | "GE"
        | "GF"
        | "GG"
        | "GH"
        | "GI"
        | "GL"
        | "GM"
        | "GN"
        | "GP"
        | "GQ"
        | "GR"
        | "GS"
        | "GT"
        | "GU"
        | "GW"
        | "GY"
        | "HK"
        | "HM"
        | "HN"
        | "HR"
        | "HT"
        | "HU"
        | "ID"
        | "IE"
        | "IL"
        | "IM"
        | "IN"
        | "IO"
        | "IQ"
        | "IR"
        | "IS"
        | "IT"
        | "JE"
        | "JM"
        | "JO"
        | "JP"
        | "KE"
        | "KG"
        | "KH"
        | "KI"
        | "KM"
        | "KN"
        | "KP"
        | "KR"
        | "KW"
        | "KY"
        | "KZ"
        | "LA"
        | "LB"
        | "LC"
        | "LI"
        | "LK"
        | "LR"
        | "LS"
        | "LT"
        | "LU"
        | "LV"
        | "LY"
        | "MA"
        | "MC"
        | "MD"
        | "ME"
        | "MF"
        | "MG"
        | "MH"
        | "MK"
        | "ML"
        | "MM"
        | "MN"
        | "MO"
        | "MP"
        | "MQ"
        | "MR"
        | "MS"
        | "MT"
        | "MU"
        | "MV"
        | "MW"
        | "MX"
        | "MY"
        | "MZ"
        | "NA"
        | "NC"
        | "NE"
        | "NF"
        | "NG"
        | "NI"
        | "NL"
        | "NO"
        | "NP"
        | "NR"
        | "NU"
        | "NZ"
        | "OM"
        | "PA"
        | "PE"
        | "PF"
        | "PG"
        | "PH"
        | "PK"
        | "PL"
        | "PM"
        | "PN"
        | "PR"
        | "PS"
        | "PT"
        | "PW"
        | "PY"
        | "QA"
        | "RE"
        | "RO"
        | "RS"
        | "RU"
        | "RW"
        | "SA"
        | "SB"
        | "SC"
        | "SD"
        | "SE"
        | "SG"
        | "SH"
        | "SI"
        | "SJ"
        | "SK"
        | "SL"
        | "SM"
        | "SN"
        | "SO"
        | "SR"
        | "SS"
        | "ST"
        | "SV"
        | "SX"
        | "SY"
        | "SZ"
        | "TC"
        | "TD"
        | "TF"
        | "TG"
        | "TH"
        | "TJ"
        | "TK"
        | "TL"
        | "TM"
        | "TN"
        | "TO"
        | "TR"
        | "TT"
        | "TV"
        | "TW"
        | "TZ"
        | "UA"
        | "UG"
        | "UM"
        | "US"
        | "UY"
        | "UZ"
        | "VA"
        | "VC"
        | "VE"
        | "VG"
        | "VI"
        | "VN"
        | "VU"
        | "WF"
        | "WS"
        | "YE"
        | "YT"
        | "ZA"
        | "ZM"
        | "ZW",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'language' is not null or undefined
      if (language === null || language === undefined) {
        throw new RequiredError(
          "language",
          "Required parameter language was null or undefined when calling fetchSmartServiceEulaFilename."
        );
      }
      // verify required parameter 'country' is not null or undefined
      if (country === null || country === undefined) {
        throw new RequiredError(
          "country",
          "Required parameter country was null or undefined when calling fetchSmartServiceEulaFilename."
        );
      }
      const localVarPath =
        `/serverResource/eula/smartservice/filename/languages/{language}/countries/{country}`
          .replace(`{${"language"}}`, encodeURIComponent(String(language)))
          .replace(`{${"country"}}`, encodeURIComponent(String(country)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by region.
     * @param {"Asia" | "Australia" | "Canada" | "Europe" | "Japan" | "Latin America" | "United States" | "Other"} region The region name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename_1(
      region:
        | "Asia"
        | "Australia"
        | "Canada"
        | "Europe"
        | "Japan"
        | "Latin America"
        | "United States"
        | "Other",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'region' is not null or undefined
      if (region === null || region === undefined) {
        throw new RequiredError(
          "region",
          "Required parameter region was null or undefined when calling fetchSmartServiceEulaFilename_1."
        );
      }
      const localVarPath =
        `/serverResource/eula/smartservice/filename/regions/{region}`.replace(
          `{${"region"}}`,
          encodeURIComponent(String(region))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch static resources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStaticResources(options: any = {}): FetchArgs {
      const localVarPath = `/serverResource/staticResources`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the print test page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTestPage(options: any = {}): FetchArgs {
      const localVarPath = `/serverResource/testPage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ServerResourceApi - functional programming interface
 * @export
 */
export const ServerResourceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the content of a EULA.
     * @param {"ANTLR" | "AOPALLIANCE" | "APACHE" | "BOUNCY_CASTLE" | "CDDL" | "CPL" | "CPOL" | "CRIMSON" | "DOM4J" | "ECLIPSE" | "HAMCREST" | "JSOUP" | "LGPL" | "MOCKITO" | "MOZILLA" | "OBJENESIS" | "ORACLE_BCL" | "SLF4J" | "SPRING_TEMPLATE" | "VCPLUS" | "XMLPULL" | "XPP3" | "XSTREAM" | "SQL_SERVER" | "SYBASE" | "TEAMDEV" | "MIG_LAYOUT" | "R7000"} eulaType The EULA type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEulaContent(
      eulaType:
        | "ANTLR"
        | "AOPALLIANCE"
        | "APACHE"
        | "BOUNCY_CASTLE"
        | "CDDL"
        | "CPL"
        | "CPOL"
        | "CRIMSON"
        | "DOM4J"
        | "ECLIPSE"
        | "HAMCREST"
        | "JSOUP"
        | "LGPL"
        | "MOCKITO"
        | "MOZILLA"
        | "OBJENESIS"
        | "ORACLE_BCL"
        | "SLF4J"
        | "SPRING_TEMPLATE"
        | "VCPLUS"
        | "XMLPULL"
        | "XPP3"
        | "XSTREAM"
        | "SQL_SERVER"
        | "SYBASE"
        | "TEAMDEV"
        | "MIG_LAYOUT"
        | "R7000",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ServerResourceApiFetchParamCreator(
        configuration
      ).fetchEulaContent(eulaType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEula(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SmartServiceEulaDto> {
      const localVarFetchArgs =
        ServerResourceApiFetchParamCreator(configuration).fetchSmartServiceEula(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by language and country.
     * @param {"en" | "fr" | "es" | "it" | "de" | "ja" | "ko" | "zh_CN" | "zh_TW" | "ru" | "tr" | "cs" | "pt" | "pl" | "nl"} language The language code.
     * @param {"AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AN" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW"} country The country code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename(
      language:
        | "en"
        | "fr"
        | "es"
        | "it"
        | "de"
        | "ja"
        | "ko"
        | "zh_CN"
        | "zh_TW"
        | "ru"
        | "tr"
        | "cs"
        | "pt"
        | "pl"
        | "nl",
      country:
        | "AD"
        | "AE"
        | "AF"
        | "AG"
        | "AI"
        | "AL"
        | "AM"
        | "AN"
        | "AO"
        | "AQ"
        | "AR"
        | "AS"
        | "AT"
        | "AU"
        | "AW"
        | "AX"
        | "AZ"
        | "BA"
        | "BB"
        | "BD"
        | "BE"
        | "BF"
        | "BG"
        | "BH"
        | "BI"
        | "BJ"
        | "BL"
        | "BM"
        | "BN"
        | "BO"
        | "BQ"
        | "BR"
        | "BS"
        | "BT"
        | "BV"
        | "BW"
        | "BY"
        | "BZ"
        | "CA"
        | "CC"
        | "CD"
        | "CF"
        | "CG"
        | "CH"
        | "CI"
        | "CK"
        | "CL"
        | "CM"
        | "CN"
        | "CO"
        | "CR"
        | "CU"
        | "CV"
        | "CW"
        | "CX"
        | "CY"
        | "CZ"
        | "DE"
        | "DJ"
        | "DK"
        | "DM"
        | "DO"
        | "DZ"
        | "EC"
        | "EE"
        | "EG"
        | "EH"
        | "ER"
        | "ES"
        | "ET"
        | "FI"
        | "FJ"
        | "FK"
        | "FM"
        | "FO"
        | "FR"
        | "GA"
        | "GB"
        | "GD"
        | "GE"
        | "GF"
        | "GG"
        | "GH"
        | "GI"
        | "GL"
        | "GM"
        | "GN"
        | "GP"
        | "GQ"
        | "GR"
        | "GS"
        | "GT"
        | "GU"
        | "GW"
        | "GY"
        | "HK"
        | "HM"
        | "HN"
        | "HR"
        | "HT"
        | "HU"
        | "ID"
        | "IE"
        | "IL"
        | "IM"
        | "IN"
        | "IO"
        | "IQ"
        | "IR"
        | "IS"
        | "IT"
        | "JE"
        | "JM"
        | "JO"
        | "JP"
        | "KE"
        | "KG"
        | "KH"
        | "KI"
        | "KM"
        | "KN"
        | "KP"
        | "KR"
        | "KW"
        | "KY"
        | "KZ"
        | "LA"
        | "LB"
        | "LC"
        | "LI"
        | "LK"
        | "LR"
        | "LS"
        | "LT"
        | "LU"
        | "LV"
        | "LY"
        | "MA"
        | "MC"
        | "MD"
        | "ME"
        | "MF"
        | "MG"
        | "MH"
        | "MK"
        | "ML"
        | "MM"
        | "MN"
        | "MO"
        | "MP"
        | "MQ"
        | "MR"
        | "MS"
        | "MT"
        | "MU"
        | "MV"
        | "MW"
        | "MX"
        | "MY"
        | "MZ"
        | "NA"
        | "NC"
        | "NE"
        | "NF"
        | "NG"
        | "NI"
        | "NL"
        | "NO"
        | "NP"
        | "NR"
        | "NU"
        | "NZ"
        | "OM"
        | "PA"
        | "PE"
        | "PF"
        | "PG"
        | "PH"
        | "PK"
        | "PL"
        | "PM"
        | "PN"
        | "PR"
        | "PS"
        | "PT"
        | "PW"
        | "PY"
        | "QA"
        | "RE"
        | "RO"
        | "RS"
        | "RU"
        | "RW"
        | "SA"
        | "SB"
        | "SC"
        | "SD"
        | "SE"
        | "SG"
        | "SH"
        | "SI"
        | "SJ"
        | "SK"
        | "SL"
        | "SM"
        | "SN"
        | "SO"
        | "SR"
        | "SS"
        | "ST"
        | "SV"
        | "SX"
        | "SY"
        | "SZ"
        | "TC"
        | "TD"
        | "TF"
        | "TG"
        | "TH"
        | "TJ"
        | "TK"
        | "TL"
        | "TM"
        | "TN"
        | "TO"
        | "TR"
        | "TT"
        | "TV"
        | "TW"
        | "TZ"
        | "UA"
        | "UG"
        | "UM"
        | "US"
        | "UY"
        | "UZ"
        | "VA"
        | "VC"
        | "VE"
        | "VG"
        | "VI"
        | "VN"
        | "VU"
        | "WF"
        | "WS"
        | "YE"
        | "YT"
        | "ZA"
        | "ZM"
        | "ZW",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ServerResourceApiFetchParamCreator(
        configuration
      ).fetchSmartServiceEulaFilename(language, country, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by region.
     * @param {"Asia" | "Australia" | "Canada" | "Europe" | "Japan" | "Latin America" | "United States" | "Other"} region The region name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename_1(
      region:
        | "Asia"
        | "Australia"
        | "Canada"
        | "Europe"
        | "Japan"
        | "Latin America"
        | "United States"
        | "Other",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = ServerResourceApiFetchParamCreator(
        configuration
      ).fetchSmartServiceEulaFilename_1(region, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch static resources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStaticResources(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<{ [key: string]: any }> {
      const localVarFetchArgs =
        ServerResourceApiFetchParamCreator(configuration).fetchStaticResources(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the print test page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTestPage(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        ServerResourceApiFetchParamCreator(configuration).fetchTestPage(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ServerResourceApi - factory interface
 * @export
 */
export const ServerResourceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the content of a EULA.
     * @param {"ANTLR" | "AOPALLIANCE" | "APACHE" | "BOUNCY_CASTLE" | "CDDL" | "CPL" | "CPOL" | "CRIMSON" | "DOM4J" | "ECLIPSE" | "HAMCREST" | "JSOUP" | "LGPL" | "MOCKITO" | "MOZILLA" | "OBJENESIS" | "ORACLE_BCL" | "SLF4J" | "SPRING_TEMPLATE" | "VCPLUS" | "XMLPULL" | "XPP3" | "XSTREAM" | "SQL_SERVER" | "SYBASE" | "TEAMDEV" | "MIG_LAYOUT" | "R7000"} eulaType The EULA type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchEulaContent(
      eulaType:
        | "ANTLR"
        | "AOPALLIANCE"
        | "APACHE"
        | "BOUNCY_CASTLE"
        | "CDDL"
        | "CPL"
        | "CPOL"
        | "CRIMSON"
        | "DOM4J"
        | "ECLIPSE"
        | "HAMCREST"
        | "JSOUP"
        | "LGPL"
        | "MOCKITO"
        | "MOZILLA"
        | "OBJENESIS"
        | "ORACLE_BCL"
        | "SLF4J"
        | "SPRING_TEMPLATE"
        | "VCPLUS"
        | "XMLPULL"
        | "XPP3"
        | "XSTREAM"
        | "SQL_SERVER"
        | "SYBASE"
        | "TEAMDEV"
        | "MIG_LAYOUT"
        | "R7000",
      options?: any
    ) {
      return ServerResourceApiFp(configuration).fetchEulaContent(
        eulaType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEula(options?: any) {
      return ServerResourceApiFp(configuration).fetchSmartServiceEula(options)(
        fetch,
        basePath
      );
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by language and country.
     * @param {"en" | "fr" | "es" | "it" | "de" | "ja" | "ko" | "zh_CN" | "zh_TW" | "ru" | "tr" | "cs" | "pt" | "pl" | "nl"} language The language code.
     * @param {"AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AN" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW"} country The country code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename(
      language:
        | "en"
        | "fr"
        | "es"
        | "it"
        | "de"
        | "ja"
        | "ko"
        | "zh_CN"
        | "zh_TW"
        | "ru"
        | "tr"
        | "cs"
        | "pt"
        | "pl"
        | "nl",
      country:
        | "AD"
        | "AE"
        | "AF"
        | "AG"
        | "AI"
        | "AL"
        | "AM"
        | "AN"
        | "AO"
        | "AQ"
        | "AR"
        | "AS"
        | "AT"
        | "AU"
        | "AW"
        | "AX"
        | "AZ"
        | "BA"
        | "BB"
        | "BD"
        | "BE"
        | "BF"
        | "BG"
        | "BH"
        | "BI"
        | "BJ"
        | "BL"
        | "BM"
        | "BN"
        | "BO"
        | "BQ"
        | "BR"
        | "BS"
        | "BT"
        | "BV"
        | "BW"
        | "BY"
        | "BZ"
        | "CA"
        | "CC"
        | "CD"
        | "CF"
        | "CG"
        | "CH"
        | "CI"
        | "CK"
        | "CL"
        | "CM"
        | "CN"
        | "CO"
        | "CR"
        | "CU"
        | "CV"
        | "CW"
        | "CX"
        | "CY"
        | "CZ"
        | "DE"
        | "DJ"
        | "DK"
        | "DM"
        | "DO"
        | "DZ"
        | "EC"
        | "EE"
        | "EG"
        | "EH"
        | "ER"
        | "ES"
        | "ET"
        | "FI"
        | "FJ"
        | "FK"
        | "FM"
        | "FO"
        | "FR"
        | "GA"
        | "GB"
        | "GD"
        | "GE"
        | "GF"
        | "GG"
        | "GH"
        | "GI"
        | "GL"
        | "GM"
        | "GN"
        | "GP"
        | "GQ"
        | "GR"
        | "GS"
        | "GT"
        | "GU"
        | "GW"
        | "GY"
        | "HK"
        | "HM"
        | "HN"
        | "HR"
        | "HT"
        | "HU"
        | "ID"
        | "IE"
        | "IL"
        | "IM"
        | "IN"
        | "IO"
        | "IQ"
        | "IR"
        | "IS"
        | "IT"
        | "JE"
        | "JM"
        | "JO"
        | "JP"
        | "KE"
        | "KG"
        | "KH"
        | "KI"
        | "KM"
        | "KN"
        | "KP"
        | "KR"
        | "KW"
        | "KY"
        | "KZ"
        | "LA"
        | "LB"
        | "LC"
        | "LI"
        | "LK"
        | "LR"
        | "LS"
        | "LT"
        | "LU"
        | "LV"
        | "LY"
        | "MA"
        | "MC"
        | "MD"
        | "ME"
        | "MF"
        | "MG"
        | "MH"
        | "MK"
        | "ML"
        | "MM"
        | "MN"
        | "MO"
        | "MP"
        | "MQ"
        | "MR"
        | "MS"
        | "MT"
        | "MU"
        | "MV"
        | "MW"
        | "MX"
        | "MY"
        | "MZ"
        | "NA"
        | "NC"
        | "NE"
        | "NF"
        | "NG"
        | "NI"
        | "NL"
        | "NO"
        | "NP"
        | "NR"
        | "NU"
        | "NZ"
        | "OM"
        | "PA"
        | "PE"
        | "PF"
        | "PG"
        | "PH"
        | "PK"
        | "PL"
        | "PM"
        | "PN"
        | "PR"
        | "PS"
        | "PT"
        | "PW"
        | "PY"
        | "QA"
        | "RE"
        | "RO"
        | "RS"
        | "RU"
        | "RW"
        | "SA"
        | "SB"
        | "SC"
        | "SD"
        | "SE"
        | "SG"
        | "SH"
        | "SI"
        | "SJ"
        | "SK"
        | "SL"
        | "SM"
        | "SN"
        | "SO"
        | "SR"
        | "SS"
        | "ST"
        | "SV"
        | "SX"
        | "SY"
        | "SZ"
        | "TC"
        | "TD"
        | "TF"
        | "TG"
        | "TH"
        | "TJ"
        | "TK"
        | "TL"
        | "TM"
        | "TN"
        | "TO"
        | "TR"
        | "TT"
        | "TV"
        | "TW"
        | "TZ"
        | "UA"
        | "UG"
        | "UM"
        | "US"
        | "UY"
        | "UZ"
        | "VA"
        | "VC"
        | "VE"
        | "VG"
        | "VI"
        | "VN"
        | "VU"
        | "WF"
        | "WS"
        | "YE"
        | "YT"
        | "ZA"
        | "ZM"
        | "ZW",
      options?: any
    ) {
      return ServerResourceApiFp(configuration).fetchSmartServiceEulaFilename(
        language,
        country,
        options
      )(fetch, basePath);
    },
    /**
     * This service is not used by the JavaFX client.  This service is for automation use only.
     * @summary Get the SmartService EULA filename by region.
     * @param {"Asia" | "Australia" | "Canada" | "Europe" | "Japan" | "Latin America" | "United States" | "Other"} region The region name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSmartServiceEulaFilename_1(
      region:
        | "Asia"
        | "Australia"
        | "Canada"
        | "Europe"
        | "Japan"
        | "Latin America"
        | "United States"
        | "Other",
      options?: any
    ) {
      return ServerResourceApiFp(configuration).fetchSmartServiceEulaFilename_1(
        region,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch static resources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStaticResources(options?: any) {
      return ServerResourceApiFp(configuration).fetchStaticResources(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the print test page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTestPage(options?: any) {
      return ServerResourceApiFp(configuration).fetchTestPage(options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * ServerResourceApi - object-oriented interface
 * @export
 * @class ServerResourceApi
 * @extends {BaseAPI}
 */
export class ServerResourceApi extends BaseAPI {
  /**
   *
   * @summary Get the content of a EULA.
   * @param {"ANTLR" | "AOPALLIANCE" | "APACHE" | "BOUNCY_CASTLE" | "CDDL" | "CPL" | "CPOL" | "CRIMSON" | "DOM4J" | "ECLIPSE" | "HAMCREST" | "JSOUP" | "LGPL" | "MOCKITO" | "MOZILLA" | "OBJENESIS" | "ORACLE_BCL" | "SLF4J" | "SPRING_TEMPLATE" | "VCPLUS" | "XMLPULL" | "XPP3" | "XSTREAM" | "SQL_SERVER" | "SYBASE" | "TEAMDEV" | "MIG_LAYOUT" | "R7000"} eulaType The EULA type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchEulaContent(
    eulaType:
      | "ANTLR"
      | "AOPALLIANCE"
      | "APACHE"
      | "BOUNCY_CASTLE"
      | "CDDL"
      | "CPL"
      | "CPOL"
      | "CRIMSON"
      | "DOM4J"
      | "ECLIPSE"
      | "HAMCREST"
      | "JSOUP"
      | "LGPL"
      | "MOCKITO"
      | "MOZILLA"
      | "OBJENESIS"
      | "ORACLE_BCL"
      | "SLF4J"
      | "SPRING_TEMPLATE"
      | "VCPLUS"
      | "XMLPULL"
      | "XPP3"
      | "XSTREAM"
      | "SQL_SERVER"
      | "SYBASE"
      | "TEAMDEV"
      | "MIG_LAYOUT"
      | "R7000",
    options?: any
  ) {
    return ServerResourceApiFp(this.configuration).fetchEulaContent(
      eulaType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the SmartService EULA.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchSmartServiceEula(options?: any) {
    return ServerResourceApiFp(this.configuration).fetchSmartServiceEula(
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This service is not used by the JavaFX client.  This service is for automation use only.
   * @summary Get the SmartService EULA filename by language and country.
   * @param {"en" | "fr" | "es" | "it" | "de" | "ja" | "ko" | "zh_CN" | "zh_TW" | "ru" | "tr" | "cs" | "pt" | "pl" | "nl"} language The language code.
   * @param {"AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AN" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW"} country The country code.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchSmartServiceEulaFilename(
    language:
      | "en"
      | "fr"
      | "es"
      | "it"
      | "de"
      | "ja"
      | "ko"
      | "zh_CN"
      | "zh_TW"
      | "ru"
      | "tr"
      | "cs"
      | "pt"
      | "pl"
      | "nl",
    country:
      | "AD"
      | "AE"
      | "AF"
      | "AG"
      | "AI"
      | "AL"
      | "AM"
      | "AN"
      | "AO"
      | "AQ"
      | "AR"
      | "AS"
      | "AT"
      | "AU"
      | "AW"
      | "AX"
      | "AZ"
      | "BA"
      | "BB"
      | "BD"
      | "BE"
      | "BF"
      | "BG"
      | "BH"
      | "BI"
      | "BJ"
      | "BL"
      | "BM"
      | "BN"
      | "BO"
      | "BQ"
      | "BR"
      | "BS"
      | "BT"
      | "BV"
      | "BW"
      | "BY"
      | "BZ"
      | "CA"
      | "CC"
      | "CD"
      | "CF"
      | "CG"
      | "CH"
      | "CI"
      | "CK"
      | "CL"
      | "CM"
      | "CN"
      | "CO"
      | "CR"
      | "CU"
      | "CV"
      | "CW"
      | "CX"
      | "CY"
      | "CZ"
      | "DE"
      | "DJ"
      | "DK"
      | "DM"
      | "DO"
      | "DZ"
      | "EC"
      | "EE"
      | "EG"
      | "EH"
      | "ER"
      | "ES"
      | "ET"
      | "FI"
      | "FJ"
      | "FK"
      | "FM"
      | "FO"
      | "FR"
      | "GA"
      | "GB"
      | "GD"
      | "GE"
      | "GF"
      | "GG"
      | "GH"
      | "GI"
      | "GL"
      | "GM"
      | "GN"
      | "GP"
      | "GQ"
      | "GR"
      | "GS"
      | "GT"
      | "GU"
      | "GW"
      | "GY"
      | "HK"
      | "HM"
      | "HN"
      | "HR"
      | "HT"
      | "HU"
      | "ID"
      | "IE"
      | "IL"
      | "IM"
      | "IN"
      | "IO"
      | "IQ"
      | "IR"
      | "IS"
      | "IT"
      | "JE"
      | "JM"
      | "JO"
      | "JP"
      | "KE"
      | "KG"
      | "KH"
      | "KI"
      | "KM"
      | "KN"
      | "KP"
      | "KR"
      | "KW"
      | "KY"
      | "KZ"
      | "LA"
      | "LB"
      | "LC"
      | "LI"
      | "LK"
      | "LR"
      | "LS"
      | "LT"
      | "LU"
      | "LV"
      | "LY"
      | "MA"
      | "MC"
      | "MD"
      | "ME"
      | "MF"
      | "MG"
      | "MH"
      | "MK"
      | "ML"
      | "MM"
      | "MN"
      | "MO"
      | "MP"
      | "MQ"
      | "MR"
      | "MS"
      | "MT"
      | "MU"
      | "MV"
      | "MW"
      | "MX"
      | "MY"
      | "MZ"
      | "NA"
      | "NC"
      | "NE"
      | "NF"
      | "NG"
      | "NI"
      | "NL"
      | "NO"
      | "NP"
      | "NR"
      | "NU"
      | "NZ"
      | "OM"
      | "PA"
      | "PE"
      | "PF"
      | "PG"
      | "PH"
      | "PK"
      | "PL"
      | "PM"
      | "PN"
      | "PR"
      | "PS"
      | "PT"
      | "PW"
      | "PY"
      | "QA"
      | "RE"
      | "RO"
      | "RS"
      | "RU"
      | "RW"
      | "SA"
      | "SB"
      | "SC"
      | "SD"
      | "SE"
      | "SG"
      | "SH"
      | "SI"
      | "SJ"
      | "SK"
      | "SL"
      | "SM"
      | "SN"
      | "SO"
      | "SR"
      | "SS"
      | "ST"
      | "SV"
      | "SX"
      | "SY"
      | "SZ"
      | "TC"
      | "TD"
      | "TF"
      | "TG"
      | "TH"
      | "TJ"
      | "TK"
      | "TL"
      | "TM"
      | "TN"
      | "TO"
      | "TR"
      | "TT"
      | "TV"
      | "TW"
      | "TZ"
      | "UA"
      | "UG"
      | "UM"
      | "US"
      | "UY"
      | "UZ"
      | "VA"
      | "VC"
      | "VE"
      | "VG"
      | "VI"
      | "VN"
      | "VU"
      | "WF"
      | "WS"
      | "YE"
      | "YT"
      | "ZA"
      | "ZM"
      | "ZW",
    options?: any
  ) {
    return ServerResourceApiFp(
      this.configuration
    ).fetchSmartServiceEulaFilename(
      language,
      country,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * This service is not used by the JavaFX client.  This service is for automation use only.
   * @summary Get the SmartService EULA filename by region.
   * @param {"Asia" | "Australia" | "Canada" | "Europe" | "Japan" | "Latin America" | "United States" | "Other"} region The region name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchSmartServiceEulaFilename_1(
    region:
      | "Asia"
      | "Australia"
      | "Canada"
      | "Europe"
      | "Japan"
      | "Latin America"
      | "United States"
      | "Other",
    options?: any
  ) {
    return ServerResourceApiFp(
      this.configuration
    ).fetchSmartServiceEulaFilename_1(region, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch static resources.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchStaticResources(options?: any) {
    return ServerResourceApiFp(this.configuration).fetchStaticResources(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the print test page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerResourceApi
   */
  public fetchTestPage(options?: any) {
    return ServerResourceApiFp(this.configuration).fetchTestPage(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * SettingsApi - fetch parameter creator
 * @export
 */
export const SettingsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get settings list.
     * @param {Array<"AUTOMATICALLY_PRINT" | "AUTOPRINT_EXCEPTION_MANUALSNAP" | "AUTOPRINT_EXCEPTION_SNAPPRO" | "AUTOPRINT_DIAGNOSTIC_REPORT" | "BACKUP_ON_EXIT" | "DISPLAY_BEEP_ALERT" | "DISPLAY_BLINK_NEW_RESULTS" | "DISPLAY_CENSUSLIST" | "DISPLAY_CLIENT_FIRSTNAME" | "DISPLAY_CLIENT_LASTNAME" | "DISPLAY_DOCTOR_NAME" | "DISPLAY_ENGLISH_ASSAY_NAME" | "DISPLAY_PATIENT_BREED" | "DISPLAY_PATIENT_GENDER" | "DISPLAY_PATIENT_WEIGHT" | "DISPLAY_REASON_FOR_TESTING" | "DISPLAY_PENDING_REQUESTS" | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS" | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "DISPLAY_RECENT_RESULTS" | "DISPLAY_REQUISITION_ID" | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS" | "DISPLAY_SHOW_ALERT" | "ENABLE_SCOPE_LOGGING" | "ENABLE_STAT" | "FIRST_BOOT" | "INCLUDE_UA_PHYSICAL_EXAM" | "INCLUDE_UA_SEDIMENT_EXAM" | "PRINT_INVUE_IMAGES" | "PRINT_LASERCYTE_DOTPLOTS" | "PRINT_PROCYTE_DOTPLOTS" | "PRINT_PROCYTE_ONE_DOTPLOTS" | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK" | "REQUIRE_REQUISITION_ID" | "RUSSIAN_SWITCH_KEY_TOGGLED" | "SHUTDOWN_ON_EXIT" | "IVLS_UPGRADE_ATTEMPTED" | "IVLS_UPGRADE_SUCCESS" | "PRINT_CHINESE_REPORT" | "DISPLAY_BEEP_ALERT_DURATION" | "DISPLAY_BLINK_NEW_RESULTS_DURATION" | "PRINT_LINES_FOR_LETTERHEAD" | "PRINT_NUMBER_OF_COPIES" | "CLINIC_COUNTRY" | "CLINIC_LANGUAGE" | "LAST_VIEWED_PIMS_LIST" | "OUT_OF_RANGE_RESULTS_HIGH" | "OUT_OF_RANGE_RESULTS_LOW" | "ABNORMAL_RESULT_COLOR" | "DEFAULT_PRINTER" | "DEFAULT_PAPER_SIZE" | "PRINT_HEADER_LINE_1" | "PRINT_HEADER_LINE_2" | "PRINT_HEADER_LINE_3" | "PRINT_HEMATOLOGY_MESSAGE_CODES" | "PRINT_QUALITY" | "PRINT_REPORT_HEADER_OPTION" | "PRINT_RESULT_REPORT_FORMAT" | "PRINT_TEST_RESULTS_ORDER" | "SAP_REFERENCE_NUMBER" | "UNIT_SYSTEM" | "WEIGHT_UNIT_TYPE" | "RECEIVE_REFLAB_RESULTS" | "SHOW_GREAT_NEWS" | "BACKUP_CATALYSTDX_ACTIVITY_LOG" | "BACKUP_CATALYSTDX_DATA_LOG" | "BACKUP_CATALYSTDX_ERROR_LOG" | "DEBUG_LC_ALERTS" | "LASERCYTE_SYNOVIAL_FLUID_REMINDER" | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER" | "INVERT_SAMPLE_REMINDER" | "REAGENT_LOW_REMINDER" | "PROCYTE_SYNOVIAL_FLUID_REMINDER" | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER" | "SNAP_CANINE3DX" | "SNAP_CANINE4DX" | "SNAP_CANINE4DXPLUS" | "SNAP_CANINELEISH4DX" | "SNAP_CANINECPL" | "SNAP_CANINEGIARDIA" | "SNAP_CANINEHEARTWORM" | "SNAP_CANINELEISHMANIA" | "SNAP_CANINELEISHMANIA2SPOT" | "SNAP_CANINELEPTO" | "SNAP_CANINEPARVO" | "SNAP_COMPLETIONBEEP" | "SNAP_ENABLETIMER" | "SNAP_EQUINEFOALIGG" | "SNAP_FELINECOMBO" | "SNAP_FELINECOMBOPLUS" | "SNAP_FELINEFBNP" | "SNAP_FELINEFELV" | "SNAP_FELINEFPL" | "SNAP_FELINEGIARDIA" | "SNAP_FELINEHEARTWORM" | "SNAP_FELINEHEARTWORMRT" | "SNAP_FELINETRIPLE" | "SNAP_CANINEFECAL" | "SNAP_FELINEFECAL" | "SNAP_CANINEANGIODETECT" | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG" | "BACKUP_SNAPSHOTDX_DATA_LOG" | "BACKUP_SNAPSHOTDX_ERROR_LOG" | "ALERT_WARNING_DURATION" | "CATALYSTDX_QC_DATA_INTERVAL" | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT" | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD" | "PROCYTE_MAX_REPLACE_COUNT" | "PROCYTE_REAGENT_LIMIT" | "PROCYTE_STAIN_LIMIT" | "PROCYTE_SW_UPGRADE_TIMEOUT" | "PROCYTE_UNINTENTIONAL_OFFLINE" | "UDO_INTERVAL" | "INSTRUMENT_UPGRADE_POLL_INTERVAL" | "VNC_CONNECT" | "URISED_IMAGE_CAPTURE_COUNT" | "URISED_IMAGE_TRANSER_COUNT" | "URISED_INCLUDE_IMAGE_ON_REPORT" | "URISED_ONLY_IF_SEDIMENT_PRESENT" | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED" | "MANUAL_UA_AUTO_ADD" | "UA_REPORTING_UNIT_TYPE" | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS" | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT" | "CATDX_SMARTQC_REMINDER_WEEKS" | "CATDX_SMARTQC_REMINDER_DAY" | "CATDX_SMARTQC_REMINDER_HOUR" | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT" | "ESUPPORT_ENABLE_ESUPPORT" | "ESUPPORT_ESUPPORT_ACTIVATED" | "ESUPPORT_ESUPPORT_EULA_ACCEPTED" | "ESUPPORT_RUN_ENABLE_ESUPPORT" | "SMARTSERVICE_DATE" | "SMARTSERVICE_UPGRADE_DATE" | "SMARTSERVICE_OFFLINE_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME" | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "SMARTSERVICE_UPGRADE_IGNORE_COUNT" | "SMARTSERVICE_COUNTRY" | "SMARTSERVICE_LANGUAGE" | "SMARTSERVICE_REGION" | "SMARTSERVICE_UPGRADE_STATUS" | "SMARTSERVICE_OFFLINE_DATE" | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE" | "MC_SMARTSERVICE_OFFLINE_FLAG" | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES" | "MC_SMARTSERVICE_OFFLINE_TIME" | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL" | "DELTA_CONTROL_MODE" | "AUTO_BACKUPS_ENABLED" | "PPR_DISCONNECTION_DATE" | "PPR_MAX_OFFLINE_WARNING_DAYS" | "PPR_ENABLED" | "PPR_WARNING_DISPLAYED" | "PPR_MONITOR_FREQUENCY" | "PPR_REMIND_ME_LATER_DURATION_SECONDS" | "NIGHTLY_BACKUP_PATH" | "MAX_LOCAL_BACKUPS" | "DATABASES_TO_BACKUP" | "PIMS_AUTOCONNECT" | "PIMS_HISTORYDATE" | "PIMS_INTERLINK_GROUP_PORT" | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD" | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA" | "PIMS_CONNECTION_TYPE" | "PIMS_TRANSMIT_RESULTS" | "ROUTER_FIRMWARE_VERSION" | "ROUTER_MODEL_NUMBER" | "ROUTER_WAN_IP_CHOICE" | "PIMS_INTERLINK_GROUP_ADDRESS" | "PIMS_IVLS_INTEGRATION_ID" | "PIMS_IVLS_INTEGRATION_NAME" | "PIMS_IP_ADDRESS" | "ROUTER_PASSWORD" | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS" | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS">} [setting] List of settings to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      setting?: Array<
        | "AUTOMATICALLY_PRINT"
        | "AUTOPRINT_EXCEPTION_MANUALSNAP"
        | "AUTOPRINT_EXCEPTION_SNAPPRO"
        | "AUTOPRINT_DIAGNOSTIC_REPORT"
        | "BACKUP_ON_EXIT"
        | "DISPLAY_BEEP_ALERT"
        | "DISPLAY_BLINK_NEW_RESULTS"
        | "DISPLAY_CENSUSLIST"
        | "DISPLAY_CLIENT_FIRSTNAME"
        | "DISPLAY_CLIENT_LASTNAME"
        | "DISPLAY_DOCTOR_NAME"
        | "DISPLAY_ENGLISH_ASSAY_NAME"
        | "DISPLAY_PATIENT_BREED"
        | "DISPLAY_PATIENT_GENDER"
        | "DISPLAY_PATIENT_WEIGHT"
        | "DISPLAY_REASON_FOR_TESTING"
        | "DISPLAY_PENDING_REQUESTS"
        | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS"
        | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "DISPLAY_RECENT_RESULTS"
        | "DISPLAY_REQUISITION_ID"
        | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS"
        | "DISPLAY_SHOW_ALERT"
        | "ENABLE_SCOPE_LOGGING"
        | "ENABLE_STAT"
        | "FIRST_BOOT"
        | "INCLUDE_UA_PHYSICAL_EXAM"
        | "INCLUDE_UA_SEDIMENT_EXAM"
        | "PRINT_INVUE_IMAGES"
        | "PRINT_LASERCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_ONE_DOTPLOTS"
        | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK"
        | "REQUIRE_REQUISITION_ID"
        | "RUSSIAN_SWITCH_KEY_TOGGLED"
        | "SHUTDOWN_ON_EXIT"
        | "IVLS_UPGRADE_ATTEMPTED"
        | "IVLS_UPGRADE_SUCCESS"
        | "PRINT_CHINESE_REPORT"
        | "DISPLAY_BEEP_ALERT_DURATION"
        | "DISPLAY_BLINK_NEW_RESULTS_DURATION"
        | "PRINT_LINES_FOR_LETTERHEAD"
        | "PRINT_NUMBER_OF_COPIES"
        | "CLINIC_COUNTRY"
        | "CLINIC_LANGUAGE"
        | "LAST_VIEWED_PIMS_LIST"
        | "OUT_OF_RANGE_RESULTS_HIGH"
        | "OUT_OF_RANGE_RESULTS_LOW"
        | "ABNORMAL_RESULT_COLOR"
        | "DEFAULT_PRINTER"
        | "DEFAULT_PAPER_SIZE"
        | "PRINT_HEADER_LINE_1"
        | "PRINT_HEADER_LINE_2"
        | "PRINT_HEADER_LINE_3"
        | "PRINT_HEMATOLOGY_MESSAGE_CODES"
        | "PRINT_QUALITY"
        | "PRINT_REPORT_HEADER_OPTION"
        | "PRINT_RESULT_REPORT_FORMAT"
        | "PRINT_TEST_RESULTS_ORDER"
        | "SAP_REFERENCE_NUMBER"
        | "UNIT_SYSTEM"
        | "WEIGHT_UNIT_TYPE"
        | "RECEIVE_REFLAB_RESULTS"
        | "SHOW_GREAT_NEWS"
        | "BACKUP_CATALYSTDX_ACTIVITY_LOG"
        | "BACKUP_CATALYSTDX_DATA_LOG"
        | "BACKUP_CATALYSTDX_ERROR_LOG"
        | "DEBUG_LC_ALERTS"
        | "LASERCYTE_SYNOVIAL_FLUID_REMINDER"
        | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER"
        | "INVERT_SAMPLE_REMINDER"
        | "REAGENT_LOW_REMINDER"
        | "PROCYTE_SYNOVIAL_FLUID_REMINDER"
        | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER"
        | "SNAP_CANINE3DX"
        | "SNAP_CANINE4DX"
        | "SNAP_CANINE4DXPLUS"
        | "SNAP_CANINELEISH4DX"
        | "SNAP_CANINECPL"
        | "SNAP_CANINEGIARDIA"
        | "SNAP_CANINEHEARTWORM"
        | "SNAP_CANINELEISHMANIA"
        | "SNAP_CANINELEISHMANIA2SPOT"
        | "SNAP_CANINELEPTO"
        | "SNAP_CANINEPARVO"
        | "SNAP_COMPLETIONBEEP"
        | "SNAP_ENABLETIMER"
        | "SNAP_EQUINEFOALIGG"
        | "SNAP_FELINECOMBO"
        | "SNAP_FELINECOMBOPLUS"
        | "SNAP_FELINEFBNP"
        | "SNAP_FELINEFELV"
        | "SNAP_FELINEFPL"
        | "SNAP_FELINEGIARDIA"
        | "SNAP_FELINEHEARTWORM"
        | "SNAP_FELINEHEARTWORMRT"
        | "SNAP_FELINETRIPLE"
        | "SNAP_CANINEFECAL"
        | "SNAP_FELINEFECAL"
        | "SNAP_CANINEANGIODETECT"
        | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG"
        | "BACKUP_SNAPSHOTDX_DATA_LOG"
        | "BACKUP_SNAPSHOTDX_ERROR_LOG"
        | "ALERT_WARNING_DURATION"
        | "CATALYSTDX_QC_DATA_INTERVAL"
        | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT"
        | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD"
        | "PROCYTE_MAX_REPLACE_COUNT"
        | "PROCYTE_REAGENT_LIMIT"
        | "PROCYTE_STAIN_LIMIT"
        | "PROCYTE_SW_UPGRADE_TIMEOUT"
        | "PROCYTE_UNINTENTIONAL_OFFLINE"
        | "UDO_INTERVAL"
        | "INSTRUMENT_UPGRADE_POLL_INTERVAL"
        | "VNC_CONNECT"
        | "URISED_IMAGE_CAPTURE_COUNT"
        | "URISED_IMAGE_TRANSER_COUNT"
        | "URISED_INCLUDE_IMAGE_ON_REPORT"
        | "URISED_ONLY_IF_SEDIMENT_PRESENT"
        | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED"
        | "MANUAL_UA_AUTO_ADD"
        | "UA_REPORTING_UNIT_TYPE"
        | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS"
        | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "CATDX_SMARTQC_REMINDER_WEEKS"
        | "CATDX_SMARTQC_REMINDER_DAY"
        | "CATDX_SMARTQC_REMINDER_HOUR"
        | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "ESUPPORT_ENABLE_ESUPPORT"
        | "ESUPPORT_ESUPPORT_ACTIVATED"
        | "ESUPPORT_ESUPPORT_EULA_ACCEPTED"
        | "ESUPPORT_RUN_ENABLE_ESUPPORT"
        | "SMARTSERVICE_DATE"
        | "SMARTSERVICE_UPGRADE_DATE"
        | "SMARTSERVICE_OFFLINE_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME"
        | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "SMARTSERVICE_UPGRADE_IGNORE_COUNT"
        | "SMARTSERVICE_COUNTRY"
        | "SMARTSERVICE_LANGUAGE"
        | "SMARTSERVICE_REGION"
        | "SMARTSERVICE_UPGRADE_STATUS"
        | "SMARTSERVICE_OFFLINE_DATE"
        | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE"
        | "MC_SMARTSERVICE_OFFLINE_FLAG"
        | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES"
        | "MC_SMARTSERVICE_OFFLINE_TIME"
        | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL"
        | "DELTA_CONTROL_MODE"
        | "AUTO_BACKUPS_ENABLED"
        | "PPR_DISCONNECTION_DATE"
        | "PPR_MAX_OFFLINE_WARNING_DAYS"
        | "PPR_ENABLED"
        | "PPR_WARNING_DISPLAYED"
        | "PPR_MONITOR_FREQUENCY"
        | "PPR_REMIND_ME_LATER_DURATION_SECONDS"
        | "NIGHTLY_BACKUP_PATH"
        | "MAX_LOCAL_BACKUPS"
        | "DATABASES_TO_BACKUP"
        | "PIMS_AUTOCONNECT"
        | "PIMS_HISTORYDATE"
        | "PIMS_INTERLINK_GROUP_PORT"
        | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD"
        | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_TRANSMIT_RESULTS"
        | "ROUTER_FIRMWARE_VERSION"
        | "ROUTER_MODEL_NUMBER"
        | "ROUTER_WAN_IP_CHOICE"
        | "PIMS_INTERLINK_GROUP_ADDRESS"
        | "PIMS_IVLS_INTEGRATION_ID"
        | "PIMS_IVLS_INTEGRATION_NAME"
        | "PIMS_IP_ADDRESS"
        | "ROUTER_PASSWORD"
        | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS"
        | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS"
      >,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/settings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (setting) {
        localVarQueryParameter["setting"] = setting;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save settings. Returns a list of all modified settings.
     * @param {Array<SettingDto>} [body] List of settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings(body?: Array<SettingDto>, options: any = {}): FetchArgs {
      const localVarPath = `/settings`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;SettingDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get settings list.
     * @param {Array<"AUTOMATICALLY_PRINT" | "AUTOPRINT_EXCEPTION_MANUALSNAP" | "AUTOPRINT_EXCEPTION_SNAPPRO" | "AUTOPRINT_DIAGNOSTIC_REPORT" | "BACKUP_ON_EXIT" | "DISPLAY_BEEP_ALERT" | "DISPLAY_BLINK_NEW_RESULTS" | "DISPLAY_CENSUSLIST" | "DISPLAY_CLIENT_FIRSTNAME" | "DISPLAY_CLIENT_LASTNAME" | "DISPLAY_DOCTOR_NAME" | "DISPLAY_ENGLISH_ASSAY_NAME" | "DISPLAY_PATIENT_BREED" | "DISPLAY_PATIENT_GENDER" | "DISPLAY_PATIENT_WEIGHT" | "DISPLAY_REASON_FOR_TESTING" | "DISPLAY_PENDING_REQUESTS" | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS" | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "DISPLAY_RECENT_RESULTS" | "DISPLAY_REQUISITION_ID" | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS" | "DISPLAY_SHOW_ALERT" | "ENABLE_SCOPE_LOGGING" | "ENABLE_STAT" | "FIRST_BOOT" | "INCLUDE_UA_PHYSICAL_EXAM" | "INCLUDE_UA_SEDIMENT_EXAM" | "PRINT_INVUE_IMAGES" | "PRINT_LASERCYTE_DOTPLOTS" | "PRINT_PROCYTE_DOTPLOTS" | "PRINT_PROCYTE_ONE_DOTPLOTS" | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK" | "REQUIRE_REQUISITION_ID" | "RUSSIAN_SWITCH_KEY_TOGGLED" | "SHUTDOWN_ON_EXIT" | "IVLS_UPGRADE_ATTEMPTED" | "IVLS_UPGRADE_SUCCESS" | "PRINT_CHINESE_REPORT" | "DISPLAY_BEEP_ALERT_DURATION" | "DISPLAY_BLINK_NEW_RESULTS_DURATION" | "PRINT_LINES_FOR_LETTERHEAD" | "PRINT_NUMBER_OF_COPIES" | "CLINIC_COUNTRY" | "CLINIC_LANGUAGE" | "LAST_VIEWED_PIMS_LIST" | "OUT_OF_RANGE_RESULTS_HIGH" | "OUT_OF_RANGE_RESULTS_LOW" | "ABNORMAL_RESULT_COLOR" | "DEFAULT_PRINTER" | "DEFAULT_PAPER_SIZE" | "PRINT_HEADER_LINE_1" | "PRINT_HEADER_LINE_2" | "PRINT_HEADER_LINE_3" | "PRINT_HEMATOLOGY_MESSAGE_CODES" | "PRINT_QUALITY" | "PRINT_REPORT_HEADER_OPTION" | "PRINT_RESULT_REPORT_FORMAT" | "PRINT_TEST_RESULTS_ORDER" | "SAP_REFERENCE_NUMBER" | "UNIT_SYSTEM" | "WEIGHT_UNIT_TYPE" | "RECEIVE_REFLAB_RESULTS" | "SHOW_GREAT_NEWS" | "BACKUP_CATALYSTDX_ACTIVITY_LOG" | "BACKUP_CATALYSTDX_DATA_LOG" | "BACKUP_CATALYSTDX_ERROR_LOG" | "DEBUG_LC_ALERTS" | "LASERCYTE_SYNOVIAL_FLUID_REMINDER" | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER" | "INVERT_SAMPLE_REMINDER" | "REAGENT_LOW_REMINDER" | "PROCYTE_SYNOVIAL_FLUID_REMINDER" | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER" | "SNAP_CANINE3DX" | "SNAP_CANINE4DX" | "SNAP_CANINE4DXPLUS" | "SNAP_CANINELEISH4DX" | "SNAP_CANINECPL" | "SNAP_CANINEGIARDIA" | "SNAP_CANINEHEARTWORM" | "SNAP_CANINELEISHMANIA" | "SNAP_CANINELEISHMANIA2SPOT" | "SNAP_CANINELEPTO" | "SNAP_CANINEPARVO" | "SNAP_COMPLETIONBEEP" | "SNAP_ENABLETIMER" | "SNAP_EQUINEFOALIGG" | "SNAP_FELINECOMBO" | "SNAP_FELINECOMBOPLUS" | "SNAP_FELINEFBNP" | "SNAP_FELINEFELV" | "SNAP_FELINEFPL" | "SNAP_FELINEGIARDIA" | "SNAP_FELINEHEARTWORM" | "SNAP_FELINEHEARTWORMRT" | "SNAP_FELINETRIPLE" | "SNAP_CANINEFECAL" | "SNAP_FELINEFECAL" | "SNAP_CANINEANGIODETECT" | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG" | "BACKUP_SNAPSHOTDX_DATA_LOG" | "BACKUP_SNAPSHOTDX_ERROR_LOG" | "ALERT_WARNING_DURATION" | "CATALYSTDX_QC_DATA_INTERVAL" | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT" | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD" | "PROCYTE_MAX_REPLACE_COUNT" | "PROCYTE_REAGENT_LIMIT" | "PROCYTE_STAIN_LIMIT" | "PROCYTE_SW_UPGRADE_TIMEOUT" | "PROCYTE_UNINTENTIONAL_OFFLINE" | "UDO_INTERVAL" | "INSTRUMENT_UPGRADE_POLL_INTERVAL" | "VNC_CONNECT" | "URISED_IMAGE_CAPTURE_COUNT" | "URISED_IMAGE_TRANSER_COUNT" | "URISED_INCLUDE_IMAGE_ON_REPORT" | "URISED_ONLY_IF_SEDIMENT_PRESENT" | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED" | "MANUAL_UA_AUTO_ADD" | "UA_REPORTING_UNIT_TYPE" | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS" | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT" | "CATDX_SMARTQC_REMINDER_WEEKS" | "CATDX_SMARTQC_REMINDER_DAY" | "CATDX_SMARTQC_REMINDER_HOUR" | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT" | "ESUPPORT_ENABLE_ESUPPORT" | "ESUPPORT_ESUPPORT_ACTIVATED" | "ESUPPORT_ESUPPORT_EULA_ACCEPTED" | "ESUPPORT_RUN_ENABLE_ESUPPORT" | "SMARTSERVICE_DATE" | "SMARTSERVICE_UPGRADE_DATE" | "SMARTSERVICE_OFFLINE_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME" | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "SMARTSERVICE_UPGRADE_IGNORE_COUNT" | "SMARTSERVICE_COUNTRY" | "SMARTSERVICE_LANGUAGE" | "SMARTSERVICE_REGION" | "SMARTSERVICE_UPGRADE_STATUS" | "SMARTSERVICE_OFFLINE_DATE" | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE" | "MC_SMARTSERVICE_OFFLINE_FLAG" | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES" | "MC_SMARTSERVICE_OFFLINE_TIME" | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL" | "DELTA_CONTROL_MODE" | "AUTO_BACKUPS_ENABLED" | "PPR_DISCONNECTION_DATE" | "PPR_MAX_OFFLINE_WARNING_DAYS" | "PPR_ENABLED" | "PPR_WARNING_DISPLAYED" | "PPR_MONITOR_FREQUENCY" | "PPR_REMIND_ME_LATER_DURATION_SECONDS" | "NIGHTLY_BACKUP_PATH" | "MAX_LOCAL_BACKUPS" | "DATABASES_TO_BACKUP" | "PIMS_AUTOCONNECT" | "PIMS_HISTORYDATE" | "PIMS_INTERLINK_GROUP_PORT" | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD" | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA" | "PIMS_CONNECTION_TYPE" | "PIMS_TRANSMIT_RESULTS" | "ROUTER_FIRMWARE_VERSION" | "ROUTER_MODEL_NUMBER" | "ROUTER_WAN_IP_CHOICE" | "PIMS_INTERLINK_GROUP_ADDRESS" | "PIMS_IVLS_INTEGRATION_ID" | "PIMS_IVLS_INTEGRATION_NAME" | "PIMS_IP_ADDRESS" | "ROUTER_PASSWORD" | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS" | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS">} [setting] List of settings to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      setting?: Array<
        | "AUTOMATICALLY_PRINT"
        | "AUTOPRINT_EXCEPTION_MANUALSNAP"
        | "AUTOPRINT_EXCEPTION_SNAPPRO"
        | "AUTOPRINT_DIAGNOSTIC_REPORT"
        | "BACKUP_ON_EXIT"
        | "DISPLAY_BEEP_ALERT"
        | "DISPLAY_BLINK_NEW_RESULTS"
        | "DISPLAY_CENSUSLIST"
        | "DISPLAY_CLIENT_FIRSTNAME"
        | "DISPLAY_CLIENT_LASTNAME"
        | "DISPLAY_DOCTOR_NAME"
        | "DISPLAY_ENGLISH_ASSAY_NAME"
        | "DISPLAY_PATIENT_BREED"
        | "DISPLAY_PATIENT_GENDER"
        | "DISPLAY_PATIENT_WEIGHT"
        | "DISPLAY_REASON_FOR_TESTING"
        | "DISPLAY_PENDING_REQUESTS"
        | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS"
        | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "DISPLAY_RECENT_RESULTS"
        | "DISPLAY_REQUISITION_ID"
        | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS"
        | "DISPLAY_SHOW_ALERT"
        | "ENABLE_SCOPE_LOGGING"
        | "ENABLE_STAT"
        | "FIRST_BOOT"
        | "INCLUDE_UA_PHYSICAL_EXAM"
        | "INCLUDE_UA_SEDIMENT_EXAM"
        | "PRINT_INVUE_IMAGES"
        | "PRINT_LASERCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_ONE_DOTPLOTS"
        | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK"
        | "REQUIRE_REQUISITION_ID"
        | "RUSSIAN_SWITCH_KEY_TOGGLED"
        | "SHUTDOWN_ON_EXIT"
        | "IVLS_UPGRADE_ATTEMPTED"
        | "IVLS_UPGRADE_SUCCESS"
        | "PRINT_CHINESE_REPORT"
        | "DISPLAY_BEEP_ALERT_DURATION"
        | "DISPLAY_BLINK_NEW_RESULTS_DURATION"
        | "PRINT_LINES_FOR_LETTERHEAD"
        | "PRINT_NUMBER_OF_COPIES"
        | "CLINIC_COUNTRY"
        | "CLINIC_LANGUAGE"
        | "LAST_VIEWED_PIMS_LIST"
        | "OUT_OF_RANGE_RESULTS_HIGH"
        | "OUT_OF_RANGE_RESULTS_LOW"
        | "ABNORMAL_RESULT_COLOR"
        | "DEFAULT_PRINTER"
        | "DEFAULT_PAPER_SIZE"
        | "PRINT_HEADER_LINE_1"
        | "PRINT_HEADER_LINE_2"
        | "PRINT_HEADER_LINE_3"
        | "PRINT_HEMATOLOGY_MESSAGE_CODES"
        | "PRINT_QUALITY"
        | "PRINT_REPORT_HEADER_OPTION"
        | "PRINT_RESULT_REPORT_FORMAT"
        | "PRINT_TEST_RESULTS_ORDER"
        | "SAP_REFERENCE_NUMBER"
        | "UNIT_SYSTEM"
        | "WEIGHT_UNIT_TYPE"
        | "RECEIVE_REFLAB_RESULTS"
        | "SHOW_GREAT_NEWS"
        | "BACKUP_CATALYSTDX_ACTIVITY_LOG"
        | "BACKUP_CATALYSTDX_DATA_LOG"
        | "BACKUP_CATALYSTDX_ERROR_LOG"
        | "DEBUG_LC_ALERTS"
        | "LASERCYTE_SYNOVIAL_FLUID_REMINDER"
        | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER"
        | "INVERT_SAMPLE_REMINDER"
        | "REAGENT_LOW_REMINDER"
        | "PROCYTE_SYNOVIAL_FLUID_REMINDER"
        | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER"
        | "SNAP_CANINE3DX"
        | "SNAP_CANINE4DX"
        | "SNAP_CANINE4DXPLUS"
        | "SNAP_CANINELEISH4DX"
        | "SNAP_CANINECPL"
        | "SNAP_CANINEGIARDIA"
        | "SNAP_CANINEHEARTWORM"
        | "SNAP_CANINELEISHMANIA"
        | "SNAP_CANINELEISHMANIA2SPOT"
        | "SNAP_CANINELEPTO"
        | "SNAP_CANINEPARVO"
        | "SNAP_COMPLETIONBEEP"
        | "SNAP_ENABLETIMER"
        | "SNAP_EQUINEFOALIGG"
        | "SNAP_FELINECOMBO"
        | "SNAP_FELINECOMBOPLUS"
        | "SNAP_FELINEFBNP"
        | "SNAP_FELINEFELV"
        | "SNAP_FELINEFPL"
        | "SNAP_FELINEGIARDIA"
        | "SNAP_FELINEHEARTWORM"
        | "SNAP_FELINEHEARTWORMRT"
        | "SNAP_FELINETRIPLE"
        | "SNAP_CANINEFECAL"
        | "SNAP_FELINEFECAL"
        | "SNAP_CANINEANGIODETECT"
        | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG"
        | "BACKUP_SNAPSHOTDX_DATA_LOG"
        | "BACKUP_SNAPSHOTDX_ERROR_LOG"
        | "ALERT_WARNING_DURATION"
        | "CATALYSTDX_QC_DATA_INTERVAL"
        | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT"
        | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD"
        | "PROCYTE_MAX_REPLACE_COUNT"
        | "PROCYTE_REAGENT_LIMIT"
        | "PROCYTE_STAIN_LIMIT"
        | "PROCYTE_SW_UPGRADE_TIMEOUT"
        | "PROCYTE_UNINTENTIONAL_OFFLINE"
        | "UDO_INTERVAL"
        | "INSTRUMENT_UPGRADE_POLL_INTERVAL"
        | "VNC_CONNECT"
        | "URISED_IMAGE_CAPTURE_COUNT"
        | "URISED_IMAGE_TRANSER_COUNT"
        | "URISED_INCLUDE_IMAGE_ON_REPORT"
        | "URISED_ONLY_IF_SEDIMENT_PRESENT"
        | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED"
        | "MANUAL_UA_AUTO_ADD"
        | "UA_REPORTING_UNIT_TYPE"
        | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS"
        | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "CATDX_SMARTQC_REMINDER_WEEKS"
        | "CATDX_SMARTQC_REMINDER_DAY"
        | "CATDX_SMARTQC_REMINDER_HOUR"
        | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "ESUPPORT_ENABLE_ESUPPORT"
        | "ESUPPORT_ESUPPORT_ACTIVATED"
        | "ESUPPORT_ESUPPORT_EULA_ACCEPTED"
        | "ESUPPORT_RUN_ENABLE_ESUPPORT"
        | "SMARTSERVICE_DATE"
        | "SMARTSERVICE_UPGRADE_DATE"
        | "SMARTSERVICE_OFFLINE_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME"
        | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "SMARTSERVICE_UPGRADE_IGNORE_COUNT"
        | "SMARTSERVICE_COUNTRY"
        | "SMARTSERVICE_LANGUAGE"
        | "SMARTSERVICE_REGION"
        | "SMARTSERVICE_UPGRADE_STATUS"
        | "SMARTSERVICE_OFFLINE_DATE"
        | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE"
        | "MC_SMARTSERVICE_OFFLINE_FLAG"
        | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES"
        | "MC_SMARTSERVICE_OFFLINE_TIME"
        | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL"
        | "DELTA_CONTROL_MODE"
        | "AUTO_BACKUPS_ENABLED"
        | "PPR_DISCONNECTION_DATE"
        | "PPR_MAX_OFFLINE_WARNING_DAYS"
        | "PPR_ENABLED"
        | "PPR_WARNING_DISPLAYED"
        | "PPR_MONITOR_FREQUENCY"
        | "PPR_REMIND_ME_LATER_DURATION_SECONDS"
        | "NIGHTLY_BACKUP_PATH"
        | "MAX_LOCAL_BACKUPS"
        | "DATABASES_TO_BACKUP"
        | "PIMS_AUTOCONNECT"
        | "PIMS_HISTORYDATE"
        | "PIMS_INTERLINK_GROUP_PORT"
        | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD"
        | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_TRANSMIT_RESULTS"
        | "ROUTER_FIRMWARE_VERSION"
        | "ROUTER_MODEL_NUMBER"
        | "ROUTER_WAN_IP_CHOICE"
        | "PIMS_INTERLINK_GROUP_ADDRESS"
        | "PIMS_IVLS_INTEGRATION_ID"
        | "PIMS_IVLS_INTEGRATION_NAME"
        | "PIMS_IP_ADDRESS"
        | "ROUTER_PASSWORD"
        | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS"
        | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS"
      >,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingDto>> {
      const localVarFetchArgs = SettingsApiFetchParamCreator(
        configuration
      ).getSettings(setting, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save settings. Returns a list of all modified settings.
     * @param {Array<SettingDto>} [body] List of settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings(
      body?: Array<SettingDto>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SettingDto>> {
      const localVarFetchArgs = SettingsApiFetchParamCreator(
        configuration
      ).saveSettings(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get settings list.
     * @param {Array<"AUTOMATICALLY_PRINT" | "AUTOPRINT_EXCEPTION_MANUALSNAP" | "AUTOPRINT_EXCEPTION_SNAPPRO" | "AUTOPRINT_DIAGNOSTIC_REPORT" | "BACKUP_ON_EXIT" | "DISPLAY_BEEP_ALERT" | "DISPLAY_BLINK_NEW_RESULTS" | "DISPLAY_CENSUSLIST" | "DISPLAY_CLIENT_FIRSTNAME" | "DISPLAY_CLIENT_LASTNAME" | "DISPLAY_DOCTOR_NAME" | "DISPLAY_ENGLISH_ASSAY_NAME" | "DISPLAY_PATIENT_BREED" | "DISPLAY_PATIENT_GENDER" | "DISPLAY_PATIENT_WEIGHT" | "DISPLAY_REASON_FOR_TESTING" | "DISPLAY_PENDING_REQUESTS" | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS" | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "DISPLAY_RECENT_RESULTS" | "DISPLAY_REQUISITION_ID" | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS" | "DISPLAY_SHOW_ALERT" | "ENABLE_SCOPE_LOGGING" | "ENABLE_STAT" | "FIRST_BOOT" | "INCLUDE_UA_PHYSICAL_EXAM" | "INCLUDE_UA_SEDIMENT_EXAM" | "PRINT_INVUE_IMAGES" | "PRINT_LASERCYTE_DOTPLOTS" | "PRINT_PROCYTE_DOTPLOTS" | "PRINT_PROCYTE_ONE_DOTPLOTS" | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK" | "REQUIRE_REQUISITION_ID" | "RUSSIAN_SWITCH_KEY_TOGGLED" | "SHUTDOWN_ON_EXIT" | "IVLS_UPGRADE_ATTEMPTED" | "IVLS_UPGRADE_SUCCESS" | "PRINT_CHINESE_REPORT" | "DISPLAY_BEEP_ALERT_DURATION" | "DISPLAY_BLINK_NEW_RESULTS_DURATION" | "PRINT_LINES_FOR_LETTERHEAD" | "PRINT_NUMBER_OF_COPIES" | "CLINIC_COUNTRY" | "CLINIC_LANGUAGE" | "LAST_VIEWED_PIMS_LIST" | "OUT_OF_RANGE_RESULTS_HIGH" | "OUT_OF_RANGE_RESULTS_LOW" | "ABNORMAL_RESULT_COLOR" | "DEFAULT_PRINTER" | "DEFAULT_PAPER_SIZE" | "PRINT_HEADER_LINE_1" | "PRINT_HEADER_LINE_2" | "PRINT_HEADER_LINE_3" | "PRINT_HEMATOLOGY_MESSAGE_CODES" | "PRINT_QUALITY" | "PRINT_REPORT_HEADER_OPTION" | "PRINT_RESULT_REPORT_FORMAT" | "PRINT_TEST_RESULTS_ORDER" | "SAP_REFERENCE_NUMBER" | "UNIT_SYSTEM" | "WEIGHT_UNIT_TYPE" | "RECEIVE_REFLAB_RESULTS" | "SHOW_GREAT_NEWS" | "BACKUP_CATALYSTDX_ACTIVITY_LOG" | "BACKUP_CATALYSTDX_DATA_LOG" | "BACKUP_CATALYSTDX_ERROR_LOG" | "DEBUG_LC_ALERTS" | "LASERCYTE_SYNOVIAL_FLUID_REMINDER" | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER" | "INVERT_SAMPLE_REMINDER" | "REAGENT_LOW_REMINDER" | "PROCYTE_SYNOVIAL_FLUID_REMINDER" | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER" | "SNAP_CANINE3DX" | "SNAP_CANINE4DX" | "SNAP_CANINE4DXPLUS" | "SNAP_CANINELEISH4DX" | "SNAP_CANINECPL" | "SNAP_CANINEGIARDIA" | "SNAP_CANINEHEARTWORM" | "SNAP_CANINELEISHMANIA" | "SNAP_CANINELEISHMANIA2SPOT" | "SNAP_CANINELEPTO" | "SNAP_CANINEPARVO" | "SNAP_COMPLETIONBEEP" | "SNAP_ENABLETIMER" | "SNAP_EQUINEFOALIGG" | "SNAP_FELINECOMBO" | "SNAP_FELINECOMBOPLUS" | "SNAP_FELINEFBNP" | "SNAP_FELINEFELV" | "SNAP_FELINEFPL" | "SNAP_FELINEGIARDIA" | "SNAP_FELINEHEARTWORM" | "SNAP_FELINEHEARTWORMRT" | "SNAP_FELINETRIPLE" | "SNAP_CANINEFECAL" | "SNAP_FELINEFECAL" | "SNAP_CANINEANGIODETECT" | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG" | "BACKUP_SNAPSHOTDX_DATA_LOG" | "BACKUP_SNAPSHOTDX_ERROR_LOG" | "ALERT_WARNING_DURATION" | "CATALYSTDX_QC_DATA_INTERVAL" | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT" | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD" | "PROCYTE_MAX_REPLACE_COUNT" | "PROCYTE_REAGENT_LIMIT" | "PROCYTE_STAIN_LIMIT" | "PROCYTE_SW_UPGRADE_TIMEOUT" | "PROCYTE_UNINTENTIONAL_OFFLINE" | "UDO_INTERVAL" | "INSTRUMENT_UPGRADE_POLL_INTERVAL" | "VNC_CONNECT" | "URISED_IMAGE_CAPTURE_COUNT" | "URISED_IMAGE_TRANSER_COUNT" | "URISED_INCLUDE_IMAGE_ON_REPORT" | "URISED_ONLY_IF_SEDIMENT_PRESENT" | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED" | "MANUAL_UA_AUTO_ADD" | "UA_REPORTING_UNIT_TYPE" | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS" | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT" | "CATDX_SMARTQC_REMINDER_WEEKS" | "CATDX_SMARTQC_REMINDER_DAY" | "CATDX_SMARTQC_REMINDER_HOUR" | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT" | "ESUPPORT_ENABLE_ESUPPORT" | "ESUPPORT_ESUPPORT_ACTIVATED" | "ESUPPORT_ESUPPORT_EULA_ACCEPTED" | "ESUPPORT_RUN_ENABLE_ESUPPORT" | "SMARTSERVICE_DATE" | "SMARTSERVICE_UPGRADE_DATE" | "SMARTSERVICE_OFFLINE_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME" | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "SMARTSERVICE_UPGRADE_IGNORE_COUNT" | "SMARTSERVICE_COUNTRY" | "SMARTSERVICE_LANGUAGE" | "SMARTSERVICE_REGION" | "SMARTSERVICE_UPGRADE_STATUS" | "SMARTSERVICE_OFFLINE_DATE" | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE" | "MC_SMARTSERVICE_OFFLINE_FLAG" | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES" | "MC_SMARTSERVICE_OFFLINE_TIME" | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL" | "DELTA_CONTROL_MODE" | "AUTO_BACKUPS_ENABLED" | "PPR_DISCONNECTION_DATE" | "PPR_MAX_OFFLINE_WARNING_DAYS" | "PPR_ENABLED" | "PPR_WARNING_DISPLAYED" | "PPR_MONITOR_FREQUENCY" | "PPR_REMIND_ME_LATER_DURATION_SECONDS" | "NIGHTLY_BACKUP_PATH" | "MAX_LOCAL_BACKUPS" | "DATABASES_TO_BACKUP" | "PIMS_AUTOCONNECT" | "PIMS_HISTORYDATE" | "PIMS_INTERLINK_GROUP_PORT" | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD" | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA" | "PIMS_CONNECTION_TYPE" | "PIMS_TRANSMIT_RESULTS" | "ROUTER_FIRMWARE_VERSION" | "ROUTER_MODEL_NUMBER" | "ROUTER_WAN_IP_CHOICE" | "PIMS_INTERLINK_GROUP_ADDRESS" | "PIMS_IVLS_INTEGRATION_ID" | "PIMS_IVLS_INTEGRATION_NAME" | "PIMS_IP_ADDRESS" | "ROUTER_PASSWORD" | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS" | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS">} [setting] List of settings to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      setting?: Array<
        | "AUTOMATICALLY_PRINT"
        | "AUTOPRINT_EXCEPTION_MANUALSNAP"
        | "AUTOPRINT_EXCEPTION_SNAPPRO"
        | "AUTOPRINT_DIAGNOSTIC_REPORT"
        | "BACKUP_ON_EXIT"
        | "DISPLAY_BEEP_ALERT"
        | "DISPLAY_BLINK_NEW_RESULTS"
        | "DISPLAY_CENSUSLIST"
        | "DISPLAY_CLIENT_FIRSTNAME"
        | "DISPLAY_CLIENT_LASTNAME"
        | "DISPLAY_DOCTOR_NAME"
        | "DISPLAY_ENGLISH_ASSAY_NAME"
        | "DISPLAY_PATIENT_BREED"
        | "DISPLAY_PATIENT_GENDER"
        | "DISPLAY_PATIENT_WEIGHT"
        | "DISPLAY_REASON_FOR_TESTING"
        | "DISPLAY_PENDING_REQUESTS"
        | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS"
        | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "DISPLAY_RECENT_RESULTS"
        | "DISPLAY_REQUISITION_ID"
        | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS"
        | "DISPLAY_SHOW_ALERT"
        | "ENABLE_SCOPE_LOGGING"
        | "ENABLE_STAT"
        | "FIRST_BOOT"
        | "INCLUDE_UA_PHYSICAL_EXAM"
        | "INCLUDE_UA_SEDIMENT_EXAM"
        | "PRINT_INVUE_IMAGES"
        | "PRINT_LASERCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_DOTPLOTS"
        | "PRINT_PROCYTE_ONE_DOTPLOTS"
        | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK"
        | "REQUIRE_REQUISITION_ID"
        | "RUSSIAN_SWITCH_KEY_TOGGLED"
        | "SHUTDOWN_ON_EXIT"
        | "IVLS_UPGRADE_ATTEMPTED"
        | "IVLS_UPGRADE_SUCCESS"
        | "PRINT_CHINESE_REPORT"
        | "DISPLAY_BEEP_ALERT_DURATION"
        | "DISPLAY_BLINK_NEW_RESULTS_DURATION"
        | "PRINT_LINES_FOR_LETTERHEAD"
        | "PRINT_NUMBER_OF_COPIES"
        | "CLINIC_COUNTRY"
        | "CLINIC_LANGUAGE"
        | "LAST_VIEWED_PIMS_LIST"
        | "OUT_OF_RANGE_RESULTS_HIGH"
        | "OUT_OF_RANGE_RESULTS_LOW"
        | "ABNORMAL_RESULT_COLOR"
        | "DEFAULT_PRINTER"
        | "DEFAULT_PAPER_SIZE"
        | "PRINT_HEADER_LINE_1"
        | "PRINT_HEADER_LINE_2"
        | "PRINT_HEADER_LINE_3"
        | "PRINT_HEMATOLOGY_MESSAGE_CODES"
        | "PRINT_QUALITY"
        | "PRINT_REPORT_HEADER_OPTION"
        | "PRINT_RESULT_REPORT_FORMAT"
        | "PRINT_TEST_RESULTS_ORDER"
        | "SAP_REFERENCE_NUMBER"
        | "UNIT_SYSTEM"
        | "WEIGHT_UNIT_TYPE"
        | "RECEIVE_REFLAB_RESULTS"
        | "SHOW_GREAT_NEWS"
        | "BACKUP_CATALYSTDX_ACTIVITY_LOG"
        | "BACKUP_CATALYSTDX_DATA_LOG"
        | "BACKUP_CATALYSTDX_ERROR_LOG"
        | "DEBUG_LC_ALERTS"
        | "LASERCYTE_SYNOVIAL_FLUID_REMINDER"
        | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER"
        | "INVERT_SAMPLE_REMINDER"
        | "REAGENT_LOW_REMINDER"
        | "PROCYTE_SYNOVIAL_FLUID_REMINDER"
        | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER"
        | "SNAP_CANINE3DX"
        | "SNAP_CANINE4DX"
        | "SNAP_CANINE4DXPLUS"
        | "SNAP_CANINELEISH4DX"
        | "SNAP_CANINECPL"
        | "SNAP_CANINEGIARDIA"
        | "SNAP_CANINEHEARTWORM"
        | "SNAP_CANINELEISHMANIA"
        | "SNAP_CANINELEISHMANIA2SPOT"
        | "SNAP_CANINELEPTO"
        | "SNAP_CANINEPARVO"
        | "SNAP_COMPLETIONBEEP"
        | "SNAP_ENABLETIMER"
        | "SNAP_EQUINEFOALIGG"
        | "SNAP_FELINECOMBO"
        | "SNAP_FELINECOMBOPLUS"
        | "SNAP_FELINEFBNP"
        | "SNAP_FELINEFELV"
        | "SNAP_FELINEFPL"
        | "SNAP_FELINEGIARDIA"
        | "SNAP_FELINEHEARTWORM"
        | "SNAP_FELINEHEARTWORMRT"
        | "SNAP_FELINETRIPLE"
        | "SNAP_CANINEFECAL"
        | "SNAP_FELINEFECAL"
        | "SNAP_CANINEANGIODETECT"
        | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG"
        | "BACKUP_SNAPSHOTDX_DATA_LOG"
        | "BACKUP_SNAPSHOTDX_ERROR_LOG"
        | "ALERT_WARNING_DURATION"
        | "CATALYSTDX_QC_DATA_INTERVAL"
        | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT"
        | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD"
        | "PROCYTE_MAX_REPLACE_COUNT"
        | "PROCYTE_REAGENT_LIMIT"
        | "PROCYTE_STAIN_LIMIT"
        | "PROCYTE_SW_UPGRADE_TIMEOUT"
        | "PROCYTE_UNINTENTIONAL_OFFLINE"
        | "UDO_INTERVAL"
        | "INSTRUMENT_UPGRADE_POLL_INTERVAL"
        | "VNC_CONNECT"
        | "URISED_IMAGE_CAPTURE_COUNT"
        | "URISED_IMAGE_TRANSER_COUNT"
        | "URISED_INCLUDE_IMAGE_ON_REPORT"
        | "URISED_ONLY_IF_SEDIMENT_PRESENT"
        | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED"
        | "MANUAL_UA_AUTO_ADD"
        | "UA_REPORTING_UNIT_TYPE"
        | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS"
        | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "CATDX_SMARTQC_REMINDER_WEEKS"
        | "CATDX_SMARTQC_REMINDER_DAY"
        | "CATDX_SMARTQC_REMINDER_HOUR"
        | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE"
        | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT"
        | "ESUPPORT_ENABLE_ESUPPORT"
        | "ESUPPORT_ESUPPORT_ACTIVATED"
        | "ESUPPORT_ESUPPORT_EULA_ACCEPTED"
        | "ESUPPORT_RUN_ENABLE_ESUPPORT"
        | "SMARTSERVICE_DATE"
        | "SMARTSERVICE_UPGRADE_DATE"
        | "SMARTSERVICE_OFFLINE_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME"
        | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "SMARTSERVICE_UPGRADE_IGNORE_COUNT"
        | "SMARTSERVICE_COUNTRY"
        | "SMARTSERVICE_LANGUAGE"
        | "SMARTSERVICE_REGION"
        | "SMARTSERVICE_UPGRADE_STATUS"
        | "SMARTSERVICE_OFFLINE_DATE"
        | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE"
        | "MC_SMARTSERVICE_OFFLINE_FLAG"
        | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES"
        | "MC_SMARTSERVICE_OFFLINE_TIME"
        | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL"
        | "DELTA_CONTROL_MODE"
        | "AUTO_BACKUPS_ENABLED"
        | "PPR_DISCONNECTION_DATE"
        | "PPR_MAX_OFFLINE_WARNING_DAYS"
        | "PPR_ENABLED"
        | "PPR_WARNING_DISPLAYED"
        | "PPR_MONITOR_FREQUENCY"
        | "PPR_REMIND_ME_LATER_DURATION_SECONDS"
        | "NIGHTLY_BACKUP_PATH"
        | "MAX_LOCAL_BACKUPS"
        | "DATABASES_TO_BACKUP"
        | "PIMS_AUTOCONNECT"
        | "PIMS_HISTORYDATE"
        | "PIMS_INTERLINK_GROUP_PORT"
        | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD"
        | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_TRANSMIT_RESULTS"
        | "ROUTER_FIRMWARE_VERSION"
        | "ROUTER_MODEL_NUMBER"
        | "ROUTER_WAN_IP_CHOICE"
        | "PIMS_INTERLINK_GROUP_ADDRESS"
        | "PIMS_IVLS_INTEGRATION_ID"
        | "PIMS_IVLS_INTEGRATION_NAME"
        | "PIMS_IP_ADDRESS"
        | "ROUTER_PASSWORD"
        | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS"
        | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS"
      >,
      options?: any
    ) {
      return SettingsApiFp(configuration).getSettings(setting, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Save settings. Returns a list of all modified settings.
     * @param {Array<SettingDto>} [body] List of settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveSettings(body?: Array<SettingDto>, options?: any) {
      return SettingsApiFp(configuration).saveSettings(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   *
   * @summary Get settings list.
   * @param {Array<"AUTOMATICALLY_PRINT" | "AUTOPRINT_EXCEPTION_MANUALSNAP" | "AUTOPRINT_EXCEPTION_SNAPPRO" | "AUTOPRINT_DIAGNOSTIC_REPORT" | "BACKUP_ON_EXIT" | "DISPLAY_BEEP_ALERT" | "DISPLAY_BLINK_NEW_RESULTS" | "DISPLAY_CENSUSLIST" | "DISPLAY_CLIENT_FIRSTNAME" | "DISPLAY_CLIENT_LASTNAME" | "DISPLAY_DOCTOR_NAME" | "DISPLAY_ENGLISH_ASSAY_NAME" | "DISPLAY_PATIENT_BREED" | "DISPLAY_PATIENT_GENDER" | "DISPLAY_PATIENT_WEIGHT" | "DISPLAY_REASON_FOR_TESTING" | "DISPLAY_PENDING_REQUESTS" | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS" | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "DISPLAY_RECENT_RESULTS" | "DISPLAY_REQUISITION_ID" | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS" | "DISPLAY_SHOW_ALERT" | "ENABLE_SCOPE_LOGGING" | "ENABLE_STAT" | "FIRST_BOOT" | "INCLUDE_UA_PHYSICAL_EXAM" | "INCLUDE_UA_SEDIMENT_EXAM" | "PRINT_INVUE_IMAGES" | "PRINT_LASERCYTE_DOTPLOTS" | "PRINT_PROCYTE_DOTPLOTS" | "PRINT_PROCYTE_ONE_DOTPLOTS" | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK" | "REQUIRE_REQUISITION_ID" | "RUSSIAN_SWITCH_KEY_TOGGLED" | "SHUTDOWN_ON_EXIT" | "IVLS_UPGRADE_ATTEMPTED" | "IVLS_UPGRADE_SUCCESS" | "PRINT_CHINESE_REPORT" | "DISPLAY_BEEP_ALERT_DURATION" | "DISPLAY_BLINK_NEW_RESULTS_DURATION" | "PRINT_LINES_FOR_LETTERHEAD" | "PRINT_NUMBER_OF_COPIES" | "CLINIC_COUNTRY" | "CLINIC_LANGUAGE" | "LAST_VIEWED_PIMS_LIST" | "OUT_OF_RANGE_RESULTS_HIGH" | "OUT_OF_RANGE_RESULTS_LOW" | "ABNORMAL_RESULT_COLOR" | "DEFAULT_PRINTER" | "DEFAULT_PAPER_SIZE" | "PRINT_HEADER_LINE_1" | "PRINT_HEADER_LINE_2" | "PRINT_HEADER_LINE_3" | "PRINT_HEMATOLOGY_MESSAGE_CODES" | "PRINT_QUALITY" | "PRINT_REPORT_HEADER_OPTION" | "PRINT_RESULT_REPORT_FORMAT" | "PRINT_TEST_RESULTS_ORDER" | "SAP_REFERENCE_NUMBER" | "UNIT_SYSTEM" | "WEIGHT_UNIT_TYPE" | "RECEIVE_REFLAB_RESULTS" | "SHOW_GREAT_NEWS" | "BACKUP_CATALYSTDX_ACTIVITY_LOG" | "BACKUP_CATALYSTDX_DATA_LOG" | "BACKUP_CATALYSTDX_ERROR_LOG" | "DEBUG_LC_ALERTS" | "LASERCYTE_SYNOVIAL_FLUID_REMINDER" | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER" | "INVERT_SAMPLE_REMINDER" | "REAGENT_LOW_REMINDER" | "PROCYTE_SYNOVIAL_FLUID_REMINDER" | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER" | "SNAP_CANINE3DX" | "SNAP_CANINE4DX" | "SNAP_CANINE4DXPLUS" | "SNAP_CANINELEISH4DX" | "SNAP_CANINECPL" | "SNAP_CANINEGIARDIA" | "SNAP_CANINEHEARTWORM" | "SNAP_CANINELEISHMANIA" | "SNAP_CANINELEISHMANIA2SPOT" | "SNAP_CANINELEPTO" | "SNAP_CANINEPARVO" | "SNAP_COMPLETIONBEEP" | "SNAP_ENABLETIMER" | "SNAP_EQUINEFOALIGG" | "SNAP_FELINECOMBO" | "SNAP_FELINECOMBOPLUS" | "SNAP_FELINEFBNP" | "SNAP_FELINEFELV" | "SNAP_FELINEFPL" | "SNAP_FELINEGIARDIA" | "SNAP_FELINEHEARTWORM" | "SNAP_FELINEHEARTWORMRT" | "SNAP_FELINETRIPLE" | "SNAP_CANINEFECAL" | "SNAP_FELINEFECAL" | "SNAP_CANINEANGIODETECT" | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG" | "BACKUP_SNAPSHOTDX_DATA_LOG" | "BACKUP_SNAPSHOTDX_ERROR_LOG" | "ALERT_WARNING_DURATION" | "CATALYSTDX_QC_DATA_INTERVAL" | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT" | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD" | "PROCYTE_MAX_REPLACE_COUNT" | "PROCYTE_REAGENT_LIMIT" | "PROCYTE_STAIN_LIMIT" | "PROCYTE_SW_UPGRADE_TIMEOUT" | "PROCYTE_UNINTENTIONAL_OFFLINE" | "UDO_INTERVAL" | "INSTRUMENT_UPGRADE_POLL_INTERVAL" | "VNC_CONNECT" | "URISED_IMAGE_CAPTURE_COUNT" | "URISED_IMAGE_TRANSER_COUNT" | "URISED_INCLUDE_IMAGE_ON_REPORT" | "URISED_ONLY_IF_SEDIMENT_PRESENT" | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED" | "MANUAL_UA_AUTO_ADD" | "UA_REPORTING_UNIT_TYPE" | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS" | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT" | "CATDX_SMARTQC_REMINDER_WEEKS" | "CATDX_SMARTQC_REMINDER_DAY" | "CATDX_SMARTQC_REMINDER_HOUR" | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE" | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT" | "ESUPPORT_ENABLE_ESUPPORT" | "ESUPPORT_ESUPPORT_ACTIVATED" | "ESUPPORT_ESUPPORT_EULA_ACCEPTED" | "ESUPPORT_RUN_ENABLE_ESUPPORT" | "SMARTSERVICE_DATE" | "SMARTSERVICE_UPGRADE_DATE" | "SMARTSERVICE_OFFLINE_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME" | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "SMARTSERVICE_UPGRADE_IGNORE_COUNT" | "SMARTSERVICE_COUNTRY" | "SMARTSERVICE_LANGUAGE" | "SMARTSERVICE_REGION" | "SMARTSERVICE_UPGRADE_STATUS" | "SMARTSERVICE_OFFLINE_DATE" | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE" | "MC_SMARTSERVICE_OFFLINE_FLAG" | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES" | "MC_SMARTSERVICE_OFFLINE_TIME" | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL" | "DELTA_CONTROL_MODE" | "AUTO_BACKUPS_ENABLED" | "PPR_DISCONNECTION_DATE" | "PPR_MAX_OFFLINE_WARNING_DAYS" | "PPR_ENABLED" | "PPR_WARNING_DISPLAYED" | "PPR_MONITOR_FREQUENCY" | "PPR_REMIND_ME_LATER_DURATION_SECONDS" | "NIGHTLY_BACKUP_PATH" | "MAX_LOCAL_BACKUPS" | "DATABASES_TO_BACKUP" | "PIMS_AUTOCONNECT" | "PIMS_HISTORYDATE" | "PIMS_INTERLINK_GROUP_PORT" | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD" | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA" | "PIMS_CONNECTION_TYPE" | "PIMS_TRANSMIT_RESULTS" | "ROUTER_FIRMWARE_VERSION" | "ROUTER_MODEL_NUMBER" | "ROUTER_WAN_IP_CHOICE" | "PIMS_INTERLINK_GROUP_ADDRESS" | "PIMS_IVLS_INTEGRATION_ID" | "PIMS_IVLS_INTEGRATION_NAME" | "PIMS_IP_ADDRESS" | "ROUTER_PASSWORD" | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS" | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS">} [setting] List of settings to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettings(
    setting?: Array<
      | "AUTOMATICALLY_PRINT"
      | "AUTOPRINT_EXCEPTION_MANUALSNAP"
      | "AUTOPRINT_EXCEPTION_SNAPPRO"
      | "AUTOPRINT_DIAGNOSTIC_REPORT"
      | "BACKUP_ON_EXIT"
      | "DISPLAY_BEEP_ALERT"
      | "DISPLAY_BLINK_NEW_RESULTS"
      | "DISPLAY_CENSUSLIST"
      | "DISPLAY_CLIENT_FIRSTNAME"
      | "DISPLAY_CLIENT_LASTNAME"
      | "DISPLAY_DOCTOR_NAME"
      | "DISPLAY_ENGLISH_ASSAY_NAME"
      | "DISPLAY_PATIENT_BREED"
      | "DISPLAY_PATIENT_GENDER"
      | "DISPLAY_PATIENT_WEIGHT"
      | "DISPLAY_REASON_FOR_TESTING"
      | "DISPLAY_PENDING_REQUESTS"
      | "DISPLAY_PROCYTE_INTERPRETIVE_COMMENTS"
      | "DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
      | "DISPLAY_RECENT_RESULTS"
      | "DISPLAY_REQUISITION_ID"
      | "DISPLAY_ONLY_SHOW_PATIENTS_WITH_RESULTS"
      | "DISPLAY_SHOW_ALERT"
      | "ENABLE_SCOPE_LOGGING"
      | "ENABLE_STAT"
      | "FIRST_BOOT"
      | "INCLUDE_UA_PHYSICAL_EXAM"
      | "INCLUDE_UA_SEDIMENT_EXAM"
      | "PRINT_INVUE_IMAGES"
      | "PRINT_LASERCYTE_DOTPLOTS"
      | "PRINT_PROCYTE_DOTPLOTS"
      | "PRINT_PROCYTE_ONE_DOTPLOTS"
      | "PRINT_RESULT_REPORT_NATURAL_PAGEBREAK"
      | "REQUIRE_REQUISITION_ID"
      | "RUSSIAN_SWITCH_KEY_TOGGLED"
      | "SHUTDOWN_ON_EXIT"
      | "IVLS_UPGRADE_ATTEMPTED"
      | "IVLS_UPGRADE_SUCCESS"
      | "PRINT_CHINESE_REPORT"
      | "DISPLAY_BEEP_ALERT_DURATION"
      | "DISPLAY_BLINK_NEW_RESULTS_DURATION"
      | "PRINT_LINES_FOR_LETTERHEAD"
      | "PRINT_NUMBER_OF_COPIES"
      | "CLINIC_COUNTRY"
      | "CLINIC_LANGUAGE"
      | "LAST_VIEWED_PIMS_LIST"
      | "OUT_OF_RANGE_RESULTS_HIGH"
      | "OUT_OF_RANGE_RESULTS_LOW"
      | "ABNORMAL_RESULT_COLOR"
      | "DEFAULT_PRINTER"
      | "DEFAULT_PAPER_SIZE"
      | "PRINT_HEADER_LINE_1"
      | "PRINT_HEADER_LINE_2"
      | "PRINT_HEADER_LINE_3"
      | "PRINT_HEMATOLOGY_MESSAGE_CODES"
      | "PRINT_QUALITY"
      | "PRINT_REPORT_HEADER_OPTION"
      | "PRINT_RESULT_REPORT_FORMAT"
      | "PRINT_TEST_RESULTS_ORDER"
      | "SAP_REFERENCE_NUMBER"
      | "UNIT_SYSTEM"
      | "WEIGHT_UNIT_TYPE"
      | "RECEIVE_REFLAB_RESULTS"
      | "SHOW_GREAT_NEWS"
      | "BACKUP_CATALYSTDX_ACTIVITY_LOG"
      | "BACKUP_CATALYSTDX_DATA_LOG"
      | "BACKUP_CATALYSTDX_ERROR_LOG"
      | "DEBUG_LC_ALERTS"
      | "LASERCYTE_SYNOVIAL_FLUID_REMINDER"
      | "LASERCYTEDX_SYNOVIAL_FLUID_REMINDER"
      | "INVERT_SAMPLE_REMINDER"
      | "REAGENT_LOW_REMINDER"
      | "PROCYTE_SYNOVIAL_FLUID_REMINDER"
      | "PROCYTE_ONE_INVERT_SAMPLE_REMINDER"
      | "SNAP_CANINE3DX"
      | "SNAP_CANINE4DX"
      | "SNAP_CANINE4DXPLUS"
      | "SNAP_CANINELEISH4DX"
      | "SNAP_CANINECPL"
      | "SNAP_CANINEGIARDIA"
      | "SNAP_CANINEHEARTWORM"
      | "SNAP_CANINELEISHMANIA"
      | "SNAP_CANINELEISHMANIA2SPOT"
      | "SNAP_CANINELEPTO"
      | "SNAP_CANINEPARVO"
      | "SNAP_COMPLETIONBEEP"
      | "SNAP_ENABLETIMER"
      | "SNAP_EQUINEFOALIGG"
      | "SNAP_FELINECOMBO"
      | "SNAP_FELINECOMBOPLUS"
      | "SNAP_FELINEFBNP"
      | "SNAP_FELINEFELV"
      | "SNAP_FELINEFPL"
      | "SNAP_FELINEGIARDIA"
      | "SNAP_FELINEHEARTWORM"
      | "SNAP_FELINEHEARTWORMRT"
      | "SNAP_FELINETRIPLE"
      | "SNAP_CANINEFECAL"
      | "SNAP_FELINEFECAL"
      | "SNAP_CANINEANGIODETECT"
      | "BACKUP_SNAPSHOTDX_ACTIVITY_LOG"
      | "BACKUP_SNAPSHOTDX_DATA_LOG"
      | "BACKUP_SNAPSHOTDX_ERROR_LOG"
      | "ALERT_WARNING_DURATION"
      | "CATALYSTDX_QC_DATA_INTERVAL"
      | "INSTRUMENT_UPGRADE_NEXT_OFFER_WAIT"
      | "PROCYTE_COMMUNICATION_ERROR_THRESHOLD"
      | "PROCYTE_MAX_REPLACE_COUNT"
      | "PROCYTE_REAGENT_LIMIT"
      | "PROCYTE_STAIN_LIMIT"
      | "PROCYTE_SW_UPGRADE_TIMEOUT"
      | "PROCYTE_UNINTENTIONAL_OFFLINE"
      | "UDO_INTERVAL"
      | "INSTRUMENT_UPGRADE_POLL_INTERVAL"
      | "VNC_CONNECT"
      | "URISED_IMAGE_CAPTURE_COUNT"
      | "URISED_IMAGE_TRANSER_COUNT"
      | "URISED_INCLUDE_IMAGE_ON_REPORT"
      | "URISED_ONLY_IF_SEDIMENT_PRESENT"
      | "URISYS_DX_SAMPLE_PREP_INSTRUCTIONS_ENABLED"
      | "MANUAL_UA_AUTO_ADD"
      | "UA_REPORTING_UNIT_TYPE"
      | "THEIA_MAX_DIQ_WAIT_TIME_SECONDS"
      | "THEIA_DIQ_NOTIFICATION_WAIT_TIME_SECONDS"
      | "CATONE_SMARTQC_REMINDER_WEEKS"
      | "CATONE_SMARTQC_REMINDER_DAY"
      | "CATONE_SMARTQC_REMINDER_HOUR"
      | "CATONE_SMARTQC_NEXT_NOTIFICATION_DATE"
      | "CATONE_SMARTQC_REMINDER_DEFERRAL_COUNT"
      | "CATDX_SMARTQC_REMINDER_WEEKS"
      | "CATDX_SMARTQC_REMINDER_DAY"
      | "CATDX_SMARTQC_REMINDER_HOUR"
      | "CATDX_SMARTQC_NEXT_NOTIFICATION_DATE"
      | "CATDX_SMARTQC_REMINDER_DEFERRAL_COUNT"
      | "ESUPPORT_ENABLE_ESUPPORT"
      | "ESUPPORT_ESUPPORT_ACTIVATED"
      | "ESUPPORT_ESUPPORT_EULA_ACCEPTED"
      | "ESUPPORT_RUN_ENABLE_ESUPPORT"
      | "SMARTSERVICE_DATE"
      | "SMARTSERVICE_UPGRADE_DATE"
      | "SMARTSERVICE_OFFLINE_TIME"
      | "SMARTSERVICE_ALTERNATE_OFFLINE_TIME"
      | "SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
      | "SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
      | "SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
      | "SMARTSERVICE_UPGRADE_IGNORE_COUNT"
      | "SMARTSERVICE_COUNTRY"
      | "SMARTSERVICE_LANGUAGE"
      | "SMARTSERVICE_REGION"
      | "SMARTSERVICE_UPGRADE_STATUS"
      | "SMARTSERVICE_OFFLINE_DATE"
      | "SMARTSERVICE_SHOW_OFFLINE_NOTIFICATION_DATE"
      | "MC_SMARTSERVICE_OFFLINE_FLAG"
      | "MC_SMARTSERVICE_OFFLINE_WAIT_NOTIFICATION_IN_MINUTES"
      | "MC_SMARTSERVICE_OFFLINE_TIME"
      | "MC_SMARTSERVICE_NOTIFICATION_INTERVAL"
      | "DELTA_CONTROL_MODE"
      | "AUTO_BACKUPS_ENABLED"
      | "PPR_DISCONNECTION_DATE"
      | "PPR_MAX_OFFLINE_WARNING_DAYS"
      | "PPR_ENABLED"
      | "PPR_WARNING_DISPLAYED"
      | "PPR_MONITOR_FREQUENCY"
      | "PPR_REMIND_ME_LATER_DURATION_SECONDS"
      | "NIGHTLY_BACKUP_PATH"
      | "MAX_LOCAL_BACKUPS"
      | "DATABASES_TO_BACKUP"
      | "PIMS_AUTOCONNECT"
      | "PIMS_HISTORYDATE"
      | "PIMS_INTERLINK_GROUP_PORT"
      | "PIMS_WINDOWS_STARTUP_WAIT_PERIOD"
      | "PIMS_AGREED_TO_THIRD_PARTY_PIMS_EULA"
      | "PIMS_CONNECTION_TYPE"
      | "PIMS_TRANSMIT_RESULTS"
      | "ROUTER_FIRMWARE_VERSION"
      | "ROUTER_MODEL_NUMBER"
      | "ROUTER_WAN_IP_CHOICE"
      | "PIMS_INTERLINK_GROUP_ADDRESS"
      | "PIMS_IVLS_INTEGRATION_ID"
      | "PIMS_IVLS_INTEGRATION_NAME"
      | "PIMS_IP_ADDRESS"
      | "ROUTER_PASSWORD"
      | "REFERENCE_LAB_RESULT_POLLING_INTERVAL_SECONDS"
      | "REFERENCE_LAB_RESULT_POLLING_WINDOW_HOURS"
    >,
    options?: any
  ) {
    return SettingsApiFp(this.configuration).getSettings(setting, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Save settings. Returns a list of all modified settings.
   * @param {Array<SettingDto>} [body] List of settings to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public saveSettings(body?: Array<SettingDto>, options?: any) {
    return SettingsApiFp(this.configuration).saveSettings(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * SmartServiceAgentApi - fetch parameter creator
 * @export
 */
export const SmartServiceAgentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Activate SmartService.
     * @param {SmartServiceEulaDto} [body] The accepted SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(body?: SmartServiceEulaDto, options: any = {}): FetchArgs {
      const localVarPath = `/smartService/activate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SmartServiceEulaDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Decline the SmartService Eula.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decline(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/decline`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Disable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/disable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Enable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/enable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the SmartService status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reschedule SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleOfflineNotification(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/offlineNotification/reschedule`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reset SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetOfflineNotificationStatus(options: any = {}): FetchArgs {
      const localVarPath = `/smartService/offlineNotification/reset`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SmartServiceAgentApi - functional programming interface
 * @export
 */
export const SmartServiceAgentApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Activate SmartService.
     * @param {SmartServiceEulaDto} [body] The accepted SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(
      body?: SmartServiceEulaDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SmartServiceAgentApiFetchParamCreator(
        configuration
      ).activate(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Decline the SmartService Eula.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decline(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(configuration).decline(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Disable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(configuration).disable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Enable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(configuration).enable(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the SmartService status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(configuration).fetchStatus(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Reschedule SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleOfflineNotification(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(
          configuration
        ).rescheduleOfflineNotification(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Reset SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetOfflineNotificationStatus(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceAgentApiFetchParamCreator(
          configuration
        ).resetOfflineNotificationStatus(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SmartServiceAgentApi - factory interface
 * @export
 */
export const SmartServiceAgentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Activate SmartService.
     * @param {SmartServiceEulaDto} [body] The accepted SmartService EULA.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(body?: SmartServiceEulaDto, options?: any) {
      return SmartServiceAgentApiFp(configuration).activate(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Decline the SmartService Eula.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decline(options?: any) {
      return SmartServiceAgentApiFp(configuration).decline(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Disable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disable(options?: any) {
      return SmartServiceAgentApiFp(configuration).disable(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Enable SmartService.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enable(options?: any) {
      return SmartServiceAgentApiFp(configuration).enable(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the SmartService status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchStatus(options?: any) {
      return SmartServiceAgentApiFp(configuration).fetchStatus(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Reschedule SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleOfflineNotification(options?: any) {
      return SmartServiceAgentApiFp(
        configuration
      ).rescheduleOfflineNotification(options)(fetch, basePath);
    },
    /**
     *
     * @summary Reset SmartService offline notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetOfflineNotificationStatus(options?: any) {
      return SmartServiceAgentApiFp(
        configuration
      ).resetOfflineNotificationStatus(options)(fetch, basePath);
    },
  };
};

/**
 * SmartServiceAgentApi - object-oriented interface
 * @export
 * @class SmartServiceAgentApi
 * @extends {BaseAPI}
 */
export class SmartServiceAgentApi extends BaseAPI {
  /**
   *
   * @summary Activate SmartService.
   * @param {SmartServiceEulaDto} [body] The accepted SmartService EULA.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public activate(body?: SmartServiceEulaDto, options?: any) {
    return SmartServiceAgentApiFp(this.configuration).activate(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Decline the SmartService Eula.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public decline(options?: any) {
    return SmartServiceAgentApiFp(this.configuration).decline(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Disable SmartService.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public disable(options?: any) {
    return SmartServiceAgentApiFp(this.configuration).disable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Enable SmartService.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public enable(options?: any) {
    return SmartServiceAgentApiFp(this.configuration).enable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the SmartService status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public fetchStatus(options?: any) {
    return SmartServiceAgentApiFp(this.configuration).fetchStatus(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Reschedule SmartService offline notification.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public rescheduleOfflineNotification(options?: any) {
    return SmartServiceAgentApiFp(
      this.configuration
    ).rescheduleOfflineNotification(options)(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Reset SmartService offline notification.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceAgentApi
   */
  public resetOfflineNotificationStatus(options?: any) {
    return SmartServiceAgentApiFp(
      this.configuration
    ).resetOfflineNotificationStatus(options)(this.fetch, this.basePath);
  }
}

/**
 * SmartServiceBackupApi - fetch parameter creator
 * @export
 */
export const SmartServiceBackupApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Asynchronous endpoint called by the SS agent when a restore package is ready
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    asyncRestoreReady(options: any = {}): FetchArgs {
      const localVarPath = `/ssbackup/async/restore`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a backup has been created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    backupCompleted(options: any = {}): FetchArgs {
      const localVarPath = `/ssbackup/async/backup/full`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the flat file data that IVLS wants included in backups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFlatFiles(options: any = {}): FetchArgs {
      const localVarPath = `/ssbackup/flatfiles`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current IVLS SmartService API settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(options: any = {}): FetchArgs {
      const localVarPath = `/ssbackup/configuration`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary The agent will call this endpoint in response to a CSR initiated restore request
     * @param {string} [restoreEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoteRestore(
      restoreEventId?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ssbackup/restore/remote`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (restoreEventId !== undefined) {
        localVarQueryParameter["restoreEventId"] = restoreEventId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the IVLS SmartService API settings
     * @param {SmartServiceApiConfigurationDto} [body] The new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      body?: SmartServiceApiConfigurationDto,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/ssbackup/configuration`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SmartServiceApiConfigurationDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SmartServiceBackupApi - functional programming interface
 * @export
 */
export const SmartServiceBackupApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Asynchronous endpoint called by the SS agent when a restore package is ready
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    asyncRestoreReady(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceBackupApiFetchParamCreator(configuration).asyncRestoreReady(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a backup has been created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    backupCompleted(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceBackupApiFetchParamCreator(configuration).backupCompleted(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the flat file data that IVLS wants included in backups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFlatFiles(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FlatFileDto>> {
      const localVarFetchArgs =
        SmartServiceBackupApiFetchParamCreator(configuration).fetchFlatFiles(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the current IVLS SmartService API settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<SmartServiceApiConfigurationDto> {
      const localVarFetchArgs =
        SmartServiceBackupApiFetchParamCreator(configuration).getConfiguration(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary The agent will call this endpoint in response to a CSR initiated restore request
     * @param {string} [restoreEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoteRestore(
      restoreEventId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SmartServiceBackupApiFetchParamCreator(
        configuration
      ).requestRemoteRestore(restoreEventId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the IVLS SmartService API settings
     * @param {SmartServiceApiConfigurationDto} [body] The new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      body?: SmartServiceApiConfigurationDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SmartServiceBackupApiFetchParamCreator(
        configuration
      ).updateConfiguration(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SmartServiceBackupApi - factory interface
 * @export
 */
export const SmartServiceBackupApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Asynchronous endpoint called by the SS agent when a restore package is ready
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    asyncRestoreReady(options?: any) {
      return SmartServiceBackupApiFp(configuration).asyncRestoreReady(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a backup has been created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    backupCompleted(options?: any) {
      return SmartServiceBackupApiFp(configuration).backupCompleted(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the flat file data that IVLS wants included in backups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFlatFiles(options?: any) {
      return SmartServiceBackupApiFp(configuration).fetchFlatFiles(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the current IVLS SmartService API settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(options?: any) {
      return SmartServiceBackupApiFp(configuration).getConfiguration(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary The agent will call this endpoint in response to a CSR initiated restore request
     * @param {string} [restoreEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoteRestore(restoreEventId?: string, options?: any) {
      return SmartServiceBackupApiFp(configuration).requestRemoteRestore(
        restoreEventId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the IVLS SmartService API settings
     * @param {SmartServiceApiConfigurationDto} [body] The new configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(body?: SmartServiceApiConfigurationDto, options?: any) {
      return SmartServiceBackupApiFp(configuration).updateConfiguration(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SmartServiceBackupApi - object-oriented interface
 * @export
 * @class SmartServiceBackupApi
 * @extends {BaseAPI}
 */
export class SmartServiceBackupApi extends BaseAPI {
  /**
   *
   * @summary Asynchronous endpoint called by the SS agent when a restore package is ready
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public asyncRestoreReady(options?: any) {
    return SmartServiceBackupApiFp(this.configuration).asyncRestoreReady(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Asynchronous callback endpoint for the Agent to post once a backup has been created
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public backupCompleted(options?: any) {
    return SmartServiceBackupApiFp(this.configuration).backupCompleted(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the flat file data that IVLS wants included in backups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public fetchFlatFiles(options?: any) {
    return SmartServiceBackupApiFp(this.configuration).fetchFlatFiles(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the current IVLS SmartService API settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public getConfiguration(options?: any) {
    return SmartServiceBackupApiFp(this.configuration).getConfiguration(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary The agent will call this endpoint in response to a CSR initiated restore request
   * @param {string} [restoreEventId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public requestRemoteRestore(restoreEventId?: string, options?: any) {
    return SmartServiceBackupApiFp(this.configuration).requestRemoteRestore(
      restoreEventId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the IVLS SmartService API settings
   * @param {SmartServiceApiConfigurationDto} [body] The new configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceBackupApi
   */
  public updateConfiguration(
    body?: SmartServiceApiConfigurationDto,
    options?: any
  ) {
    return SmartServiceBackupApiFp(this.configuration).updateConfiguration(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SmartServiceFileUploadApi - fetch parameter creator
 * @export
 */
export const SmartServiceFileUploadApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a file upload is completed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUploadCompleted(options: any = {}): FetchArgs {
      const localVarPath = `/ssfileupload/async/fileupload`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SmartServiceFileUploadApi - functional programming interface
 * @export
 */
export const SmartServiceFileUploadApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a file upload is completed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUploadCompleted(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SmartServiceFileUploadApiFetchParamCreator(
          configuration
        ).fileUploadCompleted(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SmartServiceFileUploadApi - factory interface
 * @export
 */
export const SmartServiceFileUploadApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Asynchronous callback endpoint for the Agent to post once a file upload is completed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUploadCompleted(options?: any) {
      return SmartServiceFileUploadApiFp(configuration).fileUploadCompleted(
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SmartServiceFileUploadApi - object-oriented interface
 * @export
 * @class SmartServiceFileUploadApi
 * @extends {BaseAPI}
 */
export class SmartServiceFileUploadApi extends BaseAPI {
  /**
   *
   * @summary Asynchronous callback endpoint for the Agent to post once a file upload is completed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceFileUploadApi
   */
  public fileUploadCompleted(options?: any) {
    return SmartServiceFileUploadApiFp(this.configuration).fileUploadCompleted(
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SmartServiceIntegrationApi - fetch parameter creator
 * @export
 */
export const SmartServiceIntegrationApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch all SmartService properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(options: any = {}): FetchArgs {
      const localVarPath = `/ss/properties`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get SmartService property by ID.
     * @param {"IVLS_DEVICE_TYPE" | "IVLS_DATABASE_SIZE" | "IVLS_DATABASE_VERSION" | "IVLS_LAST_RUN_DATE" | "IVLS_COUNTRY" | "IVLS_LANGUAGE" | "IVLS_SOFTWARE_VERSION" | "VPC_CLIENT_VERSION" | "VPC_CLIENT_ENABLED" | "VPC_CLIENT_STARTED" | "CATALYST_DX_CURVES_VERSION" | "CATALYST_DX_IP_ADDRESS" | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE" | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER" | "CATALYST_DX_LAST_RUN_DATE" | "CATALYST_DX_QC_EXPIRATION_DATE" | "CATALYST_DX_QC_VERSION" | "CATALYST_DX_SERIAL_NUMBER" | "CATALYST_DX_SOFTWARE_VERSION" | "CATALYST_DX_UPTIME" | "CATALYST_DX_SMARTQC_REMINDER_WEEKS" | "CATALYST_DX_SMARTQC_REMINDER_DAY" | "CATALYST_DX_SMARTQC_REMINDER_HOUR" | "CATONE_CURVES_VERSION" | "CATONE_IP_ADDRESS" | "CATONE_LAST_QC_RUN_DAYS_SINCE" | "CATONE_LAST_QC_RUN_EXPIRATION_DATE" | "CATONE_LAST_QC_RUN_LOT_NUMBER" | "CATONE_LAST_RUN_DATE" | "CATONE_SERIAL_NUMBER" | "CATONE_SOFTWARE_VERSION" | "CATONE_UPTIME" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "COAG_DX_ALL" | "COAG_DX_IP_ADDRESS" | "COAG_DX_SERIAL_NUMBER" | "COAG_DX_SOFTWARE_VERSION" | "COAG_DX_UPTIME" | "LASERCYTE_LAST_RUN_DATE" | "LASERCYTE_SERIAL_NUMBER" | "LASERCYTE_SOFTWARE_VERSION" | "LASERCYTE_DX_LAST_RUN_DATE" | "LASERCYTE_DX_SERIAL_NUMBER" | "LASERCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_IP_ADDRESS" | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE" | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER" | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE" | "PROCYTE_DX_LAST_RUN_DATE" | "PROCYTE_DX_QC_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE" | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER" | "PROCYTE_DX_SERIAL_NUMBER" | "PROCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE" | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE" | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER" | "PROCYTE_DX_UPTIME" | "PROCYTE_DX_SAMPLE_INVERT_REMINDER" | "PROCYTE_ONE_SOFTWARE_VERSION" | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER" | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE" | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER" | "SEDIVUE_DX_QC_EXPIRATION_DATE" | "SEDIVUE_DX_SOFTWARE_VERSION" | "SNAPPRO_IP_ADDRESS" | "SNAPPRO_LAST_RUN_DATE" | "SNAPPRO_SERIAL_NUMBER" | "SNAPPRO_SOFTWARE_VERSION" | "SNAPSHOT_DX_IP_ADDRESS" | "SNAPSHOT_DX_LAST_RUN_DATE" | "SNAPSHOT_DX_SERIAL_NUMBER" | "SNAPSHOT_DX_SOFTWARE_VERSION" | "SNAPSHOT_DX_UPTIME" | "UA_NEXT_GEN_REPORTING_UNITS" | "UA_NEXT_GEN_SOFTWARE_VERSION" | "UA_NEXT_GEN_IP_ADDRESS" | "UA_NEXT_GEN_SERIAL_NUMBER" | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE" | "UA_NEXT_GEN_LAST_RUN_DATE" | "VETSTAT_SERIAL_NUMBER" | "VETSTAT_LAST_RUN_DATE" | "VETSTAT_LAST_RUN_SOFTWARE_VERSION" | "IVLS_ANTENNAS_STATUS" | "IVLS_ROUTER_FIRMWARE_VERSION" | "IVLS_ROUTER_MODEL" | "IVLS_ROUTER_WAN_IP_TYPE" | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD" | "IVLS_ROUTER_PASSWORD_CHANGE_DATE" | "IVLS_SSID_PASSWORD" | "IVLS_DEFAULT_GATEWAY" | "IVLS_PRIMARY_DNS" | "IVLS_SECONDARY_DNS" | "IVLS_IP_ADDRESS" | "IVLS_SUBNET_MASK" | "IVLS_PRINTER_MODEL" | "IVLS_PRINTER_PRINT_QUALITY" | "IVLS_UNITS_SYSTEM" | "IVLS_DELTA_CONTROL_MODE" | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME" | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME" | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "IVLS_UPGRADE_COMPLETE_DATETIME" | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT" | "IVLS_UPGRADE_USER_PROMPT_STATUS" | "PIMS_CONNECTION_STATUS" | "PIMS_CONNECTION_TYPE" | "PIMS_INTEGRATION_NAME" | "PIMS_SERIAL_NUMBER" | "VCP_CONNECTION_STATUS" | "IVLS_PRINTER_PAPER_SIZE" | "IVLS_PRINT_LASERCYTE_DOTPLOTS" | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS" | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS" | "IVLS_OS_TIMEZONE" | "IVLS_APPLICATION_TIMEZONE" | "IVLS_DST_STATUS" | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS" | "IVLS_ABNORMAL_RESULT_COLOR" | "IVLS_DISPLAY_REASON_FOR_TESTING"} propertyId The SmartService property ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertyById(
      propertyId:
        | "IVLS_DEVICE_TYPE"
        | "IVLS_DATABASE_SIZE"
        | "IVLS_DATABASE_VERSION"
        | "IVLS_LAST_RUN_DATE"
        | "IVLS_COUNTRY"
        | "IVLS_LANGUAGE"
        | "IVLS_SOFTWARE_VERSION"
        | "VPC_CLIENT_VERSION"
        | "VPC_CLIENT_ENABLED"
        | "VPC_CLIENT_STARTED"
        | "CATALYST_DX_CURVES_VERSION"
        | "CATALYST_DX_IP_ADDRESS"
        | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE"
        | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER"
        | "CATALYST_DX_LAST_RUN_DATE"
        | "CATALYST_DX_QC_EXPIRATION_DATE"
        | "CATALYST_DX_QC_VERSION"
        | "CATALYST_DX_SERIAL_NUMBER"
        | "CATALYST_DX_SOFTWARE_VERSION"
        | "CATALYST_DX_UPTIME"
        | "CATALYST_DX_SMARTQC_REMINDER_WEEKS"
        | "CATALYST_DX_SMARTQC_REMINDER_DAY"
        | "CATALYST_DX_SMARTQC_REMINDER_HOUR"
        | "CATONE_CURVES_VERSION"
        | "CATONE_IP_ADDRESS"
        | "CATONE_LAST_QC_RUN_DAYS_SINCE"
        | "CATONE_LAST_QC_RUN_EXPIRATION_DATE"
        | "CATONE_LAST_QC_RUN_LOT_NUMBER"
        | "CATONE_LAST_RUN_DATE"
        | "CATONE_SERIAL_NUMBER"
        | "CATONE_SOFTWARE_VERSION"
        | "CATONE_UPTIME"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "COAG_DX_ALL"
        | "COAG_DX_IP_ADDRESS"
        | "COAG_DX_SERIAL_NUMBER"
        | "COAG_DX_SOFTWARE_VERSION"
        | "COAG_DX_UPTIME"
        | "LASERCYTE_LAST_RUN_DATE"
        | "LASERCYTE_SERIAL_NUMBER"
        | "LASERCYTE_SOFTWARE_VERSION"
        | "LASERCYTE_DX_LAST_RUN_DATE"
        | "LASERCYTE_DX_SERIAL_NUMBER"
        | "LASERCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_IP_ADDRESS"
        | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE"
        | "PROCYTE_DX_LAST_RUN_DATE"
        | "PROCYTE_DX_QC_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE"
        | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER"
        | "PROCYTE_DX_SERIAL_NUMBER"
        | "PROCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE"
        | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE"
        | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER"
        | "PROCYTE_DX_UPTIME"
        | "PROCYTE_DX_SAMPLE_INVERT_REMINDER"
        | "PROCYTE_ONE_SOFTWARE_VERSION"
        | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER"
        | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "SEDIVUE_DX_QC_EXPIRATION_DATE"
        | "SEDIVUE_DX_SOFTWARE_VERSION"
        | "SNAPPRO_IP_ADDRESS"
        | "SNAPPRO_LAST_RUN_DATE"
        | "SNAPPRO_SERIAL_NUMBER"
        | "SNAPPRO_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_IP_ADDRESS"
        | "SNAPSHOT_DX_LAST_RUN_DATE"
        | "SNAPSHOT_DX_SERIAL_NUMBER"
        | "SNAPSHOT_DX_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_UPTIME"
        | "UA_NEXT_GEN_REPORTING_UNITS"
        | "UA_NEXT_GEN_SOFTWARE_VERSION"
        | "UA_NEXT_GEN_IP_ADDRESS"
        | "UA_NEXT_GEN_SERIAL_NUMBER"
        | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE"
        | "UA_NEXT_GEN_LAST_RUN_DATE"
        | "VETSTAT_SERIAL_NUMBER"
        | "VETSTAT_LAST_RUN_DATE"
        | "VETSTAT_LAST_RUN_SOFTWARE_VERSION"
        | "IVLS_ANTENNAS_STATUS"
        | "IVLS_ROUTER_FIRMWARE_VERSION"
        | "IVLS_ROUTER_MODEL"
        | "IVLS_ROUTER_WAN_IP_TYPE"
        | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD"
        | "IVLS_ROUTER_PASSWORD_CHANGE_DATE"
        | "IVLS_SSID_PASSWORD"
        | "IVLS_DEFAULT_GATEWAY"
        | "IVLS_PRIMARY_DNS"
        | "IVLS_SECONDARY_DNS"
        | "IVLS_IP_ADDRESS"
        | "IVLS_SUBNET_MASK"
        | "IVLS_PRINTER_MODEL"
        | "IVLS_PRINTER_PRINT_QUALITY"
        | "IVLS_UNITS_SYSTEM"
        | "IVLS_DELTA_CONTROL_MODE"
        | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_UPGRADE_COMPLETE_DATETIME"
        | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT"
        | "IVLS_UPGRADE_USER_PROMPT_STATUS"
        | "PIMS_CONNECTION_STATUS"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_INTEGRATION_NAME"
        | "PIMS_SERIAL_NUMBER"
        | "VCP_CONNECTION_STATUS"
        | "IVLS_PRINTER_PAPER_SIZE"
        | "IVLS_PRINT_LASERCYTE_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS"
        | "IVLS_OS_TIMEZONE"
        | "IVLS_APPLICATION_TIMEZONE"
        | "IVLS_DST_STATUS"
        | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS"
        | "IVLS_ABNORMAL_RESULT_COLOR"
        | "IVLS_DISPLAY_REASON_FOR_TESTING",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'propertyId' is not null or undefined
      if (propertyId === null || propertyId === undefined) {
        throw new RequiredError(
          "propertyId",
          "Required parameter propertyId was null or undefined when calling fetchPropertyById."
        );
      }
      const localVarPath = `/ss/properties/{propertyId}`.replace(
        `{${"propertyId"}}`,
        encodeURIComponent(String(propertyId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit a PIMS XML message for processing by IVLS
     * @param {PimsXmlMessageDto} body The Pims XML Message to process.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processPimsMessage(body: PimsXmlMessageDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling processPimsMessage."
        );
      }
      const localVarPath = `/ss/pimsMessage`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"PimsXmlMessageDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save properties for SmartService.
     * @param {SmartServicePropertiesDto} body The SmartService properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(
      body: SmartServicePropertiesDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveProperties."
        );
      }
      const localVarPath = `/ss/properties`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SmartServicePropertiesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SmartServiceIntegrationApi - functional programming interface
 * @export
 */
export const SmartServiceIntegrationApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch all SmartService properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<SmartServicePropertiesDto> {
      const localVarFetchArgs =
        SmartServiceIntegrationApiFetchParamCreator(
          configuration
        ).fetchProperties(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get SmartService property by ID.
     * @param {"IVLS_DEVICE_TYPE" | "IVLS_DATABASE_SIZE" | "IVLS_DATABASE_VERSION" | "IVLS_LAST_RUN_DATE" | "IVLS_COUNTRY" | "IVLS_LANGUAGE" | "IVLS_SOFTWARE_VERSION" | "VPC_CLIENT_VERSION" | "VPC_CLIENT_ENABLED" | "VPC_CLIENT_STARTED" | "CATALYST_DX_CURVES_VERSION" | "CATALYST_DX_IP_ADDRESS" | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE" | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER" | "CATALYST_DX_LAST_RUN_DATE" | "CATALYST_DX_QC_EXPIRATION_DATE" | "CATALYST_DX_QC_VERSION" | "CATALYST_DX_SERIAL_NUMBER" | "CATALYST_DX_SOFTWARE_VERSION" | "CATALYST_DX_UPTIME" | "CATALYST_DX_SMARTQC_REMINDER_WEEKS" | "CATALYST_DX_SMARTQC_REMINDER_DAY" | "CATALYST_DX_SMARTQC_REMINDER_HOUR" | "CATONE_CURVES_VERSION" | "CATONE_IP_ADDRESS" | "CATONE_LAST_QC_RUN_DAYS_SINCE" | "CATONE_LAST_QC_RUN_EXPIRATION_DATE" | "CATONE_LAST_QC_RUN_LOT_NUMBER" | "CATONE_LAST_RUN_DATE" | "CATONE_SERIAL_NUMBER" | "CATONE_SOFTWARE_VERSION" | "CATONE_UPTIME" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "COAG_DX_ALL" | "COAG_DX_IP_ADDRESS" | "COAG_DX_SERIAL_NUMBER" | "COAG_DX_SOFTWARE_VERSION" | "COAG_DX_UPTIME" | "LASERCYTE_LAST_RUN_DATE" | "LASERCYTE_SERIAL_NUMBER" | "LASERCYTE_SOFTWARE_VERSION" | "LASERCYTE_DX_LAST_RUN_DATE" | "LASERCYTE_DX_SERIAL_NUMBER" | "LASERCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_IP_ADDRESS" | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE" | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER" | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE" | "PROCYTE_DX_LAST_RUN_DATE" | "PROCYTE_DX_QC_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE" | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER" | "PROCYTE_DX_SERIAL_NUMBER" | "PROCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE" | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE" | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER" | "PROCYTE_DX_UPTIME" | "PROCYTE_DX_SAMPLE_INVERT_REMINDER" | "PROCYTE_ONE_SOFTWARE_VERSION" | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER" | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE" | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER" | "SEDIVUE_DX_QC_EXPIRATION_DATE" | "SEDIVUE_DX_SOFTWARE_VERSION" | "SNAPPRO_IP_ADDRESS" | "SNAPPRO_LAST_RUN_DATE" | "SNAPPRO_SERIAL_NUMBER" | "SNAPPRO_SOFTWARE_VERSION" | "SNAPSHOT_DX_IP_ADDRESS" | "SNAPSHOT_DX_LAST_RUN_DATE" | "SNAPSHOT_DX_SERIAL_NUMBER" | "SNAPSHOT_DX_SOFTWARE_VERSION" | "SNAPSHOT_DX_UPTIME" | "UA_NEXT_GEN_REPORTING_UNITS" | "UA_NEXT_GEN_SOFTWARE_VERSION" | "UA_NEXT_GEN_IP_ADDRESS" | "UA_NEXT_GEN_SERIAL_NUMBER" | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE" | "UA_NEXT_GEN_LAST_RUN_DATE" | "VETSTAT_SERIAL_NUMBER" | "VETSTAT_LAST_RUN_DATE" | "VETSTAT_LAST_RUN_SOFTWARE_VERSION" | "IVLS_ANTENNAS_STATUS" | "IVLS_ROUTER_FIRMWARE_VERSION" | "IVLS_ROUTER_MODEL" | "IVLS_ROUTER_WAN_IP_TYPE" | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD" | "IVLS_ROUTER_PASSWORD_CHANGE_DATE" | "IVLS_SSID_PASSWORD" | "IVLS_DEFAULT_GATEWAY" | "IVLS_PRIMARY_DNS" | "IVLS_SECONDARY_DNS" | "IVLS_IP_ADDRESS" | "IVLS_SUBNET_MASK" | "IVLS_PRINTER_MODEL" | "IVLS_PRINTER_PRINT_QUALITY" | "IVLS_UNITS_SYSTEM" | "IVLS_DELTA_CONTROL_MODE" | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME" | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME" | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "IVLS_UPGRADE_COMPLETE_DATETIME" | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT" | "IVLS_UPGRADE_USER_PROMPT_STATUS" | "PIMS_CONNECTION_STATUS" | "PIMS_CONNECTION_TYPE" | "PIMS_INTEGRATION_NAME" | "PIMS_SERIAL_NUMBER" | "VCP_CONNECTION_STATUS" | "IVLS_PRINTER_PAPER_SIZE" | "IVLS_PRINT_LASERCYTE_DOTPLOTS" | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS" | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS" | "IVLS_OS_TIMEZONE" | "IVLS_APPLICATION_TIMEZONE" | "IVLS_DST_STATUS" | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS" | "IVLS_ABNORMAL_RESULT_COLOR" | "IVLS_DISPLAY_REASON_FOR_TESTING"} propertyId The SmartService property ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertyById(
      propertyId:
        | "IVLS_DEVICE_TYPE"
        | "IVLS_DATABASE_SIZE"
        | "IVLS_DATABASE_VERSION"
        | "IVLS_LAST_RUN_DATE"
        | "IVLS_COUNTRY"
        | "IVLS_LANGUAGE"
        | "IVLS_SOFTWARE_VERSION"
        | "VPC_CLIENT_VERSION"
        | "VPC_CLIENT_ENABLED"
        | "VPC_CLIENT_STARTED"
        | "CATALYST_DX_CURVES_VERSION"
        | "CATALYST_DX_IP_ADDRESS"
        | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE"
        | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER"
        | "CATALYST_DX_LAST_RUN_DATE"
        | "CATALYST_DX_QC_EXPIRATION_DATE"
        | "CATALYST_DX_QC_VERSION"
        | "CATALYST_DX_SERIAL_NUMBER"
        | "CATALYST_DX_SOFTWARE_VERSION"
        | "CATALYST_DX_UPTIME"
        | "CATALYST_DX_SMARTQC_REMINDER_WEEKS"
        | "CATALYST_DX_SMARTQC_REMINDER_DAY"
        | "CATALYST_DX_SMARTQC_REMINDER_HOUR"
        | "CATONE_CURVES_VERSION"
        | "CATONE_IP_ADDRESS"
        | "CATONE_LAST_QC_RUN_DAYS_SINCE"
        | "CATONE_LAST_QC_RUN_EXPIRATION_DATE"
        | "CATONE_LAST_QC_RUN_LOT_NUMBER"
        | "CATONE_LAST_RUN_DATE"
        | "CATONE_SERIAL_NUMBER"
        | "CATONE_SOFTWARE_VERSION"
        | "CATONE_UPTIME"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "COAG_DX_ALL"
        | "COAG_DX_IP_ADDRESS"
        | "COAG_DX_SERIAL_NUMBER"
        | "COAG_DX_SOFTWARE_VERSION"
        | "COAG_DX_UPTIME"
        | "LASERCYTE_LAST_RUN_DATE"
        | "LASERCYTE_SERIAL_NUMBER"
        | "LASERCYTE_SOFTWARE_VERSION"
        | "LASERCYTE_DX_LAST_RUN_DATE"
        | "LASERCYTE_DX_SERIAL_NUMBER"
        | "LASERCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_IP_ADDRESS"
        | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE"
        | "PROCYTE_DX_LAST_RUN_DATE"
        | "PROCYTE_DX_QC_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE"
        | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER"
        | "PROCYTE_DX_SERIAL_NUMBER"
        | "PROCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE"
        | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE"
        | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER"
        | "PROCYTE_DX_UPTIME"
        | "PROCYTE_DX_SAMPLE_INVERT_REMINDER"
        | "PROCYTE_ONE_SOFTWARE_VERSION"
        | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER"
        | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "SEDIVUE_DX_QC_EXPIRATION_DATE"
        | "SEDIVUE_DX_SOFTWARE_VERSION"
        | "SNAPPRO_IP_ADDRESS"
        | "SNAPPRO_LAST_RUN_DATE"
        | "SNAPPRO_SERIAL_NUMBER"
        | "SNAPPRO_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_IP_ADDRESS"
        | "SNAPSHOT_DX_LAST_RUN_DATE"
        | "SNAPSHOT_DX_SERIAL_NUMBER"
        | "SNAPSHOT_DX_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_UPTIME"
        | "UA_NEXT_GEN_REPORTING_UNITS"
        | "UA_NEXT_GEN_SOFTWARE_VERSION"
        | "UA_NEXT_GEN_IP_ADDRESS"
        | "UA_NEXT_GEN_SERIAL_NUMBER"
        | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE"
        | "UA_NEXT_GEN_LAST_RUN_DATE"
        | "VETSTAT_SERIAL_NUMBER"
        | "VETSTAT_LAST_RUN_DATE"
        | "VETSTAT_LAST_RUN_SOFTWARE_VERSION"
        | "IVLS_ANTENNAS_STATUS"
        | "IVLS_ROUTER_FIRMWARE_VERSION"
        | "IVLS_ROUTER_MODEL"
        | "IVLS_ROUTER_WAN_IP_TYPE"
        | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD"
        | "IVLS_ROUTER_PASSWORD_CHANGE_DATE"
        | "IVLS_SSID_PASSWORD"
        | "IVLS_DEFAULT_GATEWAY"
        | "IVLS_PRIMARY_DNS"
        | "IVLS_SECONDARY_DNS"
        | "IVLS_IP_ADDRESS"
        | "IVLS_SUBNET_MASK"
        | "IVLS_PRINTER_MODEL"
        | "IVLS_PRINTER_PRINT_QUALITY"
        | "IVLS_UNITS_SYSTEM"
        | "IVLS_DELTA_CONTROL_MODE"
        | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_UPGRADE_COMPLETE_DATETIME"
        | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT"
        | "IVLS_UPGRADE_USER_PROMPT_STATUS"
        | "PIMS_CONNECTION_STATUS"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_INTEGRATION_NAME"
        | "PIMS_SERIAL_NUMBER"
        | "VCP_CONNECTION_STATUS"
        | "IVLS_PRINTER_PAPER_SIZE"
        | "IVLS_PRINT_LASERCYTE_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS"
        | "IVLS_OS_TIMEZONE"
        | "IVLS_APPLICATION_TIMEZONE"
        | "IVLS_DST_STATUS"
        | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS"
        | "IVLS_ABNORMAL_RESULT_COLOR"
        | "IVLS_DISPLAY_REASON_FOR_TESTING",
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<SmartServicePropertiesDto> {
      const localVarFetchArgs = SmartServiceIntegrationApiFetchParamCreator(
        configuration
      ).fetchPropertyById(propertyId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Submit a PIMS XML message for processing by IVLS
     * @param {PimsXmlMessageDto} body The Pims XML Message to process.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processPimsMessage(
      body: PimsXmlMessageDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<SmartServicePropertyDto> {
      const localVarFetchArgs = SmartServiceIntegrationApiFetchParamCreator(
        configuration
      ).processPimsMessage(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save properties for SmartService.
     * @param {SmartServicePropertiesDto} body The SmartService properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(
      body: SmartServicePropertiesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SmartServiceIntegrationApiFetchParamCreator(
        configuration
      ).saveProperties(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SmartServiceIntegrationApi - factory interface
 * @export
 */
export const SmartServiceIntegrationApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch all SmartService properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(options?: any) {
      return SmartServiceIntegrationApiFp(configuration).fetchProperties(
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get SmartService property by ID.
     * @param {"IVLS_DEVICE_TYPE" | "IVLS_DATABASE_SIZE" | "IVLS_DATABASE_VERSION" | "IVLS_LAST_RUN_DATE" | "IVLS_COUNTRY" | "IVLS_LANGUAGE" | "IVLS_SOFTWARE_VERSION" | "VPC_CLIENT_VERSION" | "VPC_CLIENT_ENABLED" | "VPC_CLIENT_STARTED" | "CATALYST_DX_CURVES_VERSION" | "CATALYST_DX_IP_ADDRESS" | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE" | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER" | "CATALYST_DX_LAST_RUN_DATE" | "CATALYST_DX_QC_EXPIRATION_DATE" | "CATALYST_DX_QC_VERSION" | "CATALYST_DX_SERIAL_NUMBER" | "CATALYST_DX_SOFTWARE_VERSION" | "CATALYST_DX_UPTIME" | "CATALYST_DX_SMARTQC_REMINDER_WEEKS" | "CATALYST_DX_SMARTQC_REMINDER_DAY" | "CATALYST_DX_SMARTQC_REMINDER_HOUR" | "CATONE_CURVES_VERSION" | "CATONE_IP_ADDRESS" | "CATONE_LAST_QC_RUN_DAYS_SINCE" | "CATONE_LAST_QC_RUN_EXPIRATION_DATE" | "CATONE_LAST_QC_RUN_LOT_NUMBER" | "CATONE_LAST_RUN_DATE" | "CATONE_SERIAL_NUMBER" | "CATONE_SOFTWARE_VERSION" | "CATONE_UPTIME" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "COAG_DX_ALL" | "COAG_DX_IP_ADDRESS" | "COAG_DX_SERIAL_NUMBER" | "COAG_DX_SOFTWARE_VERSION" | "COAG_DX_UPTIME" | "LASERCYTE_LAST_RUN_DATE" | "LASERCYTE_SERIAL_NUMBER" | "LASERCYTE_SOFTWARE_VERSION" | "LASERCYTE_DX_LAST_RUN_DATE" | "LASERCYTE_DX_SERIAL_NUMBER" | "LASERCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_IP_ADDRESS" | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE" | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER" | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE" | "PROCYTE_DX_LAST_RUN_DATE" | "PROCYTE_DX_QC_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE" | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER" | "PROCYTE_DX_SERIAL_NUMBER" | "PROCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE" | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE" | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER" | "PROCYTE_DX_UPTIME" | "PROCYTE_DX_SAMPLE_INVERT_REMINDER" | "PROCYTE_ONE_SOFTWARE_VERSION" | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER" | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE" | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER" | "SEDIVUE_DX_QC_EXPIRATION_DATE" | "SEDIVUE_DX_SOFTWARE_VERSION" | "SNAPPRO_IP_ADDRESS" | "SNAPPRO_LAST_RUN_DATE" | "SNAPPRO_SERIAL_NUMBER" | "SNAPPRO_SOFTWARE_VERSION" | "SNAPSHOT_DX_IP_ADDRESS" | "SNAPSHOT_DX_LAST_RUN_DATE" | "SNAPSHOT_DX_SERIAL_NUMBER" | "SNAPSHOT_DX_SOFTWARE_VERSION" | "SNAPSHOT_DX_UPTIME" | "UA_NEXT_GEN_REPORTING_UNITS" | "UA_NEXT_GEN_SOFTWARE_VERSION" | "UA_NEXT_GEN_IP_ADDRESS" | "UA_NEXT_GEN_SERIAL_NUMBER" | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE" | "UA_NEXT_GEN_LAST_RUN_DATE" | "VETSTAT_SERIAL_NUMBER" | "VETSTAT_LAST_RUN_DATE" | "VETSTAT_LAST_RUN_SOFTWARE_VERSION" | "IVLS_ANTENNAS_STATUS" | "IVLS_ROUTER_FIRMWARE_VERSION" | "IVLS_ROUTER_MODEL" | "IVLS_ROUTER_WAN_IP_TYPE" | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD" | "IVLS_ROUTER_PASSWORD_CHANGE_DATE" | "IVLS_SSID_PASSWORD" | "IVLS_DEFAULT_GATEWAY" | "IVLS_PRIMARY_DNS" | "IVLS_SECONDARY_DNS" | "IVLS_IP_ADDRESS" | "IVLS_SUBNET_MASK" | "IVLS_PRINTER_MODEL" | "IVLS_PRINTER_PRINT_QUALITY" | "IVLS_UNITS_SYSTEM" | "IVLS_DELTA_CONTROL_MODE" | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME" | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME" | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "IVLS_UPGRADE_COMPLETE_DATETIME" | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT" | "IVLS_UPGRADE_USER_PROMPT_STATUS" | "PIMS_CONNECTION_STATUS" | "PIMS_CONNECTION_TYPE" | "PIMS_INTEGRATION_NAME" | "PIMS_SERIAL_NUMBER" | "VCP_CONNECTION_STATUS" | "IVLS_PRINTER_PAPER_SIZE" | "IVLS_PRINT_LASERCYTE_DOTPLOTS" | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS" | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS" | "IVLS_OS_TIMEZONE" | "IVLS_APPLICATION_TIMEZONE" | "IVLS_DST_STATUS" | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS" | "IVLS_ABNORMAL_RESULT_COLOR" | "IVLS_DISPLAY_REASON_FOR_TESTING"} propertyId The SmartService property ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPropertyById(
      propertyId:
        | "IVLS_DEVICE_TYPE"
        | "IVLS_DATABASE_SIZE"
        | "IVLS_DATABASE_VERSION"
        | "IVLS_LAST_RUN_DATE"
        | "IVLS_COUNTRY"
        | "IVLS_LANGUAGE"
        | "IVLS_SOFTWARE_VERSION"
        | "VPC_CLIENT_VERSION"
        | "VPC_CLIENT_ENABLED"
        | "VPC_CLIENT_STARTED"
        | "CATALYST_DX_CURVES_VERSION"
        | "CATALYST_DX_IP_ADDRESS"
        | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE"
        | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER"
        | "CATALYST_DX_LAST_RUN_DATE"
        | "CATALYST_DX_QC_EXPIRATION_DATE"
        | "CATALYST_DX_QC_VERSION"
        | "CATALYST_DX_SERIAL_NUMBER"
        | "CATALYST_DX_SOFTWARE_VERSION"
        | "CATALYST_DX_UPTIME"
        | "CATALYST_DX_SMARTQC_REMINDER_WEEKS"
        | "CATALYST_DX_SMARTQC_REMINDER_DAY"
        | "CATALYST_DX_SMARTQC_REMINDER_HOUR"
        | "CATONE_CURVES_VERSION"
        | "CATONE_IP_ADDRESS"
        | "CATONE_LAST_QC_RUN_DAYS_SINCE"
        | "CATONE_LAST_QC_RUN_EXPIRATION_DATE"
        | "CATONE_LAST_QC_RUN_LOT_NUMBER"
        | "CATONE_LAST_RUN_DATE"
        | "CATONE_SERIAL_NUMBER"
        | "CATONE_SOFTWARE_VERSION"
        | "CATONE_UPTIME"
        | "CATONE_SMARTQC_REMINDER_WEEKS"
        | "CATONE_SMARTQC_REMINDER_DAY"
        | "CATONE_SMARTQC_REMINDER_HOUR"
        | "COAG_DX_ALL"
        | "COAG_DX_IP_ADDRESS"
        | "COAG_DX_SERIAL_NUMBER"
        | "COAG_DX_SOFTWARE_VERSION"
        | "COAG_DX_UPTIME"
        | "LASERCYTE_LAST_RUN_DATE"
        | "LASERCYTE_SERIAL_NUMBER"
        | "LASERCYTE_SOFTWARE_VERSION"
        | "LASERCYTE_DX_LAST_RUN_DATE"
        | "LASERCYTE_DX_SERIAL_NUMBER"
        | "LASERCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_IP_ADDRESS"
        | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE"
        | "PROCYTE_DX_LAST_RUN_DATE"
        | "PROCYTE_DX_QC_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE"
        | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE"
        | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER"
        | "PROCYTE_DX_SERIAL_NUMBER"
        | "PROCYTE_DX_SOFTWARE_VERSION"
        | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE"
        | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE"
        | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER"
        | "PROCYTE_DX_UPTIME"
        | "PROCYTE_DX_SAMPLE_INVERT_REMINDER"
        | "PROCYTE_ONE_SOFTWARE_VERSION"
        | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER"
        | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE"
        | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER"
        | "SEDIVUE_DX_QC_EXPIRATION_DATE"
        | "SEDIVUE_DX_SOFTWARE_VERSION"
        | "SNAPPRO_IP_ADDRESS"
        | "SNAPPRO_LAST_RUN_DATE"
        | "SNAPPRO_SERIAL_NUMBER"
        | "SNAPPRO_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_IP_ADDRESS"
        | "SNAPSHOT_DX_LAST_RUN_DATE"
        | "SNAPSHOT_DX_SERIAL_NUMBER"
        | "SNAPSHOT_DX_SOFTWARE_VERSION"
        | "SNAPSHOT_DX_UPTIME"
        | "UA_NEXT_GEN_REPORTING_UNITS"
        | "UA_NEXT_GEN_SOFTWARE_VERSION"
        | "UA_NEXT_GEN_IP_ADDRESS"
        | "UA_NEXT_GEN_SERIAL_NUMBER"
        | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE"
        | "UA_NEXT_GEN_LAST_RUN_DATE"
        | "VETSTAT_SERIAL_NUMBER"
        | "VETSTAT_LAST_RUN_DATE"
        | "VETSTAT_LAST_RUN_SOFTWARE_VERSION"
        | "IVLS_ANTENNAS_STATUS"
        | "IVLS_ROUTER_FIRMWARE_VERSION"
        | "IVLS_ROUTER_MODEL"
        | "IVLS_ROUTER_WAN_IP_TYPE"
        | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD"
        | "IVLS_ROUTER_PASSWORD_CHANGE_DATE"
        | "IVLS_SSID_PASSWORD"
        | "IVLS_DEFAULT_GATEWAY"
        | "IVLS_PRIMARY_DNS"
        | "IVLS_SECONDARY_DNS"
        | "IVLS_IP_ADDRESS"
        | "IVLS_SUBNET_MASK"
        | "IVLS_PRINTER_MODEL"
        | "IVLS_PRINTER_PRINT_QUALITY"
        | "IVLS_UNITS_SYSTEM"
        | "IVLS_DELTA_CONTROL_MODE"
        | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME"
        | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
        | "IVLS_UPGRADE_COMPLETE_DATETIME"
        | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT"
        | "IVLS_UPGRADE_USER_PROMPT_STATUS"
        | "PIMS_CONNECTION_STATUS"
        | "PIMS_CONNECTION_TYPE"
        | "PIMS_INTEGRATION_NAME"
        | "PIMS_SERIAL_NUMBER"
        | "VCP_CONNECTION_STATUS"
        | "IVLS_PRINTER_PAPER_SIZE"
        | "IVLS_PRINT_LASERCYTE_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS"
        | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS"
        | "IVLS_OS_TIMEZONE"
        | "IVLS_APPLICATION_TIMEZONE"
        | "IVLS_DST_STATUS"
        | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
        | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS"
        | "IVLS_ABNORMAL_RESULT_COLOR"
        | "IVLS_DISPLAY_REASON_FOR_TESTING",
      options?: any
    ) {
      return SmartServiceIntegrationApiFp(configuration).fetchPropertyById(
        propertyId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Submit a PIMS XML message for processing by IVLS
     * @param {PimsXmlMessageDto} body The Pims XML Message to process.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processPimsMessage(body: PimsXmlMessageDto, options?: any) {
      return SmartServiceIntegrationApiFp(configuration).processPimsMessage(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save properties for SmartService.
     * @param {SmartServicePropertiesDto} body The SmartService properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(body: SmartServicePropertiesDto, options?: any) {
      return SmartServiceIntegrationApiFp(configuration).saveProperties(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SmartServiceIntegrationApi - object-oriented interface
 * @export
 * @class SmartServiceIntegrationApi
 * @extends {BaseAPI}
 */
export class SmartServiceIntegrationApi extends BaseAPI {
  /**
   *
   * @summary Fetch all SmartService properties.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceIntegrationApi
   */
  public fetchProperties(options?: any) {
    return SmartServiceIntegrationApiFp(this.configuration).fetchProperties(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get SmartService property by ID.
   * @param {"IVLS_DEVICE_TYPE" | "IVLS_DATABASE_SIZE" | "IVLS_DATABASE_VERSION" | "IVLS_LAST_RUN_DATE" | "IVLS_COUNTRY" | "IVLS_LANGUAGE" | "IVLS_SOFTWARE_VERSION" | "VPC_CLIENT_VERSION" | "VPC_CLIENT_ENABLED" | "VPC_CLIENT_STARTED" | "CATALYST_DX_CURVES_VERSION" | "CATALYST_DX_IP_ADDRESS" | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE" | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER" | "CATALYST_DX_LAST_RUN_DATE" | "CATALYST_DX_QC_EXPIRATION_DATE" | "CATALYST_DX_QC_VERSION" | "CATALYST_DX_SERIAL_NUMBER" | "CATALYST_DX_SOFTWARE_VERSION" | "CATALYST_DX_UPTIME" | "CATALYST_DX_SMARTQC_REMINDER_WEEKS" | "CATALYST_DX_SMARTQC_REMINDER_DAY" | "CATALYST_DX_SMARTQC_REMINDER_HOUR" | "CATONE_CURVES_VERSION" | "CATONE_IP_ADDRESS" | "CATONE_LAST_QC_RUN_DAYS_SINCE" | "CATONE_LAST_QC_RUN_EXPIRATION_DATE" | "CATONE_LAST_QC_RUN_LOT_NUMBER" | "CATONE_LAST_RUN_DATE" | "CATONE_SERIAL_NUMBER" | "CATONE_SOFTWARE_VERSION" | "CATONE_UPTIME" | "CATONE_SMARTQC_REMINDER_WEEKS" | "CATONE_SMARTQC_REMINDER_DAY" | "CATONE_SMARTQC_REMINDER_HOUR" | "COAG_DX_ALL" | "COAG_DX_IP_ADDRESS" | "COAG_DX_SERIAL_NUMBER" | "COAG_DX_SOFTWARE_VERSION" | "COAG_DX_UPTIME" | "LASERCYTE_LAST_RUN_DATE" | "LASERCYTE_SERIAL_NUMBER" | "LASERCYTE_SOFTWARE_VERSION" | "LASERCYTE_DX_LAST_RUN_DATE" | "LASERCYTE_DX_SERIAL_NUMBER" | "LASERCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_IP_ADDRESS" | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE" | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER" | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE" | "PROCYTE_DX_LAST_RUN_DATE" | "PROCYTE_DX_QC_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE" | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE" | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER" | "PROCYTE_DX_SERIAL_NUMBER" | "PROCYTE_DX_SOFTWARE_VERSION" | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE" | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE" | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER" | "PROCYTE_DX_UPTIME" | "PROCYTE_DX_SAMPLE_INVERT_REMINDER" | "PROCYTE_ONE_SOFTWARE_VERSION" | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER" | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE" | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER" | "SEDIVUE_DX_QC_EXPIRATION_DATE" | "SEDIVUE_DX_SOFTWARE_VERSION" | "SNAPPRO_IP_ADDRESS" | "SNAPPRO_LAST_RUN_DATE" | "SNAPPRO_SERIAL_NUMBER" | "SNAPPRO_SOFTWARE_VERSION" | "SNAPSHOT_DX_IP_ADDRESS" | "SNAPSHOT_DX_LAST_RUN_DATE" | "SNAPSHOT_DX_SERIAL_NUMBER" | "SNAPSHOT_DX_SOFTWARE_VERSION" | "SNAPSHOT_DX_UPTIME" | "UA_NEXT_GEN_REPORTING_UNITS" | "UA_NEXT_GEN_SOFTWARE_VERSION" | "UA_NEXT_GEN_IP_ADDRESS" | "UA_NEXT_GEN_SERIAL_NUMBER" | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE" | "UA_NEXT_GEN_LAST_RUN_DATE" | "VETSTAT_SERIAL_NUMBER" | "VETSTAT_LAST_RUN_DATE" | "VETSTAT_LAST_RUN_SOFTWARE_VERSION" | "IVLS_ANTENNAS_STATUS" | "IVLS_ROUTER_FIRMWARE_VERSION" | "IVLS_ROUTER_MODEL" | "IVLS_ROUTER_WAN_IP_TYPE" | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD" | "IVLS_ROUTER_PASSWORD_CHANGE_DATE" | "IVLS_SSID_PASSWORD" | "IVLS_DEFAULT_GATEWAY" | "IVLS_PRIMARY_DNS" | "IVLS_SECONDARY_DNS" | "IVLS_IP_ADDRESS" | "IVLS_SUBNET_MASK" | "IVLS_PRINTER_MODEL" | "IVLS_PRINTER_PRINT_QUALITY" | "IVLS_UNITS_SYSTEM" | "IVLS_DELTA_CONTROL_MODE" | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME" | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME" | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME" | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME" | "IVLS_UPGRADE_COMPLETE_DATETIME" | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT" | "IVLS_UPGRADE_USER_PROMPT_STATUS" | "PIMS_CONNECTION_STATUS" | "PIMS_CONNECTION_TYPE" | "PIMS_INTEGRATION_NAME" | "PIMS_SERIAL_NUMBER" | "VCP_CONNECTION_STATUS" | "IVLS_PRINTER_PAPER_SIZE" | "IVLS_PRINT_LASERCYTE_DOTPLOTS" | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS" | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS" | "IVLS_OS_TIMEZONE" | "IVLS_APPLICATION_TIMEZONE" | "IVLS_DST_STATUS" | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS" | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS" | "IVLS_ABNORMAL_RESULT_COLOR" | "IVLS_DISPLAY_REASON_FOR_TESTING"} propertyId The SmartService property ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceIntegrationApi
   */
  public fetchPropertyById(
    propertyId:
      | "IVLS_DEVICE_TYPE"
      | "IVLS_DATABASE_SIZE"
      | "IVLS_DATABASE_VERSION"
      | "IVLS_LAST_RUN_DATE"
      | "IVLS_COUNTRY"
      | "IVLS_LANGUAGE"
      | "IVLS_SOFTWARE_VERSION"
      | "VPC_CLIENT_VERSION"
      | "VPC_CLIENT_ENABLED"
      | "VPC_CLIENT_STARTED"
      | "CATALYST_DX_CURVES_VERSION"
      | "CATALYST_DX_IP_ADDRESS"
      | "CATALYST_DX_LAST_QC_RUN_DAYS_SINCE"
      | "CATALYST_DX_LAST_QC_RUN_LOT_NUMBER"
      | "CATALYST_DX_LAST_RUN_DATE"
      | "CATALYST_DX_QC_EXPIRATION_DATE"
      | "CATALYST_DX_QC_VERSION"
      | "CATALYST_DX_SERIAL_NUMBER"
      | "CATALYST_DX_SOFTWARE_VERSION"
      | "CATALYST_DX_UPTIME"
      | "CATALYST_DX_SMARTQC_REMINDER_WEEKS"
      | "CATALYST_DX_SMARTQC_REMINDER_DAY"
      | "CATALYST_DX_SMARTQC_REMINDER_HOUR"
      | "CATONE_CURVES_VERSION"
      | "CATONE_IP_ADDRESS"
      | "CATONE_LAST_QC_RUN_DAYS_SINCE"
      | "CATONE_LAST_QC_RUN_EXPIRATION_DATE"
      | "CATONE_LAST_QC_RUN_LOT_NUMBER"
      | "CATONE_LAST_RUN_DATE"
      | "CATONE_SERIAL_NUMBER"
      | "CATONE_SOFTWARE_VERSION"
      | "CATONE_UPTIME"
      | "CATONE_SMARTQC_REMINDER_WEEKS"
      | "CATONE_SMARTQC_REMINDER_DAY"
      | "CATONE_SMARTQC_REMINDER_HOUR"
      | "COAG_DX_ALL"
      | "COAG_DX_IP_ADDRESS"
      | "COAG_DX_SERIAL_NUMBER"
      | "COAG_DX_SOFTWARE_VERSION"
      | "COAG_DX_UPTIME"
      | "LASERCYTE_LAST_RUN_DATE"
      | "LASERCYTE_SERIAL_NUMBER"
      | "LASERCYTE_SOFTWARE_VERSION"
      | "LASERCYTE_DX_LAST_RUN_DATE"
      | "LASERCYTE_DX_SERIAL_NUMBER"
      | "LASERCYTE_DX_SOFTWARE_VERSION"
      | "PROCYTE_DX_IP_ADDRESS"
      | "PROCYTE_DX_LAST_QC_RUN_DAYS_SINCE"
      | "PROCYTE_DX_LAST_QC_RUN_LOT_NUMBER"
      | "PROCYTE_DX_LAST_RINSE_CYCLE_DAYS_SINCE"
      | "PROCYTE_DX_LAST_RUN_DATE"
      | "PROCYTE_DX_QC_EXPIRATION_DATE"
      | "PROCYTE_DX_REAGENT_KIT_ENTERED_DATE"
      | "PROCYTE_DX_REAGENT_KIT_EXPIRATION_DATE"
      | "PROCYTE_DX_REAGENT_KIT_LOT_NUMBER"
      | "PROCYTE_DX_SERIAL_NUMBER"
      | "PROCYTE_DX_SOFTWARE_VERSION"
      | "PROCYTE_DX_STAIN_PACK_ENTERED_DATE"
      | "PROCYTE_DX_STAIN_PACK_EXPIRATION_DATE"
      | "PROCYTE_DX_STAIN_PACK_LOT_NUMBER"
      | "PROCYTE_DX_UPTIME"
      | "PROCYTE_DX_SAMPLE_INVERT_REMINDER"
      | "PROCYTE_ONE_SOFTWARE_VERSION"
      | "PROCYTE_ONE_SAMPLE_INVERT_REMINDER"
      | "SEDIVUE_DX_LAST_QC_RUN_DAYS_SINCE"
      | "SEDIVUE_DX_LAST_QC_RUN_LOT_NUMBER"
      | "SEDIVUE_DX_QC_EXPIRATION_DATE"
      | "SEDIVUE_DX_SOFTWARE_VERSION"
      | "SNAPPRO_IP_ADDRESS"
      | "SNAPPRO_LAST_RUN_DATE"
      | "SNAPPRO_SERIAL_NUMBER"
      | "SNAPPRO_SOFTWARE_VERSION"
      | "SNAPSHOT_DX_IP_ADDRESS"
      | "SNAPSHOT_DX_LAST_RUN_DATE"
      | "SNAPSHOT_DX_SERIAL_NUMBER"
      | "SNAPSHOT_DX_SOFTWARE_VERSION"
      | "SNAPSHOT_DX_UPTIME"
      | "UA_NEXT_GEN_REPORTING_UNITS"
      | "UA_NEXT_GEN_SOFTWARE_VERSION"
      | "UA_NEXT_GEN_IP_ADDRESS"
      | "UA_NEXT_GEN_SERIAL_NUMBER"
      | "UA_NEXT_GEN_LAST_CALIBRATION_RUN_DAYS_SINCE"
      | "UA_NEXT_GEN_LAST_RUN_DATE"
      | "VETSTAT_SERIAL_NUMBER"
      | "VETSTAT_LAST_RUN_DATE"
      | "VETSTAT_LAST_RUN_SOFTWARE_VERSION"
      | "IVLS_ANTENNAS_STATUS"
      | "IVLS_ROUTER_FIRMWARE_VERSION"
      | "IVLS_ROUTER_MODEL"
      | "IVLS_ROUTER_WAN_IP_TYPE"
      | "IVLS_ROUTER_PASSWORD_CHANGE_METHOD"
      | "IVLS_ROUTER_PASSWORD_CHANGE_DATE"
      | "IVLS_SSID_PASSWORD"
      | "IVLS_DEFAULT_GATEWAY"
      | "IVLS_PRIMARY_DNS"
      | "IVLS_SECONDARY_DNS"
      | "IVLS_IP_ADDRESS"
      | "IVLS_SUBNET_MASK"
      | "IVLS_PRINTER_MODEL"
      | "IVLS_PRINTER_PRINT_QUALITY"
      | "IVLS_UNITS_SYSTEM"
      | "IVLS_DELTA_CONTROL_MODE"
      | "IVLS_SMARTSERVICE_INDICATOR_OFFLINE_TIME"
      | "IVLS_SMARTSERVICE_INDICATOR_ALTERNATE_OFFLINE_TIME"
      | "IVLS_SMARTSERVICE_CONNECTION_FAILED_NOTIFICATION_TIME"
      | "IVLS_SMARTSERVICE_OFFLINE_NOTIFICATION_TIME"
      | "IVLS_SMARTSERVICE_ALTERNATE_OFFLINE_NOTIFICATION_TIME"
      | "IVLS_UPGRADE_COMPLETE_DATETIME"
      | "IVLS_UPGRADE_USER_PROMPT_IGNORE_COUNT"
      | "IVLS_UPGRADE_USER_PROMPT_STATUS"
      | "PIMS_CONNECTION_STATUS"
      | "PIMS_CONNECTION_TYPE"
      | "PIMS_INTEGRATION_NAME"
      | "PIMS_SERIAL_NUMBER"
      | "VCP_CONNECTION_STATUS"
      | "IVLS_PRINTER_PAPER_SIZE"
      | "IVLS_PRINT_LASERCYTE_DOTPLOTS"
      | "IVLS_PRINT_PROCYTE_DX_DOTPLOTS"
      | "IVLS_PRINT_PROCYTE_ONE_DOTPLOTS"
      | "IVLS_OS_TIMEZONE"
      | "IVLS_APPLICATION_TIMEZONE"
      | "IVLS_DST_STATUS"
      | "IVLS_DISPLAY_URINALYSIS_INTERPRETIVE_COMMENTS"
      | "IVLS_DISPLAY_HEMATOLOGY_INTERPRETIVE_COMMENTS"
      | "IVLS_ABNORMAL_RESULT_COLOR"
      | "IVLS_DISPLAY_REASON_FOR_TESTING",
    options?: any
  ) {
    return SmartServiceIntegrationApiFp(this.configuration).fetchPropertyById(
      propertyId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Submit a PIMS XML message for processing by IVLS
   * @param {PimsXmlMessageDto} body The Pims XML Message to process.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceIntegrationApi
   */
  public processPimsMessage(body: PimsXmlMessageDto, options?: any) {
    return SmartServiceIntegrationApiFp(this.configuration).processPimsMessage(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save properties for SmartService.
   * @param {SmartServicePropertiesDto} body The SmartService properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SmartServiceIntegrationApi
   */
  public saveProperties(body: SmartServicePropertiesDto, options?: any) {
    return SmartServiceIntegrationApiFp(this.configuration).saveProperties(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SnapDeviceApi - fetch parameter creator
 * @export
 */
export const SnapDeviceApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get snap devices for specified species.
     * @param {number} speciesId The species id.
     * @param {boolean} [enabledOnly] The enabled devices switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapDevices(
      speciesId: number,
      enabledOnly?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling getSnapDevices."
        );
      }
      const localVarPath = `/snapDevice/species/{speciesId}/devices`.replace(
        `{${"speciesId"}}`,
        encodeURIComponent(String(speciesId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (enabledOnly !== undefined) {
        localVarQueryParameter["enabledOnly"] = enabledOnly;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SnapDeviceApi - functional programming interface
 * @export
 */
export const SnapDeviceApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get snap devices for specified species.
     * @param {number} speciesId The species id.
     * @param {boolean} [enabledOnly] The enabled devices switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapDevices(
      speciesId: number,
      enabledOnly?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SnapDeviceDto>> {
      const localVarFetchArgs = SnapDeviceApiFetchParamCreator(
        configuration
      ).getSnapDevices(speciesId, enabledOnly, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SnapDeviceApi - factory interface
 * @export
 */
export const SnapDeviceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get snap devices for specified species.
     * @param {number} speciesId The species id.
     * @param {boolean} [enabledOnly] The enabled devices switch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSnapDevices(speciesId: number, enabledOnly?: boolean, options?: any) {
      return SnapDeviceApiFp(configuration).getSnapDevices(
        speciesId,
        enabledOnly,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SnapDeviceApi - object-oriented interface
 * @export
 * @class SnapDeviceApi
 * @extends {BaseAPI}
 */
export class SnapDeviceApi extends BaseAPI {
  /**
   *
   * @summary Get snap devices for specified species.
   * @param {number} speciesId The species id.
   * @param {boolean} [enabledOnly] The enabled devices switch.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SnapDeviceApi
   */
  public getSnapDevices(
    speciesId: number,
    enabledOnly?: boolean,
    options?: any
  ) {
    return SnapDeviceApiFp(this.configuration).getSnapDevices(
      speciesId,
      enabledOnly,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SpeciesApi - fetch parameter creator
 * @export
 */
export const SpeciesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get all species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllSpecies(options: any = {}): FetchArgs {
      const localVarPath = `/species`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If no breeds are available for the current country, it will return US breeds.
     * @summary Get breeds for species for the current country.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBreeds(speciesId: number, options: any = {}): FetchArgs {
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling getBreeds."
        );
      }
      const localVarPath = `/species/{speciesId}/breeds`.replace(
        `{${"speciesId"}}`,
        encodeURIComponent(String(speciesId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get reference classifications for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReferenceClassifications(
      speciesId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling getReferenceClassifications."
        );
      }
      const localVarPath =
        `/species/{speciesId}/referenceClassifications`.replace(
          `{${"speciesId"}}`,
          encodeURIComponent(String(speciesId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get sample types for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleTypes(speciesId: number, options: any = {}): FetchArgs {
      // verify required parameter 'speciesId' is not null or undefined
      if (speciesId === null || speciesId === undefined) {
        throw new RequiredError(
          "speciesId",
          "Required parameter speciesId was null or undefined when calling getSampleTypes."
        );
      }
      const localVarPath = `/species/{speciesId}/sampleTypes`.replace(
        `{${"speciesId"}}`,
        encodeURIComponent(String(speciesId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SpeciesApi - functional programming interface
 * @export
 */
export const SpeciesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get all species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllSpecies(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpeciesDto>> {
      const localVarFetchArgs =
        SpeciesApiFetchParamCreator(configuration).fetchAllSpecies(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * If no breeds are available for the current country, it will return US breeds.
     * @summary Get breeds for species for the current country.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBreeds(
      speciesId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BreedDto>> {
      const localVarFetchArgs = SpeciesApiFetchParamCreator(
        configuration
      ).getBreeds(speciesId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get reference classifications for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReferenceClassifications(
      speciesId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RefClassDto>> {
      const localVarFetchArgs = SpeciesApiFetchParamCreator(
        configuration
      ).getReferenceClassifications(speciesId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get sample types for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleTypes(
      speciesId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<SampleTypeSupportDto>> {
      const localVarFetchArgs = SpeciesApiFetchParamCreator(
        configuration
      ).getSampleTypes(speciesId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SpeciesApi - factory interface
 * @export
 */
export const SpeciesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get all species.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllSpecies(options?: any) {
      return SpeciesApiFp(configuration).fetchAllSpecies(options)(
        fetch,
        basePath
      );
    },
    /**
     * If no breeds are available for the current country, it will return US breeds.
     * @summary Get breeds for species for the current country.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBreeds(speciesId: number, options?: any) {
      return SpeciesApiFp(configuration).getBreeds(speciesId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get reference classifications for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReferenceClassifications(speciesId: number, options?: any) {
      return SpeciesApiFp(configuration).getReferenceClassifications(
        speciesId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get sample types for species.
     * @param {number} speciesId The species Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleTypes(speciesId: number, options?: any) {
      return SpeciesApiFp(configuration).getSampleTypes(speciesId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * SpeciesApi - object-oriented interface
 * @export
 * @class SpeciesApi
 * @extends {BaseAPI}
 */
export class SpeciesApi extends BaseAPI {
  /**
   *
   * @summary Get all species.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpeciesApi
   */
  public fetchAllSpecies(options?: any) {
    return SpeciesApiFp(this.configuration).fetchAllSpecies(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * If no breeds are available for the current country, it will return US breeds.
   * @summary Get breeds for species for the current country.
   * @param {number} speciesId The species Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpeciesApi
   */
  public getBreeds(speciesId: number, options?: any) {
    return SpeciesApiFp(this.configuration).getBreeds(speciesId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get reference classifications for species.
   * @param {number} speciesId The species Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpeciesApi
   */
  public getReferenceClassifications(speciesId: number, options?: any) {
    return SpeciesApiFp(this.configuration).getReferenceClassifications(
      speciesId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get sample types for species.
   * @param {number} speciesId The species Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SpeciesApi
   */
  public getSampleTypes(speciesId: number, options?: any) {
    return SpeciesApiFp(this.configuration).getSampleTypes(speciesId, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * StandbyApi - fetch parameter creator
 * @export
 */
export const StandbyApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Exit target instrument from standby
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exitStandbyInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling exitStandbyInstrument."
        );
      }
      const localVarPath = `/standby/{instrumentId}/exit`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Put target instrument into standby.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    standbyInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling standbyInstrument."
        );
      }
      const localVarPath = `/standby/{instrumentId}/enter`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StandbyApi - functional programming interface
 * @export
 */
export const StandbyApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Exit target instrument from standby
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exitStandbyInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = StandbyApiFetchParamCreator(
        configuration
      ).exitStandbyInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Put target instrument into standby.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    standbyInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = StandbyApiFetchParamCreator(
        configuration
      ).standbyInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * StandbyApi - factory interface
 * @export
 */
export const StandbyApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Exit target instrument from standby
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exitStandbyInstrument(instrumentId: number, options?: any) {
      return StandbyApiFp(configuration).exitStandbyInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Put target instrument into standby.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    standbyInstrument(instrumentId: number, options?: any) {
      return StandbyApiFp(configuration).standbyInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * StandbyApi - object-oriented interface
 * @export
 * @class StandbyApi
 * @extends {BaseAPI}
 */
export class StandbyApi extends BaseAPI {
  /**
   *
   * @summary Exit target instrument from standby
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandbyApi
   */
  public exitStandbyInstrument(instrumentId: number, options?: any) {
    return StandbyApiFp(this.configuration).exitStandbyInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Put target instrument into standby.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StandbyApi
   */
  public standbyInstrument(instrumentId: number, options?: any) {
    return StandbyApiFp(this.configuration).standbyInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SystemApi - fetch parameter creator
 * @export
 */
export const SystemApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch the system running status for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchServerRunning(options: any = {}): FetchArgs {
      const localVarPath = `/system/running`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch the system information for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSystem(options: any = {}): FetchArgs {
      const localVarPath = `/system/system`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate a random password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePassword(options: any = {}): FetchArgs {
      const localVarPath = `/system/randomPassword`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Ping the supplied IP Address, returns ping success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options: any = {}): FetchArgs {
      const localVarPath = `/system/ping`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reschedule the weekly reboot reminder to 24 hours later.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleWeeklyRebootReminder(options: any = {}): FetchArgs {
      const localVarPath = `/system/rescheduleWeeklyRebootReminder`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Restart the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(options: any = {}): FetchArgs {
      const localVarPath = `/system/restart`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Shutdown the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdown(options: any = {}): FetchArgs {
      const localVarPath = `/system/shutdown`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Fetch the system running status for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchServerRunning(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).fetchServerRunning(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch the system information for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSystem(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SystemDto> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).fetchSystem(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Generate a random password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePassword(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).generatePassword(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Ping the supplied IP Address, returns ping success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).ping(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Reschedule the weekly reboot reminder to 24 hours later.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleWeeklyRebootReminder(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(
          configuration
        ).rescheduleWeeklyRebootReminder(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Restart the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).restart(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Shutdown the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdown(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SystemApiFetchParamCreator(configuration).shutdown(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch the system running status for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchServerRunning(options?: any) {
      return SystemApiFp(configuration).fetchServerRunning(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Fetch the system information for this IVLS tomcat server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSystem(options?: any) {
      return SystemApiFp(configuration).fetchSystem(options)(fetch, basePath);
    },
    /**
     *
     * @summary Generate a random password.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePassword(options?: any) {
      return SystemApiFp(configuration).generatePassword(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Ping the supplied IP Address, returns ping success.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any) {
      return SystemApiFp(configuration).ping(options)(fetch, basePath);
    },
    /**
     *
     * @summary Reschedule the weekly reboot reminder to 24 hours later.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rescheduleWeeklyRebootReminder(options?: any) {
      return SystemApiFp(configuration).rescheduleWeeklyRebootReminder(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Restart the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restart(options?: any) {
      return SystemApiFp(configuration).restart(options)(fetch, basePath);
    },
    /**
     *
     * @summary Shutdown the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutdown(options?: any) {
      return SystemApiFp(configuration).shutdown(options)(fetch, basePath);
    },
  };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  /**
   *
   * @summary Fetch the system running status for this IVLS tomcat server.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public fetchServerRunning(options?: any) {
    return SystemApiFp(this.configuration).fetchServerRunning(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch the system information for this IVLS tomcat server.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public fetchSystem(options?: any) {
    return SystemApiFp(this.configuration).fetchSystem(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Generate a random password.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public generatePassword(options?: any) {
    return SystemApiFp(this.configuration).generatePassword(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Ping the supplied IP Address, returns ping success.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public ping(options?: any) {
    return SystemApiFp(this.configuration).ping(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Reschedule the weekly reboot reminder to 24 hours later.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public rescheduleWeeklyRebootReminder(options?: any) {
    return SystemApiFp(this.configuration).rescheduleWeeklyRebootReminder(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Restart the system.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public restart(options?: any) {
    return SystemApiFp(this.configuration).restart(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Shutdown the system.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SystemApi
   */
  public shutdown(options?: any) {
    return SystemApiFp(this.configuration).shutdown(options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * TenseiApi - fetch parameter creator
 * @export
 */
export const TenseiApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Cancel the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelFlowCellRinse(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelFlowCellRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/flowCellRinse/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelMonthlyRinse(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelMonthlyRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/monthlyRinse/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelWasteChamberRinse(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling cancelWasteChamberRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/wasteChamberRinse/cancel`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Auto Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAutoRinse(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestAutoRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/autoRinse/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request to Clear Pinch Valve maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestClearPinchValve(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestClearPinchValve."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/clearPinchValve/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Drain RBC Isolation Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainRbcIsolationChamber(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestDrainRbcIsolationChamber."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/drainRbcIsolationChamber/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Drain Reaction Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainReactionChamber(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestDrainReactionChamber."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/drainReactionChamber/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Drain Waste Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainWasteChamber(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestDrainWasteChamber."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/drainWasteChamber/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellRinse(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestFlowCellRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/flowCellRinse/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestMonthlyRinse(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestMonthlyRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/monthlyRinse/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request to Remove Clog maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoveClog(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestRemoveClog."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/removeClog/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Replenish HGB Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishHgb(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestReplenishHgb."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/replenishHGBReagent/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Replenish Lytic Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishLytic(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestReplenishLytic."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/replenishLyticReagent/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Replenish Reticulocyte Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishReticDiluent(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestReplenishReticDiluent."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/replenishReticulocyteDiluent/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Replenish Stain maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishStain(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestReplenishStain."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/replenishStain/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Replenish System Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishSystemDiluent(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestReplenishSystemDiluent."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/replenishSystemDiluent/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Reset Air Pump maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAirPump(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestResetAirPump."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/resetAirPump/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Reset Aspiration Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAspirationMotor(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestResetAspirationMotor."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/resetAspirationMotor/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Reset Sheath Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetSheathMotor(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestResetSheathMotor."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/resetSheathMotor/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Reset Tube Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetTubeMotor(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestResetTubeMotor."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/resetTubeMotor/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Reset WB Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetWBMotor(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestResetWBMotor."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/resetWBMotor/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestWasteChamberRinse(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestWasteChamberRinse."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/wasteChamberRinse/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TenseiApi - functional programming interface
 * @export
 */
export const TenseiApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Cancel the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelFlowCellRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).cancelFlowCellRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancel the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelMonthlyRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).cancelMonthlyRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancel the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelWasteChamberRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).cancelWasteChamberRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Auto Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAutoRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestAutoRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request to Clear Pinch Valve maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestClearPinchValve(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestClearPinchValve(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Drain RBC Isolation Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainRbcIsolationChamber(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestDrainRbcIsolationChamber(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Drain Reaction Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainReactionChamber(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestDrainReactionChamber(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Drain Waste Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainWasteChamber(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestDrainWasteChamber(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestFlowCellRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestMonthlyRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestMonthlyRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request to Remove Clog maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoveClog(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestRemoveClog(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Replenish HGB Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishHgb(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestReplenishHgb(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Replenish Lytic Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishLytic(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestReplenishLytic(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Replenish Reticulocyte Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishReticDiluent(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestReplenishReticDiluent(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Replenish Stain maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishStain(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestReplenishStain(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Replenish System Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishSystemDiluent(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestReplenishSystemDiluent(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Reset Air Pump maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAirPump(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestResetAirPump(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Reset Aspiration Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAspirationMotor(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestResetAspirationMotor(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Reset Sheath Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetSheathMotor(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestResetSheathMotor(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Reset Tube Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetTubeMotor(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestResetTubeMotor(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Reset WB Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetWBMotor(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestResetWBMotor(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestWasteChamberRinse(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).requestWasteChamberRinse(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TenseiApi - factory interface
 * @export
 */
export const TenseiApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Cancel the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelFlowCellRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).cancelFlowCellRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cancel the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelMonthlyRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).cancelMonthlyRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cancel the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelWasteChamberRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).cancelWasteChamberRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Auto Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestAutoRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestAutoRinse(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Request to Clear Pinch Valve maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestClearPinchValve(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestClearPinchValve(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Drain RBC Isolation Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainRbcIsolationChamber(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestDrainRbcIsolationChamber(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Drain Reaction Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainReactionChamber(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestDrainReactionChamber(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Drain Waste Chamber maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestDrainWasteChamber(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestDrainWasteChamber(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Flow Cell Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestFlowCellRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestFlowCellRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Monthly Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestMonthlyRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestMonthlyRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request to Remove Clog maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestRemoveClog(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestRemoveClog(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Replenish HGB Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishHgb(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestReplenishHgb(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Replenish Lytic Reagent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishLytic(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestReplenishLytic(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Replenish Reticulocyte Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishReticDiluent(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestReplenishReticDiluent(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Replenish Stain maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishStain(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestReplenishStain(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Replenish System Diluent maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestReplenishSystemDiluent(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestReplenishSystemDiluent(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Reset Air Pump maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAirPump(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestResetAirPump(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Reset Aspiration Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetAspirationMotor(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestResetAspirationMotor(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Reset Sheath Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetSheathMotor(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestResetSheathMotor(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Reset Tube Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetTubeMotor(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestResetTubeMotor(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Reset WB Motor maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestResetWBMotor(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestResetWBMotor(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Waste Chamber Rinse maintenance procedure.
     * @param {number} instrumentId The instrument Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestWasteChamberRinse(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).requestWasteChamberRinse(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * TenseiApi - object-oriented interface
 * @export
 * @class TenseiApi
 * @extends {BaseAPI}
 */
export class TenseiApi extends BaseAPI {
  /**
   *
   * @summary Cancel the Flow Cell Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public cancelFlowCellRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).cancelFlowCellRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cancel the Monthly Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public cancelMonthlyRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).cancelMonthlyRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cancel the Waste Chamber Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public cancelWasteChamberRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).cancelWasteChamberRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Auto Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestAutoRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestAutoRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request to Clear Pinch Valve maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestClearPinchValve(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestClearPinchValve(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Drain RBC Isolation Chamber maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestDrainRbcIsolationChamber(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestDrainRbcIsolationChamber(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Drain Reaction Chamber maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestDrainReactionChamber(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestDrainReactionChamber(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Drain Waste Chamber maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestDrainWasteChamber(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestDrainWasteChamber(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Flow Cell Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestFlowCellRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestFlowCellRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Monthly Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestMonthlyRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestMonthlyRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request to Remove Clog maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestRemoveClog(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestRemoveClog(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Replenish HGB Reagent maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestReplenishHgb(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestReplenishHgb(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Replenish Lytic Reagent maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestReplenishLytic(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestReplenishLytic(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Replenish Reticulocyte Diluent maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestReplenishReticDiluent(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestReplenishReticDiluent(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Replenish Stain maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestReplenishStain(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestReplenishStain(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Replenish System Diluent maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestReplenishSystemDiluent(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestReplenishSystemDiluent(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Reset Air Pump maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestResetAirPump(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestResetAirPump(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Reset Aspiration Motor maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestResetAspirationMotor(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestResetAspirationMotor(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Reset Sheath Motor maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestResetSheathMotor(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestResetSheathMotor(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Reset Tube Motor maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestResetTubeMotor(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestResetTubeMotor(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Reset WB Motor maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestResetWBMotor(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestResetWBMotor(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Waste Chamber Rinse maintenance procedure.
   * @param {number} instrumentId The instrument Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public requestWasteChamberRinse(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).requestWasteChamberRinse(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TenseiQCApi - fetch parameter creator
 * @export
 */
export const TenseiQCApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {TenseiQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(
      body: TenseiQcBarcodeSaveRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling saveQcBarcodes."
        );
      }
      const localVarPath = `/tensei/qc/barcodes/save`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TenseiQcBarcodeSaveRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {TenseiQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(
      body: TenseiQcBarcodeValidateRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling validateQcBarcodes."
        );
      }
      const localVarPath = `/tensei/qc/barcodes/validate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TenseiQcBarcodeValidateRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TenseiQCApi - functional programming interface
 * @export
 */
export const TenseiQCApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {TenseiQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(
      body: TenseiQcBarcodeSaveRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TenseiQCApiFetchParamCreator(
        configuration
      ).saveQcBarcodes(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {TenseiQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(
      body: TenseiQcBarcodeValidateRequestDto,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TenseiQcBarcodeValidateResponseDto> {
      const localVarFetchArgs = TenseiQCApiFetchParamCreator(
        configuration
      ).validateQcBarcodes(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TenseiQCApi - factory interface
 * @export
 */
export const TenseiQCApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Saves quality control barcodes.
     * @param {TenseiQcBarcodeSaveRequestDto} body The quality control barcodes to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveQcBarcodes(body: TenseiQcBarcodeSaveRequestDto, options?: any) {
      return TenseiQCApiFp(configuration).saveQcBarcodes(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Validates quality control barcodes.
     * @param {TenseiQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateQcBarcodes(body: TenseiQcBarcodeValidateRequestDto, options?: any) {
      return TenseiQCApiFp(configuration).validateQcBarcodes(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * TenseiQCApi - object-oriented interface
 * @export
 * @class TenseiQCApi
 * @extends {BaseAPI}
 */
export class TenseiQCApi extends BaseAPI {
  /**
   *
   * @summary Saves quality control barcodes.
   * @param {TenseiQcBarcodeSaveRequestDto} body The quality control barcodes to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiQCApi
   */
  public saveQcBarcodes(body: TenseiQcBarcodeSaveRequestDto, options?: any) {
    return TenseiQCApiFp(this.configuration).saveQcBarcodes(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Validates quality control barcodes.
   * @param {TenseiQcBarcodeValidateRequestDto} body The quality control barcodes to validate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiQCApi
   */
  public validateQcBarcodes(
    body: TenseiQcBarcodeValidateRequestDto,
    options?: any
  ) {
    return TenseiQCApiFp(this.configuration).validateQcBarcodes(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * TheiaApi - fetch parameter creator
 * @export
 */
export const TheiaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling executeMaintenanceProcedure."
        );
      }
      // verify required parameter 'instrumentMaintenanceProcedure' is not null or undefined
      if (
        instrumentMaintenanceProcedure === null ||
        instrumentMaintenanceProcedure === undefined
      ) {
        throw new RequiredError(
          "instrumentMaintenanceProcedure",
          "Required parameter instrumentMaintenanceProcedure was null or undefined when calling executeMaintenanceProcedure."
        );
      }
      const localVarPath = `/theia/{instrumentId}/procedure/execute`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (instrumentMaintenanceProcedure !== undefined) {
        localVarQueryParameter["instrumentMaintenanceProcedure"] =
          instrumentMaintenanceProcedure;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch suggested runs to use for matching a Theia run against
     * @param {number} patientId patient to search for
     * @param {number} [limit] limit the number of results. Max is 500
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMatchSuggestions(
      patientId: number,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'patientId' is not null or undefined
      if (patientId === null || patientId === undefined) {
        throw new RequiredError(
          "patientId",
          "Required parameter patientId was null or undefined when calling fetchMatchSuggestions."
        );
      }
      const localVarPath =
        `/theia/patient/{patientId}/matchSuggestions`.replace(
          `{${"patientId"}}`,
          encodeURIComponent(String(patientId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch supported barcodes types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSupportedBarcodeTypes(options: any = {}): FetchArgs {
      const localVarPath = `/theia/barcodes/types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get images for Theia run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForTheiaRun(
      instrumentRunId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentRunId' is not null or undefined
      if (instrumentRunId === null || instrumentRunId === undefined) {
        throw new RequiredError(
          "instrumentRunId",
          "Required parameter instrumentRunId was null or undefined when calling getImagesForTheiaRun."
        );
      }
      const localVarPath =
        `/theia/instrumentRuns/{instrumentRunId}/images`.replace(
          `{${"instrumentRunId"}}`,
          encodeURIComponent(String(instrumentRunId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TheiaApi - functional programming interface
 * @export
 */
export const TheiaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).executeMaintenanceProcedure(
        instrumentId,
        instrumentMaintenanceProcedure,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch suggested runs to use for matching a Theia run against
     * @param {number} patientId patient to search for
     * @param {number} [limit] limit the number of results. Max is 500
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMatchSuggestions(
      patientId: number,
      limit?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<TheiaMatchingRunResultDto>> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).fetchMatchSuggestions(patientId, limit, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch supported barcodes types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSupportedBarcodeTypes(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        TheiaApiFetchParamCreator(configuration).fetchSupportedBarcodeTypes(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get images for Theia run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForTheiaRun(
      instrumentRunId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<CytologyImageDto>> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).getImagesForTheiaRun(instrumentRunId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TheiaApi - factory interface
 * @export
 */
export const TheiaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Execute instrument maintenance procedure.
     * @param {number} instrumentId The id of connected device.
     * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeMaintenanceProcedure(
      instrumentId: number,
      instrumentMaintenanceProcedure:
        | "GENERAL_CLEAN"
        | "OPTICS_CALIBRATION"
        | "DROP_CUVETTE"
        | "INITIALIZE"
        | "OFFSETS"
        | "SHUTDOWN"
        | "RESTART"
        | "FULL_SYSTEM_PRIME"
        | "FLOW_CELL_SOAK"
        | "DRAIN_MIX_CHAMBERS"
        | "SYSTEM_FLUSH"
        | "PRIME_REAGENT"
        | "PRIME_SHEATH"
        | "REPLACE_REAGENT"
        | "REPLACE_SHEATH"
        | "REPLACE_OBC"
        | "BLEACH_CLEAN"
        | "OPTIMIZE"
        | "DRAIN_RBC_ISOLATION_CHAMBER"
        | "DRAIN_REACTION_CHAMBER"
        | "DRAIN_WASTE_CHAMBER"
        | "AUTO_RINSE"
        | "MONTHLY_RINSE"
        | "FLOW_CELL_RINSE"
        | "WASTE_CHAMBER_RINSE"
        | "CLEAR_PINCH_VALVE"
        | "REMOVE_CLOG"
        | "RESET_AIR_PUMP"
        | "RESET_ASPIRATION_MOTOR"
        | "RESET_SHEATH_MOTOR"
        | "RESET_TUBE_MOTOR"
        | "RESET_WB_MOTOR"
        | "REPLENISH_REAGENT"
        | "REPLENISH_STAIN"
        | "MAINTENANCE_1"
        | "MAINTENANCE_2"
        | "MAINTENANCE_3"
        | "MAINTENANCE_4"
        | "MAINTENANCE_5"
        | "MAINTENANCE_6",
      options?: any
    ) {
      return TheiaApiFp(configuration).executeMaintenanceProcedure(
        instrumentId,
        instrumentMaintenanceProcedure,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch suggested runs to use for matching a Theia run against
     * @param {number} patientId patient to search for
     * @param {number} [limit] limit the number of results. Max is 500
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMatchSuggestions(patientId: number, limit?: number, options?: any) {
      return TheiaApiFp(configuration).fetchMatchSuggestions(
        patientId,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Fetch supported barcodes types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSupportedBarcodeTypes(options?: any) {
      return TheiaApiFp(configuration).fetchSupportedBarcodeTypes(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get images for Theia run.
     * @param {number} instrumentRunId The instrument run Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesForTheiaRun(instrumentRunId: number, options?: any) {
      return TheiaApiFp(configuration).getImagesForTheiaRun(
        instrumentRunId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * TheiaApi - object-oriented interface
 * @export
 * @class TheiaApi
 * @extends {BaseAPI}
 */
export class TheiaApi extends BaseAPI {
  /**
   *
   * @summary Execute instrument maintenance procedure.
   * @param {number} instrumentId The id of connected device.
   * @param {"GENERAL_CLEAN" | "OPTICS_CALIBRATION" | "DROP_CUVETTE" | "INITIALIZE" | "OFFSETS" | "SHUTDOWN" | "RESTART" | "FULL_SYSTEM_PRIME" | "FLOW_CELL_SOAK" | "DRAIN_MIX_CHAMBERS" | "SYSTEM_FLUSH" | "PRIME_REAGENT" | "PRIME_SHEATH" | "REPLACE_REAGENT" | "REPLACE_SHEATH" | "REPLACE_OBC" | "BLEACH_CLEAN" | "OPTIMIZE" | "DRAIN_RBC_ISOLATION_CHAMBER" | "DRAIN_REACTION_CHAMBER" | "DRAIN_WASTE_CHAMBER" | "AUTO_RINSE" | "MONTHLY_RINSE" | "FLOW_CELL_RINSE" | "WASTE_CHAMBER_RINSE" | "CLEAR_PINCH_VALVE" | "REMOVE_CLOG" | "RESET_AIR_PUMP" | "RESET_ASPIRATION_MOTOR" | "RESET_SHEATH_MOTOR" | "RESET_TUBE_MOTOR" | "RESET_WB_MOTOR" | "REPLENISH_REAGENT" | "REPLENISH_STAIN" | "MAINTENANCE_1" | "MAINTENANCE_2" | "MAINTENANCE_3" | "MAINTENANCE_4" | "MAINTENANCE_5" | "MAINTENANCE_6"} instrumentMaintenanceProcedure Instrument procedure name.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public executeMaintenanceProcedure(
    instrumentId: number,
    instrumentMaintenanceProcedure:
      | "GENERAL_CLEAN"
      | "OPTICS_CALIBRATION"
      | "DROP_CUVETTE"
      | "INITIALIZE"
      | "OFFSETS"
      | "SHUTDOWN"
      | "RESTART"
      | "FULL_SYSTEM_PRIME"
      | "FLOW_CELL_SOAK"
      | "DRAIN_MIX_CHAMBERS"
      | "SYSTEM_FLUSH"
      | "PRIME_REAGENT"
      | "PRIME_SHEATH"
      | "REPLACE_REAGENT"
      | "REPLACE_SHEATH"
      | "REPLACE_OBC"
      | "BLEACH_CLEAN"
      | "OPTIMIZE"
      | "DRAIN_RBC_ISOLATION_CHAMBER"
      | "DRAIN_REACTION_CHAMBER"
      | "DRAIN_WASTE_CHAMBER"
      | "AUTO_RINSE"
      | "MONTHLY_RINSE"
      | "FLOW_CELL_RINSE"
      | "WASTE_CHAMBER_RINSE"
      | "CLEAR_PINCH_VALVE"
      | "REMOVE_CLOG"
      | "RESET_AIR_PUMP"
      | "RESET_ASPIRATION_MOTOR"
      | "RESET_SHEATH_MOTOR"
      | "RESET_TUBE_MOTOR"
      | "RESET_WB_MOTOR"
      | "REPLENISH_REAGENT"
      | "REPLENISH_STAIN"
      | "MAINTENANCE_1"
      | "MAINTENANCE_2"
      | "MAINTENANCE_3"
      | "MAINTENANCE_4"
      | "MAINTENANCE_5"
      | "MAINTENANCE_6",
    options?: any
  ) {
    return TheiaApiFp(this.configuration).executeMaintenanceProcedure(
      instrumentId,
      instrumentMaintenanceProcedure,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch suggested runs to use for matching a Theia run against
   * @param {number} patientId patient to search for
   * @param {number} [limit] limit the number of results. Max is 500
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public fetchMatchSuggestions(
    patientId: number,
    limit?: number,
    options?: any
  ) {
    return TheiaApiFp(this.configuration).fetchMatchSuggestions(
      patientId,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Fetch supported barcodes types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public fetchSupportedBarcodeTypes(options?: any) {
    return TheiaApiFp(this.configuration).fetchSupportedBarcodeTypes(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get images for Theia run.
   * @param {number} instrumentRunId The instrument run Id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public getImagesForTheiaRun(instrumentRunId: number, options?: any) {
    return TheiaApiFp(this.configuration).getImagesForTheiaRun(
      instrumentRunId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TimeZoneApi - fetch parameter creator
 * @export
 */
export const TimeZoneApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch if time is syncing for this operation system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsTimeSyncing(options: any = {}): FetchArgs {
      const localVarPath = `/timeZone/sync`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get list of locations for use in selecting time zone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLocations(options: any = {}): FetchArgs {
      const localVarPath = `/timeZone/locations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMigrationType(options: any = {}): FetchArgs {
      const localVarPath = `/timeZone/migrationType`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * IANA Time Zone information for IVLS.
     * @summary Gets the IVLS time zone system configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZone(options: any = {}): FetchArgs {
      const localVarPath = `/timeZone`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the list of available time zones
     * @param {string} [countryCode] Country code to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZones(countryCode?: string, options: any = {}): FetchArgs {
      const localVarPath = `/timeZone/list`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (countryCode !== undefined) {
        localVarQueryParameter["countryCode"] = countryCode;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires reboot to take effect
     * @summary Update the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMigrationTypeToFull(options: any = {}): FetchArgs {
      const localVarPath = `/timeZone/migrationType`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates IVLS and OS time zone settings, and creates a new time zone record.
     * @summary Updates the IVLS time zone.
     * @param {TimeConfigurationDto} body The time zone settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTimeZone(body: TimeConfigurationDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateTimeZone."
        );
      }
      const localVarPath = `/timeZone`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TimeConfigurationDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TimeZoneApi - functional programming interface
 * @export
 */
export const TimeZoneApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Fetch if time is syncing for this operation system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsTimeSyncing(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        TimeZoneApiFetchParamCreator(configuration).fetchIsTimeSyncing(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get list of locations for use in selecting time zone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLocations(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LocationDto>> {
      const localVarFetchArgs =
        TimeZoneApiFetchParamCreator(configuration).fetchLocations(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMigrationType(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        TimeZoneApiFetchParamCreator(configuration).fetchMigrationType(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * IANA Time Zone information for IVLS.
     * @summary Gets the IVLS time zone system configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZone(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TimeConfigurationDto> {
      const localVarFetchArgs =
        TimeZoneApiFetchParamCreator(configuration).fetchTimeZone(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the list of available time zones
     * @param {string} [countryCode] Country code to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZones(
      countryCode?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TimeZoneDto>> {
      const localVarFetchArgs = TimeZoneApiFetchParamCreator(
        configuration
      ).fetchTimeZones(countryCode, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Requires reboot to take effect
     * @summary Update the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMigrationTypeToFull(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        TimeZoneApiFetchParamCreator(configuration).updateMigrationTypeToFull(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Updates IVLS and OS time zone settings, and creates a new time zone record.
     * @summary Updates the IVLS time zone.
     * @param {TimeConfigurationDto} body The time zone settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTimeZone(
      body: TimeConfigurationDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = TimeZoneApiFetchParamCreator(
        configuration
      ).updateTimeZone(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TimeZoneApi - factory interface
 * @export
 */
export const TimeZoneApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch if time is syncing for this operation system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIsTimeSyncing(options?: any) {
      return TimeZoneApiFp(configuration).fetchIsTimeSyncing(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get list of locations for use in selecting time zone
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLocations(options?: any) {
      return TimeZoneApiFp(configuration).fetchLocations(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Fetch the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchMigrationType(options?: any) {
      return TimeZoneApiFp(configuration).fetchMigrationType(options)(
        fetch,
        basePath
      );
    },
    /**
     * IANA Time Zone information for IVLS.
     * @summary Gets the IVLS time zone system configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZone(options?: any) {
      return TimeZoneApiFp(configuration).fetchTimeZone(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the list of available time zones
     * @param {string} [countryCode] Country code to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTimeZones(countryCode?: string, options?: any) {
      return TimeZoneApiFp(configuration).fetchTimeZones(countryCode, options)(
        fetch,
        basePath
      );
    },
    /**
     * Requires reboot to take effect
     * @summary Update the migration type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMigrationTypeToFull(options?: any) {
      return TimeZoneApiFp(configuration).updateMigrationTypeToFull(options)(
        fetch,
        basePath
      );
    },
    /**
     * Updates IVLS and OS time zone settings, and creates a new time zone record.
     * @summary Updates the IVLS time zone.
     * @param {TimeConfigurationDto} body The time zone settings to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTimeZone(body: TimeConfigurationDto, options?: any) {
      return TimeZoneApiFp(configuration).updateTimeZone(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * TimeZoneApi - object-oriented interface
 * @export
 * @class TimeZoneApi
 * @extends {BaseAPI}
 */
export class TimeZoneApi extends BaseAPI {
  /**
   *
   * @summary Fetch if time is syncing for this operation system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public fetchIsTimeSyncing(options?: any) {
    return TimeZoneApiFp(this.configuration).fetchIsTimeSyncing(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get list of locations for use in selecting time zone
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public fetchLocations(options?: any) {
    return TimeZoneApiFp(this.configuration).fetchLocations(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch the migration type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public fetchMigrationType(options?: any) {
    return TimeZoneApiFp(this.configuration).fetchMigrationType(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * IANA Time Zone information for IVLS.
   * @summary Gets the IVLS time zone system configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public fetchTimeZone(options?: any) {
    return TimeZoneApiFp(this.configuration).fetchTimeZone(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the list of available time zones
   * @param {string} [countryCode] Country code to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public fetchTimeZones(countryCode?: string, options?: any) {
    return TimeZoneApiFp(this.configuration).fetchTimeZones(
      countryCode,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Requires reboot to take effect
   * @summary Update the migration type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public updateMigrationTypeToFull(options?: any) {
    return TimeZoneApiFp(this.configuration).updateMigrationTypeToFull(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Updates IVLS and OS time zone settings, and creates a new time zone record.
   * @summary Updates the IVLS time zone.
   * @param {TimeConfigurationDto} body The time zone settings to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimeZoneApi
   */
  public updateTimeZone(body: TimeConfigurationDto, options?: any) {
    return TimeZoneApiFp(this.configuration).updateTimeZone(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * UpgradeApi - fetch parameter creator
 * @export
 */
export const UpgradeApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get available upgrade mediums.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAvailableUpgradeMediums(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/upgrade_mediums`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the system software version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSoftwareVersion(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/system_software_version`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if an upgrade is available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeAvailable(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/upgrade_available`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeStatus(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/status/fetch`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the USB upgrade letter.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeLetter(usbId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/usb/upgradeLetter`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the USB upgrade properties.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeProperties(usbId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/usb/properties`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns true if there is a valid upgrade folder on the USB drive
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasValidUpgrade(usbId?: string, options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/valid/USB`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resets the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUpgradeStatus(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/status/reset`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform a CD upgrade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeByCD(options: any = {}): FetchArgs {
      const localVarPath = `/upgrade/perform/CD`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform a SmartService upgrade.
     * @param {"later" | "upgrade" | "upgradeManual"} action The SmartService upgrade action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeBySmartService(
      action: "later" | "upgrade" | "upgradeManual",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'action' is not null or undefined
      if (action === null || action === undefined) {
        throw new RequiredError(
          "action",
          "Required parameter action was null or undefined when calling upgradeBySmartService."
        );
      }
      const localVarPath = `/upgrade/perform/SmartService/{action}`.replace(
        `{${"action"}}`,
        encodeURIComponent(String(action))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Perform an upgrade that has been previously copied to a temp folder, given the usbCopyId
     * @param {UpgradeRequestDto} body Upgrade request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeCopiedUsbInstaller(
      body: UpgradeRequestDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling upgradeCopiedUsbInstaller."
        );
      }
      const localVarPath = `/upgrade/perform/copied_usb`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpgradeRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UpgradeApi - functional programming interface
 * @export
 */
export const UpgradeApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get available upgrade mediums.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAvailableUpgradeMediums(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).fetchAvailableUpgradeMediums(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the system software version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSoftwareVersion(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).fetchSoftwareVersion(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Check if an upgrade is available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeAvailable(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradeAvailableDto> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).fetchUpgradeAvailable(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeStatus(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradeStatusDto> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).fetchUpgradeStatus(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the USB upgrade letter.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeLetter(
      usbId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradeLetterDto> {
      const localVarFetchArgs = UpgradeApiFetchParamCreator(
        configuration
      ).fetchUsbUpgradeLetter(usbId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the USB upgrade properties.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeProperties(
      usbId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradePropertiesDto> {
      const localVarFetchArgs = UpgradeApiFetchParamCreator(
        configuration
      ).fetchUsbUpgradeProperties(usbId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Returns true if there is a valid upgrade folder on the USB drive
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasValidUpgrade(
      usbId?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = UpgradeApiFetchParamCreator(
        configuration
      ).hasValidUpgrade(usbId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Resets the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUpgradeStatus(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).resetUpgradeStatus(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform a CD upgrade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeByCD(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradeResultDto> {
      const localVarFetchArgs =
        UpgradeApiFetchParamCreator(configuration).upgradeByCD(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform a SmartService upgrade.
     * @param {"later" | "upgrade" | "upgradeManual"} action The SmartService upgrade action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeBySmartService(
      action: "later" | "upgrade" | "upgradeManual",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UpgradeApiFetchParamCreator(
        configuration
      ).upgradeBySmartService(action, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Perform an upgrade that has been previously copied to a temp folder, given the usbCopyId
     * @param {UpgradeRequestDto} body Upgrade request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeCopiedUsbInstaller(
      body: UpgradeRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpgradeResultDto> {
      const localVarFetchArgs = UpgradeApiFetchParamCreator(
        configuration
      ).upgradeCopiedUsbInstaller(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UpgradeApi - factory interface
 * @export
 */
export const UpgradeApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get available upgrade mediums.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAvailableUpgradeMediums(options?: any) {
      return UpgradeApiFp(configuration).fetchAvailableUpgradeMediums(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the system software version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchSoftwareVersion(options?: any) {
      return UpgradeApiFp(configuration).fetchSoftwareVersion(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Check if an upgrade is available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeAvailable(options?: any) {
      return UpgradeApiFp(configuration).fetchUpgradeAvailable(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgradeStatus(options?: any) {
      return UpgradeApiFp(configuration).fetchUpgradeStatus(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the USB upgrade letter.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeLetter(usbId?: string, options?: any) {
      return UpgradeApiFp(configuration).fetchUsbUpgradeLetter(usbId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the USB upgrade properties.
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbUpgradeProperties(usbId?: string, options?: any) {
      return UpgradeApiFp(configuration).fetchUsbUpgradeProperties(
        usbId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Returns true if there is a valid upgrade folder on the USB drive
     * @param {string} [usbId] The USB id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hasValidUpgrade(usbId?: string, options?: any) {
      return UpgradeApiFp(configuration).hasValidUpgrade(usbId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Resets the upgrade status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetUpgradeStatus(options?: any) {
      return UpgradeApiFp(configuration).resetUpgradeStatus(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Perform a CD upgrade.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeByCD(options?: any) {
      return UpgradeApiFp(configuration).upgradeByCD(options)(fetch, basePath);
    },
    /**
     *
     * @summary Perform a SmartService upgrade.
     * @param {"later" | "upgrade" | "upgradeManual"} action The SmartService upgrade action.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeBySmartService(
      action: "later" | "upgrade" | "upgradeManual",
      options?: any
    ) {
      return UpgradeApiFp(configuration).upgradeBySmartService(action, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Perform an upgrade that has been previously copied to a temp folder, given the usbCopyId
     * @param {UpgradeRequestDto} body Upgrade request parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upgradeCopiedUsbInstaller(body: UpgradeRequestDto, options?: any) {
      return UpgradeApiFp(configuration).upgradeCopiedUsbInstaller(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UpgradeApi - object-oriented interface
 * @export
 * @class UpgradeApi
 * @extends {BaseAPI}
 */
export class UpgradeApi extends BaseAPI {
  /**
   *
   * @summary Get available upgrade mediums.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchAvailableUpgradeMediums(options?: any) {
    return UpgradeApiFp(this.configuration).fetchAvailableUpgradeMediums(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the system software version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchSoftwareVersion(options?: any) {
    return UpgradeApiFp(this.configuration).fetchSoftwareVersion(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Check if an upgrade is available.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchUpgradeAvailable(options?: any) {
    return UpgradeApiFp(this.configuration).fetchUpgradeAvailable(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the upgrade status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchUpgradeStatus(options?: any) {
    return UpgradeApiFp(this.configuration).fetchUpgradeStatus(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the USB upgrade letter.
   * @param {string} [usbId] The USB id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchUsbUpgradeLetter(usbId?: string, options?: any) {
    return UpgradeApiFp(this.configuration).fetchUsbUpgradeLetter(
      usbId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the USB upgrade properties.
   * @param {string} [usbId] The USB id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public fetchUsbUpgradeProperties(usbId?: string, options?: any) {
    return UpgradeApiFp(this.configuration).fetchUsbUpgradeProperties(
      usbId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Returns true if there is a valid upgrade folder on the USB drive
   * @param {string} [usbId] The USB id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public hasValidUpgrade(usbId?: string, options?: any) {
    return UpgradeApiFp(this.configuration).hasValidUpgrade(usbId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Resets the upgrade status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public resetUpgradeStatus(options?: any) {
    return UpgradeApiFp(this.configuration).resetUpgradeStatus(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Perform a CD upgrade.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public upgradeByCD(options?: any) {
    return UpgradeApiFp(this.configuration).upgradeByCD(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Perform a SmartService upgrade.
   * @param {"later" | "upgrade" | "upgradeManual"} action The SmartService upgrade action.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public upgradeBySmartService(
    action: "later" | "upgrade" | "upgradeManual",
    options?: any
  ) {
    return UpgradeApiFp(this.configuration).upgradeBySmartService(
      action,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Perform an upgrade that has been previously copied to a temp folder, given the usbCopyId
   * @param {UpgradeRequestDto} body Upgrade request parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UpgradeApi
   */
  public upgradeCopiedUsbInstaller(body: UpgradeRequestDto, options?: any) {
    return UpgradeApiFp(this.configuration).upgradeCopiedUsbInstaller(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UriSysDxMaintenanceApi - fetch parameter creator
 * @export
 */
export const UriSysDxMaintenanceApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Request the Initialize (aka self-check) maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInitialize(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestInitialize."
        );
      }
      const localVarPath =
        `/instruments/urisysdx/{instrumentId}/maintenance/initialize/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling requestShutDown."
        );
      }
      const localVarPath =
        `/instruments/urisysdx/{instrumentId}/maintenance/shutdown/request`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UriSysDxMaintenanceApi - functional programming interface
 * @export
 */
export const UriSysDxMaintenanceApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Request the Initialize (aka self-check) maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInitialize(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UriSysDxMaintenanceApiFetchParamCreator(
        configuration
      ).requestInitialize(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UriSysDxMaintenanceApiFetchParamCreator(
        configuration
      ).requestShutDown(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UriSysDxMaintenanceApi - factory interface
 * @export
 */
export const UriSysDxMaintenanceApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Request the Initialize (aka self-check) maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInitialize(instrumentId: number, options?: any) {
      return UriSysDxMaintenanceApiFp(configuration).requestInitialize(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Request the Shut down maintenance procedure.
     * @param {number} instrumentId The instrument ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestShutDown(instrumentId: number, options?: any) {
      return UriSysDxMaintenanceApiFp(configuration).requestShutDown(
        instrumentId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UriSysDxMaintenanceApi - object-oriented interface
 * @export
 * @class UriSysDxMaintenanceApi
 * @extends {BaseAPI}
 */
export class UriSysDxMaintenanceApi extends BaseAPI {
  /**
   *
   * @summary Request the Initialize (aka self-check) maintenance procedure.
   * @param {number} instrumentId The instrument ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UriSysDxMaintenanceApi
   */
  public requestInitialize(instrumentId: number, options?: any) {
    return UriSysDxMaintenanceApiFp(this.configuration).requestInitialize(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Request the Shut down maintenance procedure.
   * @param {number} instrumentId The instrument ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UriSysDxMaintenanceApi
   */
  public requestShutDown(instrumentId: number, options?: any) {
    return UriSysDxMaintenanceApiFp(this.configuration).requestShutDown(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UriSysDxQualityControlApi - fetch parameter creator
 * @export
 */
export const UriSysDxQualityControlApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get quality control runs for the specified UriSys Dx
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUriSysDxQualityControlRuns(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchUriSysDxQualityControlRuns."
        );
      }
      const localVarPath =
        `/uriSysDxQualityControl/{instrumentId}/runs`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UriSysDxQualityControlApi - functional programming interface
 * @export
 */
export const UriSysDxQualityControlApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get quality control runs for the specified UriSys Dx
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUriSysDxQualityControlRuns(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<UriSysDxQualityControlRunRecordDto>> {
      const localVarFetchArgs = UriSysDxQualityControlApiFetchParamCreator(
        configuration
      ).fetchUriSysDxQualityControlRuns(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UriSysDxQualityControlApi - factory interface
 * @export
 */
export const UriSysDxQualityControlApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get quality control runs for the specified UriSys Dx
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUriSysDxQualityControlRuns(instrumentId: number, options?: any) {
      return UriSysDxQualityControlApiFp(
        configuration
      ).fetchUriSysDxQualityControlRuns(instrumentId, options)(fetch, basePath);
    },
  };
};

/**
 * UriSysDxQualityControlApi - object-oriented interface
 * @export
 * @class UriSysDxQualityControlApi
 * @extends {BaseAPI}
 */
export class UriSysDxQualityControlApi extends BaseAPI {
  /**
   *
   * @summary Get quality control runs for the specified UriSys Dx
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UriSysDxQualityControlApi
   */
  public fetchUriSysDxQualityControlRuns(instrumentId: number, options?: any) {
    return UriSysDxQualityControlApiFp(
      this.configuration
    ).fetchUriSysDxQualityControlRuns(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * UsbApi - fetch parameter creator
 * @export
 */
export const UsbApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get backup size in bytes.
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateBackupSize(
      body: BackupMetadataWrapperDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling calculateBackupSize."
        );
      }
      const localVarPath = `/usb/backup/size`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BackupMetadataWrapperDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancels an in-process USB copy
     * @param {string} copyId The copy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelCopy(copyId: string, options: any = {}): FetchArgs {
      // verify required parameter 'copyId' is not null or undefined
      if (copyId === null || copyId === undefined) {
        throw new RequiredError(
          "copyId",
          "Required parameter copyId was null or undefined when calling cancelCopy."
        );
      }
      const localVarPath = `/usb/copy/cancel`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (copyId !== undefined) {
        localVarQueryParameter["copyId"] = copyId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copy a backup to the selected USB drive
     * @param {string} usbId The USB ID
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbBackup(
      usbId: string,
      body: BackupMetadataWrapperDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'usbId' is not null or undefined
      if (usbId === null || usbId === undefined) {
        throw new RequiredError(
          "usbId",
          "Required parameter usbId was null or undefined when calling copyUsbBackup."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling copyUsbBackup."
        );
      }
      const localVarPath = `/usb/backup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BackupMetadataWrapperDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Copies the USB installer files to a temporary folder for installation
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbUpgradeInstallFiles(usbId: string, options: any = {}): FetchArgs {
      // verify required parameter 'usbId' is not null or undefined
      if (usbId === null || usbId === undefined) {
        throw new RequiredError(
          "usbId",
          "Required parameter usbId was null or undefined when calling copyUsbUpgradeInstallFiles."
        );
      }
      const localVarPath = `/usb/copy/upgrade`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the candidate backups
     * @param {Array<BackupMetadataWrapperDto>} body List of backup metadata wrappers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBackups(
      body: Array<BackupMetadataWrapperDto>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteBackups."
        );
      }
      const localVarPath = `/usb/backup/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"Array&lt;BackupMetadataWrapperDto&gt;" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Checks whether there are any USB drives connected to the IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDrivesAreConnected(options: any = {}): FetchArgs {
      const localVarPath = `/usb/drivesAreConnected`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all USB drives.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbDrives(options: any = {}): FetchArgs {
      const localVarPath = `/usb/drives`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Format a USB drive
     * @param {string} removableDriveKey They key of the USB drive to format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formatUsbDrive(removableDriveKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'removableDriveKey' is not null or undefined
      if (removableDriveKey === null || removableDriveKey === undefined) {
        throw new RequiredError(
          "removableDriveKey",
          "Required parameter removableDriveKey was null or undefined when calling formatUsbDrive."
        );
      }
      const localVarPath = `/usb/{removableDriveKey}/format`.replace(
        `{${"removableDriveKey"}}`,
        encodeURIComponent(String(removableDriveKey))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the candidate backups for deletion
     * @param {string} usbId The USB ID
     * @param {number} backupSize The amount of space needed for the backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeletableCandidates(
      usbId: string,
      backupSize: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'usbId' is not null or undefined
      if (usbId === null || usbId === undefined) {
        throw new RequiredError(
          "usbId",
          "Required parameter usbId was null or undefined when calling getDeletableCandidates."
        );
      }
      // verify required parameter 'backupSize' is not null or undefined
      if (backupSize === null || backupSize === undefined) {
        throw new RequiredError(
          "backupSize",
          "Required parameter backupSize was null or undefined when calling getDeletableCandidates."
        );
      }
      const localVarPath = `/usb/backup/deletable`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (usbId !== undefined) {
        localVarQueryParameter["usbId"] = usbId;
      }

      if (backupSize !== undefined) {
        localVarQueryParameter["backupSize"] = backupSize;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a USB drive.
     * @param {string} removableDriveKey They key of the USB drive to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbDrive(removableDriveKey: string, options: any = {}): FetchArgs {
      // verify required parameter 'removableDriveKey' is not null or undefined
      if (removableDriveKey === null || removableDriveKey === undefined) {
        throw new RequiredError(
          "removableDriveKey",
          "Required parameter removableDriveKey was null or undefined when calling getUsbDrive."
        );
      }
      const localVarPath = `/usb/{removableDriveKey}`.replace(
        `{${"removableDriveKey"}}`,
        encodeURIComponent(String(removableDriveKey))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsbApi - functional programming interface
 * @export
 */
export const UsbApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get backup size in bytes.
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateBackupSize(
      body: BackupMetadataWrapperDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).calculateBackupSize(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cancels an in-process USB copy
     * @param {string} copyId The copy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelCopy(
      copyId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).cancelCopy(copyId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Copy a backup to the selected USB drive
     * @param {string} usbId The USB ID
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbBackup(
      usbId: string,
      body: BackupMetadataWrapperDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).copyUsbBackup(usbId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Copies the USB installer files to a temporary folder for installation
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbUpgradeInstallFiles(
      usbId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<UsbUpgradeCopyResultDto> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).copyUsbUpgradeInstallFiles(usbId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Delete the candidate backups
     * @param {Array<BackupMetadataWrapperDto>} body List of backup metadata wrappers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBackups(
      body: Array<BackupMetadataWrapperDto>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).deleteBackups(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Checks whether there are any USB drives connected to the IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDrivesAreConnected(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        UsbApiFetchParamCreator(configuration).fetchDrivesAreConnected(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get all USB drives.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbDrives(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<RemovableDriveDto>> {
      const localVarFetchArgs =
        UsbApiFetchParamCreator(configuration).fetchUsbDrives(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Format a USB drive
     * @param {string} removableDriveKey They key of the USB drive to format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formatUsbDrive(
      removableDriveKey: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RemovableDriveDto> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).formatUsbDrive(removableDriveKey, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the candidate backups for deletion
     * @param {string} usbId The USB ID
     * @param {number} backupSize The amount of space needed for the backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeletableCandidates(
      usbId: string,
      backupSize: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<BackupMetadataDto>> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).getDeletableCandidates(usbId, backupSize, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get a USB drive.
     * @param {string} removableDriveKey They key of the USB drive to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbDrive(
      removableDriveKey: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RemovableDriveDto> {
      const localVarFetchArgs = UsbApiFetchParamCreator(
        configuration
      ).getUsbDrive(removableDriveKey, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UsbApi - factory interface
 * @export
 */
export const UsbApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get backup size in bytes.
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateBackupSize(body: BackupMetadataWrapperDto, options?: any) {
      return UsbApiFp(configuration).calculateBackupSize(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Cancels an in-process USB copy
     * @param {string} copyId The copy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelCopy(copyId: string, options?: any) {
      return UsbApiFp(configuration).cancelCopy(copyId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Copy a backup to the selected USB drive
     * @param {string} usbId The USB ID
     * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbBackup(
      usbId: string,
      body: BackupMetadataWrapperDto,
      options?: any
    ) {
      return UsbApiFp(configuration).copyUsbBackup(
        usbId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Copies the USB installer files to a temporary folder for installation
     * @param {string} usbId The USB ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyUsbUpgradeInstallFiles(usbId: string, options?: any) {
      return UsbApiFp(configuration).copyUsbUpgradeInstallFiles(usbId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Delete the candidate backups
     * @param {Array<BackupMetadataWrapperDto>} body List of backup metadata wrappers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBackups(body: Array<BackupMetadataWrapperDto>, options?: any) {
      return UsbApiFp(configuration).deleteBackups(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Checks whether there are any USB drives connected to the IVLS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchDrivesAreConnected(options?: any) {
      return UsbApiFp(configuration).fetchDrivesAreConnected(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get all USB drives.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUsbDrives(options?: any) {
      return UsbApiFp(configuration).fetchUsbDrives(options)(fetch, basePath);
    },
    /**
     *
     * @summary Format a USB drive
     * @param {string} removableDriveKey They key of the USB drive to format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formatUsbDrive(removableDriveKey: string, options?: any) {
      return UsbApiFp(configuration).formatUsbDrive(removableDriveKey, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the candidate backups for deletion
     * @param {string} usbId The USB ID
     * @param {number} backupSize The amount of space needed for the backup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeletableCandidates(usbId: string, backupSize: number, options?: any) {
      return UsbApiFp(configuration).getDeletableCandidates(
        usbId,
        backupSize,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get a USB drive.
     * @param {string} removableDriveKey They key of the USB drive to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsbDrive(removableDriveKey: string, options?: any) {
      return UsbApiFp(configuration).getUsbDrive(removableDriveKey, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * UsbApi - object-oriented interface
 * @export
 * @class UsbApi
 * @extends {BaseAPI}
 */
export class UsbApi extends BaseAPI {
  /**
   *
   * @summary Get backup size in bytes.
   * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public calculateBackupSize(body: BackupMetadataWrapperDto, options?: any) {
    return UsbApiFp(this.configuration).calculateBackupSize(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Cancels an in-process USB copy
   * @param {string} copyId The copy ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public cancelCopy(copyId: string, options?: any) {
    return UsbApiFp(this.configuration).cancelCopy(copyId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Copy a backup to the selected USB drive
   * @param {string} usbId The USB ID
   * @param {BackupMetadataWrapperDto} body Object which holds metadata as well as a path to the metadata json file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public copyUsbBackup(
    usbId: string,
    body: BackupMetadataWrapperDto,
    options?: any
  ) {
    return UsbApiFp(this.configuration).copyUsbBackup(
      usbId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Copies the USB installer files to a temporary folder for installation
   * @param {string} usbId The USB ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public copyUsbUpgradeInstallFiles(usbId: string, options?: any) {
    return UsbApiFp(this.configuration).copyUsbUpgradeInstallFiles(
      usbId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Delete the candidate backups
   * @param {Array<BackupMetadataWrapperDto>} body List of backup metadata wrappers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public deleteBackups(body: Array<BackupMetadataWrapperDto>, options?: any) {
    return UsbApiFp(this.configuration).deleteBackups(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Checks whether there are any USB drives connected to the IVLS
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public fetchDrivesAreConnected(options?: any) {
    return UsbApiFp(this.configuration).fetchDrivesAreConnected(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get all USB drives.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public fetchUsbDrives(options?: any) {
    return UsbApiFp(this.configuration).fetchUsbDrives(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Format a USB drive
   * @param {string} removableDriveKey They key of the USB drive to format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public formatUsbDrive(removableDriveKey: string, options?: any) {
    return UsbApiFp(this.configuration).formatUsbDrive(
      removableDriveKey,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the candidate backups for deletion
   * @param {string} usbId The USB ID
   * @param {number} backupSize The amount of space needed for the backup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public getDeletableCandidates(
    usbId: string,
    backupSize: number,
    options?: any
  ) {
    return UsbApiFp(this.configuration).getDeletableCandidates(
      usbId,
      backupSize,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get a USB drive.
   * @param {string} removableDriveKey They key of the USB drive to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsbApi
   */
  public getUsbDrive(removableDriveKey: string, options?: any) {
    return UsbApiFp(this.configuration).getUsbDrive(removableDriveKey, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * UserEventsApi - fetch parameter creator
 * @export
 */
export const UserEventsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Log that the suggestion dialog was shown to the user
     * @param {SuggestionDialogShownDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogShown(
      body: SuggestionDialogShownDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling logSuggestionDialogShown."
        );
      }
      const localVarPath = `/userEvents/suggestionDialog`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SuggestionDialogShownDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Log that the user clicked the create new patient button
     * @param {SuggestionDialogCreateNewPatientDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserCreateNewPatient(
      body: SuggestionDialogCreateNewPatientDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling logSuggestionDialogUserCreateNewPatient."
        );
      }
      const localVarPath = `/userEvents/suggestionDialog/createNewPatient`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SuggestionDialogCreateNewPatientDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Log that the user clicked the match button
     * @param {SuggestionDialogUserMatchDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserMatch(
      body: SuggestionDialogUserMatchDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling logSuggestionDialogUserMatch."
        );
      }
      const localVarPath = `/userEvents/suggestionDialog/userMatch`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SuggestionDialogUserMatchDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserEventsApi - functional programming interface
 * @export
 */
export const UserEventsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Log that the suggestion dialog was shown to the user
     * @param {SuggestionDialogShownDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogShown(
      body: SuggestionDialogShownDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UserEventsApiFetchParamCreator(
        configuration
      ).logSuggestionDialogShown(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Log that the user clicked the create new patient button
     * @param {SuggestionDialogCreateNewPatientDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserCreateNewPatient(
      body: SuggestionDialogCreateNewPatientDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UserEventsApiFetchParamCreator(
        configuration
      ).logSuggestionDialogUserCreateNewPatient(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Log that the user clicked the match button
     * @param {SuggestionDialogUserMatchDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserMatch(
      body: SuggestionDialogUserMatchDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = UserEventsApiFetchParamCreator(
        configuration
      ).logSuggestionDialogUserMatch(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserEventsApi - factory interface
 * @export
 */
export const UserEventsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Log that the suggestion dialog was shown to the user
     * @param {SuggestionDialogShownDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogShown(body: SuggestionDialogShownDto, options?: any) {
      return UserEventsApiFp(configuration).logSuggestionDialogShown(
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Log that the user clicked the create new patient button
     * @param {SuggestionDialogCreateNewPatientDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserCreateNewPatient(
      body: SuggestionDialogCreateNewPatientDto,
      options?: any
    ) {
      return UserEventsApiFp(
        configuration
      ).logSuggestionDialogUserCreateNewPatient(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Log that the user clicked the match button
     * @param {SuggestionDialogUserMatchDto} body Metric event data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logSuggestionDialogUserMatch(
      body: SuggestionDialogUserMatchDto,
      options?: any
    ) {
      return UserEventsApiFp(configuration).logSuggestionDialogUserMatch(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UserEventsApi - object-oriented interface
 * @export
 * @class UserEventsApi
 * @extends {BaseAPI}
 */
export class UserEventsApi extends BaseAPI {
  /**
   *
   * @summary Log that the suggestion dialog was shown to the user
   * @param {SuggestionDialogShownDto} body Metric event data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEventsApi
   */
  public logSuggestionDialogShown(
    body: SuggestionDialogShownDto,
    options?: any
  ) {
    return UserEventsApiFp(this.configuration).logSuggestionDialogShown(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Log that the user clicked the create new patient button
   * @param {SuggestionDialogCreateNewPatientDto} body Metric event data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEventsApi
   */
  public logSuggestionDialogUserCreateNewPatient(
    body: SuggestionDialogCreateNewPatientDto,
    options?: any
  ) {
    return UserEventsApiFp(
      this.configuration
    ).logSuggestionDialogUserCreateNewPatient(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Log that the user clicked the match button
   * @param {SuggestionDialogUserMatchDto} body Metric event data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEventsApi
   */
  public logSuggestionDialogUserMatch(
    body: SuggestionDialogUserMatchDto,
    options?: any
  ) {
    return UserEventsApiFp(this.configuration).logSuggestionDialogUserMatch(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * VcpApi - fetch parameter creator
 * @export
 */
export const VcpApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Activates VetConnect PLUS.
     * @param {VcpActivationRequestDto} [body] The VCP activation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(body?: VcpActivationRequestDto, options: any = {}): FetchArgs {
      const localVarPath = `/vcp/activate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"VcpActivationRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deactivates VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivate(options: any = {}): FetchArgs {
      const localVarPath = `/vcp/deactivate`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns true if IVLS is able to establish a connection with VetConnect PLUS, otherwise false.
     * @summary Tests the connection between IVLS and VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCanConnect(options: any = {}): FetchArgs {
      const localVarPath = `/vcp/connection/test`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns true if IVLS Great News notification should be shown.
     * @summary Get Great News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchShowGreatNews(options: any = {}): FetchArgs {
      const localVarPath = `/vcp/showGreatNews`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch VetConnect PLUS related statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchVcpConfiguration(options: any = {}): FetchArgs {
      const localVarPath = `/vcp/configuration`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the enabled status of DxPortal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDxPortalIsEnabled(options: any = {}): FetchArgs {
      const localVarPath = `/vcp/dxportalEnabled`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set Great News notification status. Pass 'true' to show on next reboot.
     * @summary Set Great News status.
     * @param {boolean} [body] The VCPGreat News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setShowGreatNews(body?: boolean, options: any = {}): FetchArgs {
      const localVarPath = `/vcp/showGreatNews`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"boolean" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VcpApi - functional programming interface
 * @export
 */
export const VcpApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Activates VetConnect PLUS.
     * @param {VcpActivationRequestDto} [body] The VCP activation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(
      body?: VcpActivationRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = VcpApiFetchParamCreator(configuration).activate(
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Deactivates VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivate(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        VcpApiFetchParamCreator(configuration).deactivate(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns true if IVLS is able to establish a connection with VetConnect PLUS, otherwise false.
     * @summary Tests the connection between IVLS and VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCanConnect(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        VcpApiFetchParamCreator(configuration).fetchCanConnect(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns true if IVLS Great News notification should be shown.
     * @summary Get Great News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchShowGreatNews(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs =
        VcpApiFetchParamCreator(configuration).fetchShowGreatNews(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch VetConnect PLUS related statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchVcpConfiguration(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VcpConfigurationDto> {
      const localVarFetchArgs =
        VcpApiFetchParamCreator(configuration).fetchVcpConfiguration(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the enabled status of DxPortal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDxPortalIsEnabled(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        VcpApiFetchParamCreator(configuration).setDxPortalIsEnabled(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Set Great News notification status. Pass 'true' to show on next reboot.
     * @summary Set Great News status.
     * @param {boolean} [body] The VCPGreat News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setShowGreatNews(
      body?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = VcpApiFetchParamCreator(
        configuration
      ).setShowGreatNews(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * VcpApi - factory interface
 * @export
 */
export const VcpApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Activates VetConnect PLUS.
     * @param {VcpActivationRequestDto} [body] The VCP activation request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(body?: VcpActivationRequestDto, options?: any) {
      return VcpApiFp(configuration).activate(body, options)(fetch, basePath);
    },
    /**
     *
     * @summary Deactivates VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivate(options?: any) {
      return VcpApiFp(configuration).deactivate(options)(fetch, basePath);
    },
    /**
     * Returns true if IVLS is able to establish a connection with VetConnect PLUS, otherwise false.
     * @summary Tests the connection between IVLS and VetConnect PLUS.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCanConnect(options?: any) {
      return VcpApiFp(configuration).fetchCanConnect(options)(fetch, basePath);
    },
    /**
     * Returns true if IVLS Great News notification should be shown.
     * @summary Get Great News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchShowGreatNews(options?: any) {
      return VcpApiFp(configuration).fetchShowGreatNews(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Fetch VetConnect PLUS related statuses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchVcpConfiguration(options?: any) {
      return VcpApiFp(configuration).fetchVcpConfiguration(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Sets the enabled status of DxPortal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setDxPortalIsEnabled(options?: any) {
      return VcpApiFp(configuration).setDxPortalIsEnabled(options)(
        fetch,
        basePath
      );
    },
    /**
     * Set Great News notification status. Pass 'true' to show on next reboot.
     * @summary Set Great News status.
     * @param {boolean} [body] The VCPGreat News status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setShowGreatNews(body?: boolean, options?: any) {
      return VcpApiFp(configuration).setShowGreatNews(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * VcpApi - object-oriented interface
 * @export
 * @class VcpApi
 * @extends {BaseAPI}
 */
export class VcpApi extends BaseAPI {
  /**
   *
   * @summary Activates VetConnect PLUS.
   * @param {VcpActivationRequestDto} [body] The VCP activation request.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public activate(body?: VcpActivationRequestDto, options?: any) {
    return VcpApiFp(this.configuration).activate(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Deactivates VetConnect PLUS.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public deactivate(options?: any) {
    return VcpApiFp(this.configuration).deactivate(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns true if IVLS is able to establish a connection with VetConnect PLUS, otherwise false.
   * @summary Tests the connection between IVLS and VetConnect PLUS.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public fetchCanConnect(options?: any) {
    return VcpApiFp(this.configuration).fetchCanConnect(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns true if IVLS Great News notification should be shown.
   * @summary Get Great News status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public fetchShowGreatNews(options?: any) {
    return VcpApiFp(this.configuration).fetchShowGreatNews(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch VetConnect PLUS related statuses
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public fetchVcpConfiguration(options?: any) {
    return VcpApiFp(this.configuration).fetchVcpConfiguration(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Sets the enabled status of DxPortal
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public setDxPortalIsEnabled(options?: any) {
    return VcpApiFp(this.configuration).setDxPortalIsEnabled(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Set Great News notification status. Pass 'true' to show on next reboot.
   * @summary Set Great News status.
   * @param {boolean} [body] The VCPGreat News status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcpApi
   */
  public setShowGreatNews(body?: boolean, options?: any) {
    return VcpApiFp(this.configuration).setShowGreatNews(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * ViewPointApi - fetch parameter creator
 * @export
 */
export const ViewPointApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Check whether the ViewPoint web client is current enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivation(options: any = {}): FetchArgs {
      const localVarPath = `/viewPoint/activation`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Enable/disable the ViewPoint web client
     * @param {ViewPointActivationStatusDto} [body] Whether to enable the ViewPoint client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActivation(
      body?: ViewPointActivationStatusDto,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/viewPoint/activation`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"ViewPointActivationStatusDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ViewPointApi - functional programming interface
 * @export
 */
export const ViewPointApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check whether the ViewPoint web client is current enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivation(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ViewPointActivationStatusDto> {
      const localVarFetchArgs =
        ViewPointApiFetchParamCreator(configuration).getActivation(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Enable/disable the ViewPoint web client
     * @param {ViewPointActivationStatusDto} [body] Whether to enable the ViewPoint client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActivation(
      body?: ViewPointActivationStatusDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = ViewPointApiFetchParamCreator(
        configuration
      ).setActivation(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ViewPointApi - factory interface
 * @export
 */
export const ViewPointApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Check whether the ViewPoint web client is current enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivation(options?: any) {
      return ViewPointApiFp(configuration).getActivation(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Enable/disable the ViewPoint web client
     * @param {ViewPointActivationStatusDto} [body] Whether to enable the ViewPoint client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActivation(body?: ViewPointActivationStatusDto, options?: any) {
      return ViewPointApiFp(configuration).setActivation(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * ViewPointApi - object-oriented interface
 * @export
 * @class ViewPointApi
 * @extends {BaseAPI}
 */
export class ViewPointApi extends BaseAPI {
  /**
   *
   * @summary Check whether the ViewPoint web client is current enabled
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewPointApi
   */
  public getActivation(options?: any) {
    return ViewPointApiFp(this.configuration).getActivation(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Enable/disable the ViewPoint web client
   * @param {ViewPointActivationStatusDto} [body] Whether to enable the ViewPoint client
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ViewPointApi
   */
  public setActivation(body?: ViewPointActivationStatusDto, options?: any) {
    return ViewPointApiFp(this.configuration).setActivation(body, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * WizardApi - fetch parameter creator
 * @export
 */
export const WizardApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Fetch wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling fetchWizardData."
        );
      }
      const localVarPath = `/wizard/{type}`.replace(
        `{${"type"}}`,
        encodeURIComponent(String(type))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch wizards to restore on startup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardsToRestoreOnStartup(options: any = {}): FetchArgs {
      const localVarPath = `/wizard/toRestore`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove target wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling removeWizardData."
        );
      }
      const localVarPath = `/wizard/{type}`.replace(
        `{${"type"}}`,
        encodeURIComponent(String(type))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save wizard data.
     * @param {WizardDataDto} [body] The wizard data to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveWizardData(body?: WizardDataDto, options: any = {}): FetchArgs {
      const localVarPath = `/wizard`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete (localVarUrlObj as any).search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"WizardDataDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WizardApi - functional programming interface
 * @export
 */
export const WizardApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Fetch wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WizardDataDto> {
      const localVarFetchArgs = WizardApiFetchParamCreator(
        configuration
      ).fetchWizardData(type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Fetch wizards to restore on startup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardsToRestoreOnStartup(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs =
        WizardApiFetchParamCreator(
          configuration
        ).fetchWizardsToRestoreOnStartup(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove target wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = WizardApiFetchParamCreator(
        configuration
      ).removeWizardData(type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save wizard data.
     * @param {WizardDataDto} [body] The wizard data to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveWizardData(
      body?: WizardDataDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = WizardApiFetchParamCreator(
        configuration
      ).saveWizardData(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * WizardApi - factory interface
 * @export
 */
export const WizardApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Fetch wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options?: any
    ) {
      return WizardApiFp(configuration).fetchWizardData(type, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Fetch wizards to restore on startup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchWizardsToRestoreOnStartup(options?: any) {
      return WizardApiFp(configuration).fetchWizardsToRestoreOnStartup(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Remove target wizard data.
     * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeWizardData(
      type:
        | "CAT_ONE_CLEANING"
        | "CAT_ONE_OPTICS_CALIBRATION"
        | "CAT_ONE_OFFSETS"
        | "CAT_ONE_QC_VETTROL"
        | "CAT_ONE_QC_PHBR"
        | "CAT_ONE_QC_UPRO"
        | "CAT_ONE_QC_ADV"
        | "PREPARE_VETTROL"
        | "ACADIA_REPLACE_SHEATH"
        | "ACADIA_REPLACE_FILTER"
        | "ACADIA_REPLACE_REAGENT"
        | "ACADIA_REPLACE_QC"
        | "URISED_FULL_DOOR_CLEANING"
        | "URISED_HALF_DOOR_CLEANING"
        | "URISED_INITIALIZE"
        | "PDX_SHUTDOWN_FOR_SHIPPING"
        | "VETTEST_RUN_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
        | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
      options?: any
    ) {
      return WizardApiFp(configuration).removeWizardData(type, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Save wizard data.
     * @param {WizardDataDto} [body] The wizard data to be saved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveWizardData(body?: WizardDataDto, options?: any) {
      return WizardApiFp(configuration).saveWizardData(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * WizardApi - object-oriented interface
 * @export
 * @class WizardApi
 * @extends {BaseAPI}
 */
export class WizardApi extends BaseAPI {
  /**
   *
   * @summary Fetch wizard data.
   * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WizardApi
   */
  public fetchWizardData(
    type:
      | "CAT_ONE_CLEANING"
      | "CAT_ONE_OPTICS_CALIBRATION"
      | "CAT_ONE_OFFSETS"
      | "CAT_ONE_QC_VETTROL"
      | "CAT_ONE_QC_PHBR"
      | "CAT_ONE_QC_UPRO"
      | "CAT_ONE_QC_ADV"
      | "PREPARE_VETTROL"
      | "ACADIA_REPLACE_SHEATH"
      | "ACADIA_REPLACE_FILTER"
      | "ACADIA_REPLACE_REAGENT"
      | "ACADIA_REPLACE_QC"
      | "URISED_FULL_DOOR_CLEANING"
      | "URISED_HALF_DOOR_CLEANING"
      | "URISED_INITIALIZE"
      | "PDX_SHUTDOWN_FOR_SHIPPING"
      | "VETTEST_RUN_INSTRUCTIONS"
      | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
      | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
    options?: any
  ) {
    return WizardApiFp(this.configuration).fetchWizardData(type, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Fetch wizards to restore on startup.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WizardApi
   */
  public fetchWizardsToRestoreOnStartup(options?: any) {
    return WizardApiFp(this.configuration).fetchWizardsToRestoreOnStartup(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove target wizard data.
   * @param {"CAT_ONE_CLEANING" | "CAT_ONE_OPTICS_CALIBRATION" | "CAT_ONE_OFFSETS" | "CAT_ONE_QC_VETTROL" | "CAT_ONE_QC_PHBR" | "CAT_ONE_QC_UPRO" | "CAT_ONE_QC_ADV" | "PREPARE_VETTROL" | "ACADIA_REPLACE_SHEATH" | "ACADIA_REPLACE_FILTER" | "ACADIA_REPLACE_REAGENT" | "ACADIA_REPLACE_QC" | "URISED_FULL_DOOR_CLEANING" | "URISED_HALF_DOOR_CLEANING" | "URISED_INITIALIZE" | "PDX_SHUTDOWN_FOR_SHIPPING" | "VETTEST_RUN_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS" | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER"} type The target wizard type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WizardApi
   */
  public removeWizardData(
    type:
      | "CAT_ONE_CLEANING"
      | "CAT_ONE_OPTICS_CALIBRATION"
      | "CAT_ONE_OFFSETS"
      | "CAT_ONE_QC_VETTROL"
      | "CAT_ONE_QC_PHBR"
      | "CAT_ONE_QC_UPRO"
      | "CAT_ONE_QC_ADV"
      | "PREPARE_VETTROL"
      | "ACADIA_REPLACE_SHEATH"
      | "ACADIA_REPLACE_FILTER"
      | "ACADIA_REPLACE_REAGENT"
      | "ACADIA_REPLACE_QC"
      | "URISED_FULL_DOOR_CLEANING"
      | "URISED_HALF_DOOR_CLEANING"
      | "URISED_INITIALIZE"
      | "PDX_SHUTDOWN_FOR_SHIPPING"
      | "VETTEST_RUN_INSTRUCTIONS"
      | "LASERCYTE_REPLACE_FILTER_INSTRUCTIONS"
      | "LASERCYTE_REPLACE_FILTER_FIND_MY_FILTER",
    options?: any
  ) {
    return WizardApiFp(this.configuration).removeWizardData(type, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Save wizard data.
   * @param {WizardDataDto} [body] The wizard data to be saved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WizardApi
   */
  public saveWizardData(body?: WizardDataDto, options?: any) {
    return WizardApiFp(this.configuration).saveWizardData(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
