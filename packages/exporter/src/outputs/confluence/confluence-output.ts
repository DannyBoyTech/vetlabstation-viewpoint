import type { OutputWriter } from "../outputs";
import type {
  ConfluenceAttachment,
  ConfluencePage,
} from "./confluence-api-types";
import { ConfluenceClient, ConfluenceClientOptions } from "./confluence-client";
import { LOGGER } from "../../logger";
import fs from "fs";
import crypto from "node:crypto";
import path from "path";

export interface ConfluenceOutputOptions {
  clientOptions: ConfluenceClientOptions;
  defaultSpaceKey?: string;
}

export class ConfluenceOutput implements OutputWriter {
  private readonly options: ConfluenceOutputOptions;
  private readonly client: ConfluenceClient;
  private pageId?: string;
  private attachments?: ConfluenceAttachment[];

  constructor(opts: ConfluenceOutputOptions) {
    this.options = opts;
    this.client = new ConfluenceClient(opts.clientOptions);
  }

  async createTableCellElement(
    content: string,
    opts?: { cellId?: string }
  ): Promise<string> {
    return `<td id="${opts?.cellId}">${content}</td>`;
  }

  async createTableRowElement(
    opts?: { rowId?: string | undefined } | undefined
  ): Promise<string> {
    return `<tr id="${opts?.rowId}"></tr>`;
  }

  async createTableElement(
    title: string,
    columnHeaders: string[],
    opts?: { bodyId?: string | undefined }
  ): Promise<string> {
    return `
          <div style="margin-top: 20px;">
            <h2>${title}</h2>
            <table>
              <tbody id="${opts?.bodyId}">
                <tr>
                  ${columnHeaders
                    .map((header) => `<th>${header}</th>`)
                    .join("")}
                </tr>
              </tbody>
            </table>
          </div>
        `;
  }

  async setTargetPage(
    parentPageTitle: string | undefined,
    pageTitle: string
  ): Promise<unknown> {
    let page: ConfluencePage | undefined = undefined;
    const searchResults = await this.client.searchForPage(
      pageTitle,
      this.options.defaultSpaceKey
    );
    if (
      searchResults == null ||
      searchResults.size === 0 ||
      searchResults.size > 1
    ) {
      // Create a new page
      page = await this.createPage(parentPageTitle, pageTitle, "");
    } else {
      page = await this.client.findUniquePage(pageTitle);
    }
    // Locate the page
    LOGGER.info(`Setting target page to '${pageTitle}' with ID '${page.id}`);
    this.pageId = page.id;

    // Populate list of attachments
    this.attachments = await this.getAllAttachments();
    return this.pageId;
  }

  async createTableOfContentsElement(buildUrl?: string): Promise<string> {
    return `
      <p>
        ${
          buildUrl == null
            ? ""
            : `<p style="margin: 12px 0;">Generated by build: <a href="${buildUrl}">${buildUrl}</a></p>`
        }
        <ac:structured-macro ac:name="toc">
          <ac:parameter ac:name="style">square</ac:parameter>
          <ac:parameter ac:name="type">list</ac:parameter>
        </ac:structured-macro>
      </p>
    `;
  }

  async createImageElement(
    localImagePath: string,
    fileName: string,
    type: string = "image/png"
  ): Promise<string> {
    // Images must be attached to the page before they can be used in Confluence content,
    // so verify that a page has been initialized for this client
    this.assertPageId(this.pageId);
    if (this.attachments == null) {
      this.attachments = await this.getAllAttachments();
    }
    const uniqueFileName = getUniqueImageFilename(
      fileName,
      fs.readFileSync(localImagePath)
    );
    // Is there an existing attachment with the same hash?
    const existingAttachment = this.attachments?.find(
      (attachment) => attachment.title === uniqueFileName
    );

    if (existingAttachment == null) {
      await this.client.createAttachment(
        this.pageId,
        localImagePath,
        uniqueFileName,
        type
      );
    } else {
      LOGGER.verbose(
        `Attachment for ${uniqueFileName} already exists, skipping upload`
      );
    }

    // Are there any old attachments for this image?
    const oldAttachments = this.attachments?.filter(
      (attachment) =>
        attachment.title !== uniqueFileName &&
        attachment.title.toLowerCase().includes(fileName)
    );
    for (const oldAttachment of oldAttachments) {
      try {
        await this.client.deleteAttachment(oldAttachment.id);
      } catch (err) {
        LOGGER.error(`Error deleting attachment ${oldAttachment.id}`, err);
      }
    }

    // Create the confluence-specific image/attachment elements
    return `
        <ac:image ac:width="500px">
          <ri:attachment ri:filename="${uniqueFileName}" />
        </ac:image>
    `;
  }

  async createPage(
    parentPageTitle: string | undefined,
    newPageTitle: string,
    pageContent: string
  ) {
    const parentPage =
      parentPageTitle == null
        ? undefined
        : await this.client.findUniquePage(
            parentPageTitle,
            this.options.defaultSpaceKey
          );
    LOGGER.info(
      `Creating new page ${newPageTitle}${
        parentPage == null
          ? "under root"
          : `under parent page '${parentPage.title}'`
      }`
    );
    if (parentPage?.space == null && this.options.defaultSpaceKey == null) {
      throw new Error(
        "No default space key provided, and parent space is not available. If you are trying to create a root page, you must provide a default space key."
      );
    }
    return this.client.createPage({
      title: newPageTitle,
      type: "page",
      space:
        parentPage?.space ??
        (await this.client.fetchSpace(this.options.defaultSpaceKey!)),
      ancestors: parentPage == null ? undefined : [parentPage],
      body: {
        storage: {
          representation: "storage",
          value: pageContent,
        },
      },
    });
  }

  async updatePage(pageTitle: string, newTitle: string, newContent: string) {
    LOGGER.info(
      `Updating page content for '${pageTitle}' with new title '${newTitle}'`
    );
    const page = await this.client.findUniquePage(pageTitle);
    return this.client.updatePage(page.id, {
      ...page,
      title: newTitle,
      version: {
        ...page.version,
        number: page.version.number + 1,
        minorEdit: true,
      },
      body: {
        storage: {
          representation: "storage",
          value: newContent,
        },
      },
    });
  }

  async getAllAttachments() {
    this.assertPageId(this.pageId);
    LOGGER.debug("Fetching attachments for current page");
    const results: ConfluenceAttachment[] = [];
    let response = await this.client.getAttachments(this.pageId);
    results.push(...response.results);

    while (response._links.next != null) {
      const params = new URL(
        path.join(this.client.options.targetHost, response._links.next)
      ).searchParams;
      response = await this.client.getAttachments(
        this.pageId,
        parseInt(params.get("start")!),
        parseInt(params.get("limit")!)
      );
      results.push(...response.results);
    }

    return results;
  }

  async deleteAllAttachments() {
    this.assertPageId(this.pageId);
    LOGGER.info(`Deleting all attachments for current page '${this.pageId}'`);
    if (this.attachments == null) {
      this.attachments = await this.getAllAttachments();
    }
    for (const attachment of this.attachments) {
      try {
        await this.client.deleteAttachment(attachment.id);
      } catch (err) {
        LOGGER.error(`Error deleting attachment ${attachment.id}`, err);
      }
    }
  }

  private assertPageId(pageId: string | undefined): asserts pageId is string {
    if (pageId == null) {
      throw new Error(
        "Page ID has not been established -- must start by updating or creating a new page, or calling 'setTargetPage'"
      );
    }
  }
}

// Append hash of the image so that we can easily tell if the content of the
// image has changed before we delete/re-upload the attachment
function getUniqueImageFilename(fileName: string, imageBuffer: Buffer) {
  const sha = crypto.createHash("sha1").update(imageBuffer).digest("hex");
  const ext = path.extname(fileName);
  const base = path.basename(fileName, ext);
  return `${base}-${sha}${ext}`;
}
