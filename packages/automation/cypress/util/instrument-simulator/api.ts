/* eslint-disable @typescript-eslint/no-namespace */

// tslint:disable
/**
 * IRIS API Specification
 * This document is the API specification for the IDEXX Real-time Instrument Simulator.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "url";
import { Configuration } from "./configuration";

const BASE_PATH = "http://127.0.0.1:50045/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

let _fetcher: FetchAPI | undefined;
const portableFetch: FetchAPI = (_url, _init) => {
  if (!_fetcher) {
    throw new Error("IRIS API Services must be initialized");
  }
  return _fetcher(_url, _init);
};

export const initializeApiServices = (fetcher: FetchAPI) => {
  console.log("Initializing IRIS API services");
  _fetcher = fetcher;
};

export type IrisInstruments =
  | "Catalyst Dx"
  | "Catalyst One"
  | "ProCyte Dx"
  | "SediVue Dx"
  | "SnapPro"
  | "SnapShot Dx"
  | "Acadia Dx"
  | "UriSys Dx"
  | "Theia"
  | "Tensei";

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AcadiaDxPropertiesDto
 */
export interface AcadiaDxPropertiesDto {
  /**
   *
   * @type {boolean}
   * @memberof AcadiaDxPropertiesDto
   */
  ignoreMaintenanceRequests?: boolean;
}

/**
 *
 * @export
 * @interface AcadiaDxUpgradeDto
 */
export interface AcadiaDxUpgradeDto {
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeDto
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeDto
   */
  notificationType: string;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeDto
   */
  version?: string;
  /**
   *
   * @type {number}
   * @memberof AcadiaDxUpgradeDto
   */
  waitTimeMs?: number;
  /**
   *
   * @type {boolean}
   * @memberof AcadiaDxUpgradeDto
   */
  includeLetter?: boolean;
  /**
   *
   * @type {any}
   * @memberof AcadiaDxUpgradeDto
   */
  upgradeLetterFile?: any;
}

/**
 *
 * @export
 * @interface AcadiaDxUpgradeInputDto
 */
export interface AcadiaDxUpgradeInputDto {
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeInputDto
   */
  status: AcadiaDxUpgradeInputDto.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeInputDto
   */
  notificationType: AcadiaDxUpgradeInputDto.NotificationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeInputDto
   */
  version: string;
  /**
   *
   * @type {number}
   * @memberof AcadiaDxUpgradeInputDto
   */
  waitTimeMs?: number;
  /**
   *
   * @type {boolean}
   * @memberof AcadiaDxUpgradeInputDto
   */
  includeLetter?: boolean;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeInputDto
   */
  upgradeLetterFile?: string;
  /**
   *
   * @type {string}
   * @memberof AcadiaDxUpgradeInputDto
   */
  signatureFile?: string;
}

/**
 * @export
 * @namespace AcadiaDxUpgradeInputDto
 */
export namespace AcadiaDxUpgradeInputDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Success = <any>"Success",
    Failed = <any>"Failed",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum NotificationTypeEnum {
    Notify = <any>"Notify",
    Silent = <any>"Silent",
  }
}

/**
 *
 * @export
 * @interface CatOneUpgradeDto
 */
export interface CatOneUpgradeDto {
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeDto
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeDto
   */
  notificationType: string;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeDto
   */
  version?: string;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeDto
   */
  curvesVersion?: string;
}

/**
 *
 * @export
 * @interface CatOneUpgradeInputDto
 */
export interface CatOneUpgradeInputDto {
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeInputDto
   */
  status: CatOneUpgradeInputDto.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeInputDto
   */
  notificationType: CatOneUpgradeInputDto.NotificationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeInputDto
   */
  version: string;
  /**
   *
   * @type {string}
   * @memberof CatOneUpgradeInputDto
   */
  curvesVersion?: string;
}

/**
 * @export
 * @namespace CatOneUpgradeInputDto
 */
export namespace CatOneUpgradeInputDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Success = <any>"Success",
    Failed = <any>"Failed",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum NotificationTypeEnum {
    Notify = <any>"Notify",
    Silent = <any>"Silent",
  }
}

/**
 *
 * @export
 * @interface FluidPackStatusDto
 */
export interface FluidPackStatusDto {
  /**
   *
   * @type {number}
   * @memberof FluidPackStatusDto
   */
  percentRemaining?: number;
  /**
   *
   * @type {number}
   * @memberof FluidPackStatusDto
   */
  runsRemaining?: number;
  /**
   *
   * @type {number}
   * @memberof FluidPackStatusDto
   */
  daysRemaining?: number;
}

/**
 *
 * @export
 * @interface FtpCredentialsDto
 */
export interface FtpCredentialsDto {
  /**
   *
   * @type {string}
   * @memberof FtpCredentialsDto
   */
  login: string;
  /**
   *
   * @type {string}
   * @memberof FtpCredentialsDto
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof FtpCredentialsDto
   */
  relativePath: string;
}

/**
 *
 * @export
 * @interface InstrumentInputDto
 */
export interface InstrumentInputDto {
  /**
   *
   * @type {string}
   * @memberof InstrumentInputDto
   */
  instrumentSerialNumber?: string;
  /**
   *
   * @type {string}
   * @memberof InstrumentInputDto
   */
  instrumentSoftwareVersion?: string;
  /**
   *
   * @type {string}
   * @memberof InstrumentInputDto
   */
  mainUnitSerialNumber?: string;
}

/**
 *
 * @export
 * @interface InstrumentMaintenanceResultDto
 */
export interface InstrumentMaintenanceResultDto {
  /**
   *
   * @type {string}
   * @memberof InstrumentMaintenanceResultDto
   */
  procedure?: string;
  /**
   *
   * @type {string}
   * @memberof InstrumentMaintenanceResultDto
   */
  result?: InstrumentMaintenanceResultDto.ResultEnum;
}

/**
 * @export
 * @namespace InstrumentMaintenanceResultDto
 */
export namespace InstrumentMaintenanceResultDto {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Success = <any>"Success",
    Failed = <any>"Failed",
  }
}

/**
 *
 * @export
 * @interface IrisAlertDto
 */
export interface IrisAlertDto {
  /**
   *
   * @type {string}
   * @memberof IrisAlertDto
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof IrisAlertDto
   */
  priority?: number;
  /**
   *
   * @type {string}
   * @memberof IrisAlertDto
   */
  actionMessage: string;
  /**
   *
   * @type {string}
   * @memberof IrisAlertDto
   */
  recoveryCommand?: string;
}

/**
 *
 * @export
 * @interface IrisFaultDto
 */
export interface IrisFaultDto {
  /**
   *
   * @type {string}
   * @memberof IrisFaultDto
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IrisFaultDto
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof IrisFaultDto
   */
  text?: string;
}

/**
 *
 * @export
 * @interface IrisInstrumentDto
 */
export interface IrisInstrumentDto {
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentDto
   */
  instrumentName: string;
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentDto
   */
  instrumentSerialNumber: string;
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentDto
   */
  instrumentSoftwareVersion: string;
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentDto
   */
  instrumentStatus: "Busy" | "Offline" | "Ready" | "Standby";
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentDto
   */
  mainUnitSerialNumber?: string;
  /**
   *
   * @type {number}
   * @memberof IrisInstrumentDto
   */
  id: number;
}

/**
 *
 * @export
 * @interface IrisInstrumentStatusDto
 */
export interface IrisInstrumentStatusDto {
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentStatusDto
   */
  instrumentStatus: IrisInstrumentStatusDto.InstrumentStatusEnum;
  /**
   *
   * @type {string}
   * @memberof IrisInstrumentStatusDto
   */
  instrumentStatusDetail?: IrisInstrumentStatusDto.InstrumentStatusDetailEnum;
}

/**
 * @export
 * @namespace IrisInstrumentStatusDto
 */
export namespace IrisInstrumentStatusDto {
  /**
   * @export
   * @enum {string}
   */
  export enum InstrumentStatusEnum {
    Busy = <any>"Busy",
    Offline = <any>"Offline",
    Ready = <any>"Ready",
    Standby = <any>"Standby",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum InstrumentStatusDetailEnum {
    ENTERINGSTANDBY = <any>"ENTERING_STANDBY",
    EXITINGSTANDBY = <any>"EXITING_STANDBY",
    IDLE = <any>"IDLE",
    INITIALIZING = <any>"INITIALIZING",
    LOADINGCUVETTE = <any>"LOADING_CUVETTE",
    LULLABY = <any>"LULLABY",
    MAINTENANCE = <any>"MAINTENANCE",
    MAINTENANCEACCESSOPEN = <any>"MAINTENANCE_ACCESS_OPEN",
    MAINTENANCEREQUIRED = <any>"MAINTENANCE_REQUIRED",
    QUALITYCONTROL = <any>"QUALITY_CONTROL",
    RESTARTING = <any>"RESTARTING",
    RUNNINGSAMPLE = <any>"RUNNING_SAMPLE",
    SHUTTINGDOWN = <any>"SHUTTING_DOWN",
    UPGRADE = <any>"UPGRADE",
    WAITINGFORCUVETTE = <any>"WAITING_FOR_CUVETTE",
    WAITINGFORSAMPLE = <any>"WAITING_FOR_SAMPLE",
    WAKINGUP = <any>"WAKING_UP",
    WAITINGMONTHLYRINSE = <any>"WAITING_MONTHLY_RINSE",
    WAITINGFLOWCELLRINSE = <any>"WAITING_FLOW_CELL_RINSE",
    WAITINGWASTECHAMBERRINSE = <any>"WAITING_WASTE_CHAMBER_RINSE",
  }
}

/**
 *
 * @export
 * @interface NextAcadiaDxMaintenanceResultDto
 */
export interface NextAcadiaDxMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  fault?: NextAcadiaDxMaintenanceResultDto.FaultEnum;
  /**
   *
   * @type {boolean}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  waitForStartButtonPress?: boolean;
  /**
   *
   * @type {number}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  startDelayInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextAcadiaDxMaintenanceResultDto
   */
  maintenanceTubeError?: boolean;
}

/**
 * @export
 * @namespace NextAcadiaDxMaintenanceResultDto
 */
export namespace NextAcadiaDxMaintenanceResultDto {
  export enum MaintenanceProcedure {
    BleachClean = "BleachClean",
    DrainMixChambers = "DrainMixChambers",
    FlowCellSoak = "FlowCellSoak",
    FullSystemPrime = "FullSystemPrime",
    PrimeReagent = "PrimeReagent",
    PrimeSheath = "PrimeSheath",
    ReplaceOBC = "ReplaceOBC",
    ReplaceReagent = "ReplaceReagent",
    ReplaceSheath = "ReplaceSheath",
    SystemFlush = "SystemFlush",
    Shutdown = "Shutdown",
  }

  /**
   * @export
   * @enum {string}
   */
  export enum FaultEnum {
    FILTERREPLACE = <any>"FILTER_REPLACE",
    FILTERLEAK = <any>"FILTER_LEAK",
    SAMPLEDRAWEROPENRUN = <any>"SAMPLE_DRAWER_OPEN_RUN",
    MISSINGSAMPLE = <any>"MISSING_SAMPLE",
    SHEATHEMPTY = <any>"SHEATH_EMPTY",
    UNSPECIFIEDALERTSYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    REAGENTEMPTY = <any>"REAGENT_EMPTY",
    BARCODEREADFAILUREREAGENT = <any>"BARCODE_READ_FAILURE_REAGENT",
    USEDREAGENT = <any>"USED_REAGENT",
    UNSTABLEREAGENT = <any>"UNSTABLE_REAGENT",
    EXPIREDREAGENT = <any>"EXPIRED_REAGENT",
    EXPIREDSHEATH = <any>"EXPIRED_SHEATH",
    UNSTABLESHEATH = <any>"UNSTABLE_SHEATH",
    MAINTENANCETUBEERROR = <any>"MAINTENANCE_TUBE_ERROR",
    MISSINGREAGENT = <any>"MISSING_REAGENT",
    MISSINGSHEATH = <any>"MISSING_SHEATH",
    STOPPERPRESENT = <any>"STOPPER_PRESENT",
    UNKNOWNTUBE = <any>"UNKNOWN_TUBE",
    OVERTEMP = <any>"OVER_TEMP",
    CAMERAINITIALIZATIONFAILURE = <any>"CAMERA_INITIALIZATION_FAILURE",
    OVERPRESSUREUNRECOVERABLE = <any>"OVER_PRESSURE_UNRECOVERABLE",
    UPDATEPENDING = <any>"UPDATE_PENDING",
    UNRECOVERABLEERROR = <any>"UNRECOVERABLE_ERROR",
    BLEACHCLEANREQUIRED = <any>"BLEACH_CLEAN_REQUIRED",
    SAMPLEDRAWEROPENQC = <any>"SAMPLE_DRAWER_OPEN_QC",
    MISSINGCONTROL = <any>"MISSING_CONTROL",
    BARCODEREADFAILUREQC = <any>"BARCODE_READ_FAILURE_QC",
    OBCLOW = <any>"OBC_LOW",
    OBCEMPTY = <any>"OBC_EMPTY",
    UNSUPPORTEDQCLOT = <any>"UNSUPPORTED_QC_LOT",
    REAGENTLOW = <any>"REAGENT_LOW",
    REAGENTPACKLEAKRUN = <any>"REAGENT_PACK_LEAK_RUN",
    REAGENTPACKLEAK = <any>"REAGENT_PACK_LEAK",
    BARCODEREADFAILURESHEATH = <any>"BARCODE_READ_FAILURE_SHEATH",
    SHEATHLOW = <any>"SHEATH_LOW",
    UNEXPECTEDERROR = <any>"UNEXPECTED_ERROR",
    UNSPECIFIEDALERTACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
    UNEXPECTEDERRORMAINTENANCE = <any>"UNEXPECTED_ERROR_MAINTENANCE",
    SAMPLETUBERUNEND = <any>"SAMPLE_TUBE_RUN_END",
    DATAPROCESSINGERROR = <any>"DATA_PROCESSING_ERROR",
    INSUFFICIENTEVENTS = <any>"INSUFFICIENT_EVENTS",
    XAXISMOTIONERROR = <any>"XAXIS_MOTION_ERROR",
    SYRWBCHOMEERROR = <any>"SYR_WBC_HOME_ERROR",
    SYRRBCHOMEERROR = <any>"SYR_RBC_HOME_ERROR",
    ZAXISMOTIONERROR = <any>"ZAXIS_MOTION_ERROR",
    SYRSAMPLEHOMEERROR = <any>"SYR_SAMPLE_HOME_ERROR",
    SYRSHEATHHOMEERROR = <any>"SYR_SHEATH_HOME_ERROR",
    SYRWBCMOTIONERROR = <any>"SYR_WBC_MOTION_ERROR",
    SYRRBCMOTIONERROR = <any>"SYR_RBC_MOTION_ERROR",
    SYRSAMPLEMOTIONERROR = <any>"SYR_SAMPLE_MOTION_ERROR",
    SYRSHEATHMOTIONERROR = <any>"SYR_SHEATH_MOTION_ERROR",
    SYRWBCPRESSUREERROR = <any>"SYR_WBC_PRESSURE_ERROR",
    SYRRBCPRESSUREERROR = <any>"SYR_RBC_PRESSURE_ERROR",
    SYRSAMPLEPRESSUREERROR = <any>"SYR_SAMPLE_PRESSURE_ERROR",
    SYRSHEATHPRESSUREERROR = <any>"SYR_SHEATH_PRESSURE_ERROR",
    ASPERROR = <any>"ASP_ERROR",
    TUBEEMPTY = <any>"TUBE_EMPTY",
    ASPCLOT = <any>"ASP_CLOT",
    ASPSTARTINAIR = <any>"ASP_START_IN_AIR",
    ASPPARTIAL = <any>"ASP_PARTIAL",
    ASPNOFLUID = <any>"ASP_NO_FLUID",
    MICROCODEWATCHDOG = <any>"MICROCODE_WATCHDOG",
    OVERPRESSURE = <any>"OVER_PRESSURE",
    PACKACCESSOPEN = <any>"PACK_ACCESS_OPEN",
    PACKACCESSOPENRUN = <any>"PACK_ACCESS_OPEN_RUN",
    SHUTDOWNSHIPPINGCLEANUP = <any>"SHUTDOWN_SHIPPING_CLEANUP",
    ALGRUNFLAGFAULT = <any>"ALG_RUN_FLAG_FAULT",
    JUNKOVERLOAD = <any>"JUNK_OVERLOAD",
    QCREMINDER = <any>"QC_REMINDER",
    BLEACHCLEANRECOMMENDED = <any>"BLEACH_CLEAN_RECOMMENDED",
  }
}

/**
 *
 * @export
 * @interface NextBarcodeValidationResultDto
 */
export interface NextBarcodeValidationResultDto {
  /**
   *
   * @type {boolean}
   * @memberof NextBarcodeValidationResultDto
   */
  valid?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof NextBarcodeValidationResultDto
   */
  ignore?: boolean;
}

/**
 *
 * @export
 * @interface NextCatOneMaintenanceResultDto
 */
export interface NextCatOneMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextCatOneMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextCatOneMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextCatOneMaintenanceResultDto
   */
  fault?: NextCatOneMaintenanceResultDto.FaultEnum;
}

/**
 * @export
 * @namespace NextCatOneMaintenanceResultDto
 */
export namespace NextCatOneMaintenanceResultDto {
  export enum MaintenanceProcedure {
    GeneralClean = "GeneralClean",
    Offsets = "Offsets",
    OpticsCalibration = "OpticsCalibration",
    Shutdown = "Shutdown",
    Optimize = "Optimize",
  }

  /**
   * @export
   * @enum {string}
   */
  export enum FaultEnum {
    UPDATEAVAILABLE = <any>"UPDATE_AVAILABLE",
    UPDATEFAILEDCATASTROPHIC = <any>"UPDATE_FAILED_CATASTROPHIC",
    UPDATEFAILED = <any>"UPDATE_FAILED",
    ADDPIPETTETIPS = <any>"ADD_PIPETTE_TIPS",
    AIRDETECTEDINSAMPLE = <any>"AIR_DETECTED_IN_SAMPLE",
    AIRDETECTEDINSAMPLEWARNING = <any>"AIR_DETECTED_IN_SAMPLE_WARNING",
    ASPIRATIONFAILURE = <any>"ASPIRATION_FAILURE",
    BADORMISSINGCALCURVEDATA = <any>"BAD_OR_MISSING_CALCURVE_DATA",
    CALIBRATIONSOFTWAREERROR = <any>"CALIBRATION_SOFTWARE_ERROR",
    CAMERAINITIALIZATIONFAILURE = <any>"CAMERA_INITIALIZATION_FAILURE",
    CANNOTLOCKSAMPLEDRAWER = <any>"CANNOT_LOCK_SAMPLE_DRAWER",
    CANNOTUNLOCKSAMPLEDRAWER = <any>"CANNOT_UNLOCK_SAMPLE_DRAWER",
    CAPDETECTED = <any>"CAP_DETECTED",
    CAROUSELALIGNMENTFAILED = <any>"CAROUSEL_ALIGNMENT_FAILED",
    CAROUSELCOVEROPEN = <any>"CAROUSEL_COVER_OPEN",
    CENTRIFUGEERROR = <any>"CENTRIFUGE_ERROR",
    CLEANINGREQUIRED = <any>"CLEANING_REQUIRED",
    DILUTIONSLIDECOUNTEXCEEDED = <any>"DILUTION_SLIDE_COUNT_EXCEEDED",
    DUPLICATEREAGENTTYPEDETECTED = <any>"DUPLICATE_REAGENT_TYPE_DETECTED",
    FLUIDFINDFAILUREDILCUP = <any>"FLUID_FIND_FAILURE_DIL_CUP",
    FLUIDFINDFAILUREMIXCUP = <any>"FLUID_FIND_FAILURE_MIX_CUP",
    HEIGHTCORRECTIONSURFACEFINDFAILURE = <any>(
      "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
    ),
    INCORRECTSLIDEORREAGENT = <any>"INCORRECT_SLIDE_OR_REAGENT",
    INCORRECTSLIDEORREAGENTIGNORABLE = <any>(
      "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
    ),
    INCORRECTLYSEATEDCAROUSEL = <any>"INCORRECTLY_SEATED_CAROUSEL",
    INSUFFICIENTDILUENTVOLUMEWARNING = <any>(
      "INSUFFICIENT_DILUENT_VOLUME_WARNING"
    ),
    INSUFFICIENTDILUENTVOLUME = <any>"INSUFFICIENT_DILUENT_VOLUME",
    INSUFFICIENTPIPETTETIPS = <any>"INSUFFICIENT_PIPETTE_TIPS",
    INSUFFICIENTSAMPLEFORDILUTIONWARNING = <any>(
      "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
    ),
    INSUFFICIENTSAMPLEFORDILUTION = <any>"INSUFFICIENT_SAMPLE_FOR_DILUTION",
    INTERNALTIMINGERROR = <any>"INTERNAL_TIMING_ERROR",
    MATERIALSINCOMPATIBLE = <any>"MATERIALS_INCOMPATIBLE",
    MISSINGDILUTIONMATERIALS = <any>"MISSING_DILUTION_MATERIALS",
    MISSINGEMPTYCUP = <any>"MISSING_EMPTY_CUP",
    MISSINGREAGENT = <any>"MISSING_REAGENT",
    MISSINGREAGENTIGNORABLE = <any>"MISSING_REAGENT_IGNORABLE",
    MISSINGUPCMATERIALS = <any>"MISSING_UPC_MATERIALS",
    MULTIPLESAMPLESDETECTED = <any>"MULTIPLE_SAMPLES_DETECTED",
    NOIDENTIFIABLESLIDESFOUND = <any>"NO_IDENTIFIABLE_SLIDES_FOUND",
    NOSAMPLEDETECTED = <any>"NO_SAMPLE_DETECTED",
    OPTICSINITIALIZATIONFAILURE = <any>"OPTICS_INITIALIZATION_FAILURE",
    OPTICSMODULECONFIGURATIONERROR = <any>"OPTICS_MODULE_CONFIGURATION_ERROR",
    PHBRLOADERROR = <any>"PHBR_LOAD_ERROR",
    PHBRLOADERRORIGNORABLE = <any>"PHBR_LOAD_ERROR_IGNORABLE",
    PIPETTETIPSLOW = <any>"PIPETTE_TIPS_LOW",
    REAGENTIDENTIFICATIONERROR = <any>"REAGENT_IDENTIFICATION_ERROR",
    RECOVERABLETIMEOUT = <any>"RECOVERABLE_TIMEOUT",
    RECOVERYFAILURE = <any>"RECOVERY_FAILURE",
    ROBOTHOMINGFAILURE = <any>"ROBOT_HOMING_FAILURE",
    ROBOTMOTIONERROR = <any>"ROBOT_MOTION_ERROR",
    RUNCOMPLETIONERROR = <any>"RUN_COMPLETION_ERROR",
    SAMPLEDRAWERLOCKERROR = <any>"SAMPLE_DRAWER_LOCK_ERROR",
    SAMPLEDRAWEROPEN = <any>"SAMPLE_DRAWER_OPEN",
    SAMPLEDRAWEROPENRUN = <any>"SAMPLE_DRAWER_OPEN_RUN",
    SHIPPINGCLIPSDETECTED = <any>"SHIPPING_CLIPS_DETECTED",
    SLIDEDATESOFTWAREVERSIONMISMATCH = <any>(
      "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
    ),
    SLIDEDETECTIONERROR = <any>"SLIDE_DETECTION_ERROR",
    SLIDEEJECTERROR = <any>"SLIDE_EJECT_ERROR",
    SLIDELOADINGERROR = <any>"SLIDE_LOADING_ERROR",
    SLIDETIMEOUTERROR = <any>"SLIDE_TIMEOUT_ERROR",
    SPURIOUSDEVICEEVENT = <any>"SPURIOUS_DEVICE_EVENT",
    THERMALCONTROLERROR = <any>"THERMAL_CONTROL_ERROR",
    THERMALERROR = <any>"THERMAL_ERROR",
    UNSPECIFIEDERROR = <any>"UNSPECIFIED_ERROR",
    UNSUPPORTEDWHITEREFSLIDELOT = <any>"UNSUPPORTED_WHITE_REF_SLIDE_LOT",
    USERCALIBRATIONUNSUCCESSFUL = <any>"USER_CALIBRATION_UNSUCCESSFUL",
    WARMUPTHERMALERROR = <any>"WARMUP_THERMAL_ERROR",
    WASTEDRAWERFULL = <any>"WASTE_DRAWER_FULL",
    WASTEDRAWEROPEN = <any>"WASTE_DRAWER_OPEN",
    WASTEDRAWEROPENRUN = <any>"WASTE_DRAWER_OPEN_RUN",
    UPGRADEFAILEDPREPARATION = <any>"UPGRADE_FAILED_PREPARATION",
    UPGRADEFAILEDDOWNLOAD = <any>"UPGRADE_FAILED_DOWNLOAD",
    WBSSAMPLEVOLUMEHIGH = <any>"WBS_SAMPLE_VOLUME_HIGH",
    CAMERACOMERROR = <any>"CAMERA_COM_ERROR",
    CAMERACONNECTIONERROR = <any>"CAMERA_CONNECTION_ERROR",
    CAROUSELROTATIONERROR = <any>"CAROUSEL_ROTATION_ERROR",
    OPTICSCALIBRATIONREQUIRED = <any>"OPTICS_CALIBRATION_REQUIRED",
    SLIDEREAGENTMISMATCH = <any>"SLIDE_REAGENT_MISMATCH",
    SLIDEREAGENTMISMATCHIGNORABLE = <any>"SLIDE_REAGENT_MISMATCH_IGNORABLE",
    PRESSURESENSORERROR = <any>"PRESSURE_SENSOR_ERROR",
    FLUIDFINDFAILURE = <any>"FLUID_FIND_FAILURE",
    UNSPECIFIEDALERTSYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    ALGANOMINITSLOPEVSSUBREAD = <any>"ALG_ANOM_INIT_SLOPE_VS_SUB_READ",
    ALGANOMPROGCURVEDEVELOPMENT = <any>"ALG_ANOM_PROG_CURVE_DEVELOPMENT",
    ALGBADSUBMINUSWASHDIFF = <any>"ALG_BAD_SUB_MINUS_WASH_DIFF",
    ALGELLIPSEINTERSECTIONFAIL = <any>"ALG_ELLIPSE_INTERSECTION_FAIL",
    ALGINTERFERINGSUBSTANCE = <any>"ALG_INTERFERING_SUBSTANCE",
    ALGIONCALIBRATIONDRIFT = <any>"ALG_ION_CALIBRATION_DRIFT",
    ALGIONIMPULSEDETECTED = <any>"ALG_ION_IMPULSE_DETECTED",
    ALGIONSAMPLEDRIFT = <any>"ALG_ION_SAMPLE_DRIFT",
    ALGIONSAMPLEERROR = <any>"ALG_ION_SAMPLE_ERROR",
    ALGIONSAMPLENOTDETECTED = <any>"ALG_ION_SAMPLE_NOT_DETECTED",
    ALGIONSHIFTDETECTED = <any>"ALG_ION_SHIFT_DETECTED",
    ALGNOSAMPLEDISPENSE = <any>"ALG_NO_SAMPLE_DISPENSE",
    ALGNOWASH1DISPENSE = <any>"ALG_NO_WASH_1_DISPENSE",
    ALGNOWASH2DISPENSE = <any>"ALG_NO_WASH_2_DISPENSE",
    ALGPHBRBIASEDRESULT = <any>"ALG_PHBR_BIASED_RESULT",
    ALGSLIDENOTSPOTTED = <any>"ALG_SLIDE_NOT_SPOTTED",
    ALGSUBSTRATEDEPLETION = <any>"ALG_SUBSTRATE_DEPLETION",
    ASPIRATIONSTARTINAIR = <any>"ASPIRATION_START_IN_AIR",
    ASPIRATIONSTARTINAIRWARNING = <any>"ASPIRATION_START_IN_AIR_WARNING",
    BARCODEREADFAILURE = <any>"BARCODE_READ_FAILURE",
    CLOTDETECTEDINSAMPLE = <any>"CLOT_DETECTED_IN_SAMPLE",
    CLOTDETECTEDINSAMPLEWARNING = <any>"CLOT_DETECTED_IN_SAMPLE_WARNING",
    FOAMDETECTEDINSAMPLE = <any>"FOAM_DETECTED_IN_SAMPLE",
    FOAMDETECTEDINSAMPLEWARNING = <any>"FOAM_DETECTED_IN_SAMPLE_WARNING",
    INSUFFICIENTSAMPLEVOLUME = <any>"INSUFFICIENT_SAMPLE_VOLUME",
    INSUFFICIENTSAMPLEVOLUMEWARNING = <any>"INSUFFICIENT_SAMPLE_VOLUME_WARNING",
    INSUFFICIENTSAMPLEVOLUMEIGNORABLE = <any>(
      "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
    ),
    INSUFFICIENTSAMPLEVOLUMEIGNORABLEWARNING = <any>(
      "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
    ),
    LVLASPBUBBLE = <any>"LVLASP_BUBBLE",
    LVLASPCLOT = <any>"LVLASP_CLOT",
    LVLASPINSUFFICIENTSAMPLE = <any>"LVLASP_INSUFFICIENT_SAMPLE",
    LVLASPSTARTINAIR = <any>"LVLASP_START_IN_AIR",
    SAMPLETOOLOW = <any>"SAMPLE_TOO_LOW",
    SLIDECONTAMINATED = <any>"SLIDE_CONTAMINATED",
    UNSUPPORTEDQCRANGE = <any>"UNSUPPORTED_QC_RANGE",
    UNSUPPORTEDSLIDELOT = <any>"UNSUPPORTED_SLIDE_LOT",
    USEDREAGENTDETECTEDIGNORABLEWARNING = <any>(
      "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
    ),
    OFFSETSINSUFFICIENTSLIDESERROR = <any>"OFFSETS_INSUFFICIENT_SLIDES_ERROR",
    OFFSETSOUTOFRANGEERROR = <any>"OFFSETS_OUT_OF_RANGE_ERROR",
    OFFSETSCVTOOHIGHERROR = <any>"OFFSETS_CV_TOO_HIGH_ERROR",
    ALGBADDRYREAD = <any>"ALG_BAD_DRY_READ",
    ALGBADSCMINUSDRYDIFF = <any>"ALG_BAD_SC_MINUS_DRY_DIFF",
    ALGBADWASHMINUSSCDIFF = <any>"ALG_BAD_WASH_MINUS_SC_DIFF",
    ALGBADLATESLOPE = <any>"ALG_BAD_LATE_SLOPE",
    ALGGREATERTHANEXTREMEHIGHCONCLIMIT = <any>(
      "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
    ),
    ALGGREATERTHANEXTREMELOWCONCLIMIT = <any>(
      "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
    ),
    ASSAYNORMALIZATIONMISSING = <any>"ASSAY_NORMALIZATION_MISSING",
    ALGSLOPENOTCORRECTABLE = <any>"ALG_SLOPE_NOT_CORRECTABLE",
    USEDREAGENTDETECTEDWARNING = <any>"USED_REAGENT_DETECTED_WARNING",
    MATERIALSINCOMPATIBLEFRIENDS = <any>"MATERIALS_INCOMPATIBLE_FRIENDS",
    SUSPECTRESULTCOMPARISON = <any>"SUSPECT_RESULT_COMPARISON",
    LYTEPROCESSINGERROR = <any>"LYTE_PROCESSING_ERROR",
    ALGBADRESPONSERANGE = <any>"ALG_BAD_RESPONSE_RANGE",
    OPTICSLEDFAILURE = <any>"OPTICS_LED_FAILURE",
    OPTICSSENSORFAILURE = <any>"OPTICS_SENSOR_FAILURE",
    ALGSLOPENOTCORRECTABLEGEN = <any>"ALG_SLOPE_NOT_CORRECTABLE_GEN",
    MISSINGIAFORREAGENT = <any>"MISSING_IA_FOR_REAGENT",
    MISSINGREAGENTFORIA = <any>"MISSING_REAGENT_FOR_IA",
    OFFSETSCALIBRATIONERROR = <any>"OFFSETS_CALIBRATION_ERROR",
    BARCODEREADERROR = <any>"BARCODE_READ_ERROR",
    MISSINGEMPTYDILUTIONCUP = <any>"MISSING_EMPTY_DILUTION_CUP",
    PHBRORIENTERRORIGNORABLE = <any>"PHBR_ORIENT_ERROR_IGNORABLE",
    PHBRORIENTERROR = <any>"PHBR_ORIENT_ERROR",
    SLIDEREAGENTLOTMISMATCHIGNORABLE = <any>(
      "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
    ),
    SLIDEREAGENTLOTMISMATCH = <any>"SLIDE_REAGENT_LOT_MISMATCH",
    USEDREAGENTDETECTED = <any>"USED_REAGENT_DETECTED",
    USEDREAGENTDETECTEDIGNORABLE = <any>"USED_REAGENT_DETECTED_IGNORABLE",
    ALGTT4ANOMINITSLOPEVSSUBREAD = <any>"ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ",
    ALGTT4ANOMPROGCURVEDEVELOPMENT = <any>"ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT",
    ALGTT4BADSUBMINUSWASHDIFF = <any>"ALG_TT4_BAD_SUB_MINUS_WASH_DIFF",
    ALGTT4ELLIPSEINTERSECTIONFAIL = <any>"ALG_TT4_ELLIPSE_INTERSECTION_FAIL",
    ERRALGALGORITHMINTERFERINGSUBSTANCE = <any>(
      "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
    ),
    UNSPECIFIEDALERTACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
    OPTIMIZATIONAVAILABLE = <any>"OPTIMIZATION_AVAILABLE",
    OPTIMIZATIONAVAILABLEALIGNMENT = <any>"OPTIMIZATION_AVAILABLE_ALIGNMENT",
    CHECKEVAPCAP = <any>"CHECK_EVAP_CAP",
    ALGDRYREADVARIANCE = <any>"ALG_DRY_READ_VARIANCE",
    RUNCONSUMABLEIDSTART = <any>"RUN_CONSUMABLE_ID_START",
    PLANFAILTIPSEXHAUSTED = <any>"PLAN_FAIL_TIPS_EXHAUSTED",
    PLANFAILREPLANATTEMPTSEXCEEDED = <any>"PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED",
    UPGRADEFAILEDVERIFICATION = <any>"UPGRADE_FAILED_VERIFICATION",
    UPGRADEFAILEDINSTALLATION = <any>"UPGRADE_FAILED_INSTALLATION",
    SLIDETYPESINCOMPATIBLE = <any>"SLIDE_TYPES_INCOMPATIBLE",
    DUPLICATESLIDEDETECTED = <any>"DUPLICATE_SLIDE_DETECTED",
  }
}

/**
 *
 * @export
 * @interface NextFcsFilesDto
 */
export interface NextFcsFilesDto {
  /**
   *
   * @type {number}
   * @memberof NextFcsFilesDto
   */
  crimsonInstrumentId: number;
  /**
   *
   * @type {string}
   * @memberof NextFcsFilesDto
   */
  encodedReticFile: string;
  /**
   *
   * @type {string}
   * @memberof NextFcsFilesDto
   */
  encodedDiffFile: string;
}

/**
 *
 * @export
 * @interface NextFluidPackStatusDto
 */
export interface NextFluidPackStatusDto {
  /**
   *
   * @type {number}
   * @memberof NextFluidPackStatusDto
   */
  percentLeft?: number;
  /**
   *
   * @type {number}
   * @memberof NextFluidPackStatusDto
   */
  runsLeft?: number;
}

/**
 *
 * @export
 * @interface NextResultDto
 */
export interface NextResultDto {
  /**
   *
   * @type {number}
   * @memberof NextResultDto
   */
  irisInstrumentId: number;
  /**
   *
   * @type {string}
   * @memberof NextResultDto
   */
  body?: string;
}

/**
 *
 * @export
 * @interface NextSediVueDxMaintenanceResultDto
 */
export interface NextSediVueDxMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextSediVueDxMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextSediVueDxMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextSediVueDxMaintenanceResultDto
   */
  fault?: NextSediVueDxMaintenanceResultDto.FaultEnum;
}

/**
 * @export
 * @namespace NextSediVueDxMaintenanceResultDto
 */
export namespace NextSediVueDxMaintenanceResultDto {
  /**
   * @export
   * @enum {string}
   */
  export enum MaintenanceProcedure {
    DropCuvette = "DropCuvette",
    GeneralClean = "GeneralClean",
    Initialize = "Initialize",
    Restart = "Restart",
    Shutdown = "Shutdown",
  }

  export enum FaultEnum {
    CLEANINGRECOMMENDED = <any>"CLEANING_RECOMMENDED",
    CUVETTECOUNTLOW = <any>"CUVETTE_COUNT_LOW",
    QUALITYCONTROLRECOMMENDED = <any>"QUALITY_CONTROL_RECOMMENDED",
    SYSTEMREBOOTRECOMMENDED = <any>"SYSTEM_REBOOT_RECOMMENDED",
    UPDATEAVAILABLE = <any>"UPDATE_AVAILABLE",
    UPDATEFAILED = <any>"UPDATE_FAILED",
    ARMMOVEMENT = <any>"ARM_MOVEMENT",
    CAMERAERROR = <any>"CAMERA_ERROR",
    CENTRIFUGEROTATIONERROR = <any>"CENTRIFUGE_ROTATION_ERROR",
    CUVETTECOUNTZERO = <any>"CUVETTE_COUNT_ZERO",
    CUVETTESENSOREMPTY = <any>"CUVETTE_SENSOR_EMPTY",
    DOOROPEN = <any>"DOOR_OPEN",
    FEEDERMOVEMENT = <any>"FEEDER_MOVEMENT",
    FOCUSDLLNOTFOUND = <any>"FOCUS_DLL_NOT_FOUND",
    FOCUSFUNCTIONMISSING = <any>"FOCUS_FUNCTION_MISSING",
    FOCUSHOMEPOSITIONERROR = <any>"FOCUS_HOME_POSITION_ERROR",
    GENERALCOMMUNICATIONERROR = <any>"GENERAL_COMMUNICATION_ERROR",
    HOUSEOPEN = <any>"HOUSE_OPEN",
    INSTRUMENTPORTOPENERROR = <any>"INSTRUMENT_PORT_OPEN_ERROR",
    MEMORYALLOCATIONERROR = <any>"MEMORY_ALLOCATION_ERROR",
    MICROSCOPECTSTIMEOUT = <any>"MICROSCOPE_CTS_TIMEOUT",
    MICROSCOPETHREADCREATIONERROR = <any>"MICROSCOPE_THREAD_CREATION_ERROR",
    PLATEMISSING = <any>"PLATE_MISSING",
    PORTTHREADNOTSTARTED = <any>"PORT_THREAD_NOT_STARTED",
    PROTOCOLCLASSCREATIONERROR = <any>"PROTOCOL_CLASS_CREATION_ERROR",
    PROTOCOLUSAGEUNDEFINED = <any>"PROTOCOL_USAGE_UNDEFINED",
    SERIALPORTNOTFOUND = <any>"SERIAL_PORT_NOT_FOUND",
    SERIALPORTUNAVAILABLE = <any>"SERIAL_PORT_UNAVAILABLE",
    TOOMANYSERIALPORTSDEFINED = <any>"TOO_MANY_SERIAL_PORTS_DEFINED",
    UNSPECIFIEDALERTSYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    MOTYMOVEMENT = <any>"MOTY_MOVEMENT",
    CENTRIFUGEARMMISSING = <any>"CENTRIFUGE_ARM_MISSING",
    UNSPECIFIEDALERTACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
  }
}

/**
 *
 * @export
 * @interface NextTenseiMaintenanceResultDto
 */
export interface NextTenseiMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextTenseiMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextTenseiMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextTenseiMaintenanceResultDto
   */
  fault?: NextTenseiMaintenanceResultDto.FaultEnum;
  /**
   *
   * @type {boolean}
   * @memberof NextTenseiMaintenanceResultDto
   */
  waitForStartButtonPress?: boolean;
  /**
   * The delay (in milliseconds) between the instrument accepting the maintenance request and the instrument starting the requested maintenance procedure.  Defaults to 500ms.
   * @type {number}
   * @memberof NextTenseiMaintenanceResultDto
   */
  startDelayInMillis?: number;
  /**
   * The delay (in milliseconds) between the instrument starting the requested maintenance procedure and the instrument reporting progress against it.  Defaults to 500ms.
   * @type {number}
   * @memberof NextTenseiMaintenanceResultDto
   */
  progressDelayInMillis?: number;
  /**
   *
   * @type {string}
   * @memberof NextTenseiMaintenanceResultDto
   */
  lastProgressValue?: string;
  /**
   *
   * @type {boolean}
   * @memberof NextTenseiMaintenanceResultDto
   */
  sendProgress?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof NextTenseiMaintenanceResultDto
   */
  sendMaintenanceResult?: boolean;
}

/**
 * @export
 * @namespace NextTenseiMaintenanceResultDto
 */
export namespace NextTenseiMaintenanceResultDto {
  /**
   * @export
   * @enum {string}
   */
  export enum MaintenanceProcedure {
    AutoRinse = "AutoRinse",
    ClearPinchValve = "ClearPinchValve",
    DrainReactionChamber = "DrainReactionChamber",
    DrainWasteChamber = "DrainWasteChamber",
    RemoveClog = "RemoveClog",
    ResetAirPump = "ResetAirPump",
    ResetAspirationMotor = "ResetAspirationMotor",
    ResetSheathMotor = "ResetSheathMotor",
    ResetTubeMotor = "ResetTubeMotor",
    ReplenishReagent = "ReplenishReagent",
    ReplenishStain = "ReplenishStain",
    FlowCellRinse = "FlowCellRinse",
    MonthlyRinse = "MonthlyRinse",
    WasteChamberRinse = "WasteChamberRinse",
  }
  export enum FaultEnum {
    SYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    ACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
  }
}

/**
 *
 * @export
 * @interface NextTheiaMaintenanceResultDto
 */
export interface NextTheiaMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextTheiaMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextTheiaMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextTheiaMaintenanceResultDto
   */
  fault?: NextTheiaMaintenanceResultDto.FaultEnum;
  /**
   *
   * @type {boolean}
   * @memberof NextTheiaMaintenanceResultDto
   */
  waitForStartButtonPress?: boolean;
  /**
   *
   * @type {number}
   * @memberof NextTheiaMaintenanceResultDto
   */
  startDelayInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextTheiaMaintenanceResultDto
   */
  maintenanceTubeError?: boolean;
}

/**
 * @export
 * @namespace NextTheiaMaintenanceResultDto
 */
export namespace NextTheiaMaintenanceResultDto {
  /**
   * @export
   * @enum {string}
   */
  export enum FaultEnum {
    INSTTEMPLOW = <any>"INST_TEMP_LOW",
    INSTTEMPHIGH = <any>"INST_TEMP_HIGH",
    BARCODEREADFAILURE = <any>"BARCODE_READ_FAILURE",
    UNSPECIFIEDALERTSYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    INVALIDCONSUMABLES = <any>"INVALID_CONSUMABLES",
    EXPIREDCONSUMABLES = <any>"EXPIRED_CONSUMABLES",
    INCORRECTTESTTYPE = <any>"INCORRECT_TEST_TYPE",
    SAMPLEOVERTEMP = <any>"SAMPLE_OVER_TEMP",
    SAMPLEUNDERTEMP = <any>"SAMPLE_UNDER_TEMP",
    IMPROPERSAMPLEPREPARATION = <any>"IMPROPER_SAMPLE_PREPARATION",
    SAMPLECELLULARITYHIGH = <any>"SAMPLE_CELLULARITY_HIGH",
    MOTIONERRORCARTRIDGE = <any>"MOTION_ERROR_CARTRIDGE",
    MOTIONERRORMICROSCOPE = <any>"MOTION_ERROR_MICROSCOPE",
    UNKNOWNERROR = <any>"UNKNOWN_ERROR",
    UNSPECIFIEDALERTACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
  }
}

/**
 *
 * @export
 * @interface NextUriSysDxMaintenanceResultDto
 */
export interface NextUriSysDxMaintenanceResultDto {
  /**
   *
   * @type {number}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  durationInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  reject?: boolean;
  /**
   *
   * @type {string}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  fault?: NextUriSysDxMaintenanceResultDto.FaultEnum;
  /**
   *
   * @type {boolean}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  waitForStartButtonPress?: boolean;
  /**
   *
   * @type {number}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  startDelayInMillis?: number;
  /**
   *
   * @type {boolean}
   * @memberof NextUriSysDxMaintenanceResultDto
   */
  maintenanceTubeError?: boolean;
}

/**
 * @export
 * @namespace NextUriSysDxMaintenanceResultDto
 */
export namespace NextUriSysDxMaintenanceResultDto {
  /**
   * @export
   * @enum {string}
   */
  export enum FaultEnum {
    UPDATEAVAILABLE = <any>"UPDATE_AVAILABLE",
    UPDATEFAILED = <any>"UPDATE_FAILED",
    UPDATEFAILEDCATASTROPHIC = <any>"UPDATE_FAILED_CATASTROPHIC",
    UNSPECIFIEDALERTSYSTEM = <any>"UNSPECIFIED_ALERT_SYSTEM",
    UNSPECIFIEDALERTACKNOWLEDGE = <any>"UNSPECIFIED_ALERT_ACKNOWLEDGE",
    E7MISSINGTRAYERROR = <any>"E7_MISSING_TRAY_ERROR",
    E8TRAYPOSITIONERROR = <any>"E8_TRAY_POSITION_ERROR",
    E9WRONGTRAYERROR = <any>"E9_WRONG_TRAY_ERROR",
    E10LIGHTBARRIERERROR = <any>"E10_LIGHT_BARRIER_ERROR",
    E11MOTORSTEPERROR = <any>"E11_MOTOR_STEP_ERROR",
    E12OPTICSERROR = <any>"E12_OPTICS_ERROR",
    E25SYSTEMEPROMERROR = <any>"E25_SYSTEM_EPROM_ERROR",
    E29DATABASEERROR = <any>"E29_DATABASE_ERROR",
    E30SYSTEMINITIALIZATIONERROR = <any>"E30_SYSTEM_INITIALIZATION_ERROR",
    E33SYSTEMERROR = <any>"E33_SYSTEM_ERROR",
    E100POWERSUPPLYERROR = <any>"E100_POWERSUPPLY_ERROR",
    E1REFERENCEPADERRORMIDDLEERROR = <any>"E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR",
    E2WRONGSTRIPERROR = <any>"E2_WRONG_STRIP_ERROR",
    E3STRIPMEASUREMENTERROR = <any>"E3_STRIP_MEASUREMENT_ERROR",
    E4CALIBRATIONERROR = <any>"E4_CALIBRATION_ERROR",
    E5CALIBRATIONINVALIDERROR = <any>"E5_CALIBRATION_INVALID_ERROR",
    E15REFERENCEPADBOTTOMERROR = <any>"E15_REFERENCE_PAD_BOTTOM_ERROR",
    E16REFERENCEPADTOPERROR = <any>"E16_REFERENCE_PAD_TOP_ERROR",
    E24COMPPADREMISSIONSOUTOFRANGEERROR = <any>(
      "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
    ),
    E27USERCALIBRATIONISREQUIREDERROR = <any>(
      "E27_USER_CALIBRATION_IS_REQUIRED_ERROR"
    ),
  }
}

/**
 *
 * @export
 * @interface SediVueDxUpgradeDto
 */
export interface SediVueDxUpgradeDto {
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeDto
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeDto
   */
  notificationType: string;
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeDto
   */
  version: string;
  /**
   *
   * @type {boolean}
   * @memberof SediVueDxUpgradeDto
   */
  saveForLater?: boolean;
}

/**
 *
 * @export
 * @interface SediVueDxUpgradeInputDto
 */
export interface SediVueDxUpgradeInputDto {
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeInputDto
   */
  status: SediVueDxUpgradeInputDto.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeInputDto
   */
  notificationType: SediVueDxUpgradeInputDto.NotificationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof SediVueDxUpgradeInputDto
   */
  version: string;
  /**
   *
   * @type {boolean}
   * @memberof SediVueDxUpgradeInputDto
   */
  saveForLater?: boolean;
}

/**
 * @export
 * @namespace SediVueDxUpgradeInputDto
 */
export namespace SediVueDxUpgradeInputDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Success = <any>"Success",
    Failed = <any>"Failed",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum NotificationTypeEnum {
    Notify = <any>"Notify",
    Silent = <any>"Silent",
  }
}

/**
 *
 * @export
 * @interface TenseiPropertiesDto
 */
export interface TenseiPropertiesDto {
  /**
   *
   * @type {boolean}
   * @memberof TenseiPropertiesDto
   */
  ignoreMaintenanceRequests?: boolean;
}

/**
 *
 * @export
 * @interface UriSysDxUpgradeInputDto
 */
export interface UriSysDxUpgradeInputDto {
  /**
   *
   * @type {string}
   * @memberof UriSysDxUpgradeInputDto
   */
  status: UriSysDxUpgradeInputDto.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof UriSysDxUpgradeInputDto
   */
  notificationType: UriSysDxUpgradeInputDto.NotificationTypeEnum;
  /**
   *
   * @type {string}
   * @memberof UriSysDxUpgradeInputDto
   */
  version: string;
}

/**
 * @export
 * @namespace UriSysDxUpgradeInputDto
 */
export namespace UriSysDxUpgradeInputDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Success = <any>"Success",
    Failed = <any>"Failed",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum NotificationTypeEnum {
    Notify = <any>"Notify",
    Silent = <any>"Silent",
  }
}

/**
 * AcadiaDxApi - fetch parameter creator
 * @export
 */
export const AcadiaDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling abortUpgrade."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/upgrade/abort`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade(
      instrumentId: number,
      upgradeDetails?: AcadiaDxUpgradeInputDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addUpgrade."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/upgrade`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AcadiaDxUpgradeInputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(upgradeDetails || {})
        : upgradeDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentStatus."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchProperties."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/properties`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchUpgrade."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/upgrade`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling getFluidPackStatus."
        );
      }
      // verify required parameter 'fluidPackType' is not null or undefined
      if (fluidPackType === null || fluidPackType === undefined) {
        throw new RequiredError(
          "fluidPackType",
          "Required parameter fluidPackType was null or undefined when calling getFluidPackStatus."
        );
      }
      const localVarPath =
        `/acadiaDx/{instrumentId}/fluidPack/status/{fluidPackType}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"fluidPackType"}}`,
            encodeURIComponent(String(fluidPackType))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling pressStartButton."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/startButton`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Replace a fluid pack.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceFluidPack(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling replaceFluidPack."
        );
      }
      // verify required parameter 'fluidPackType' is not null or undefined
      if (fluidPackType === null || fluidPackType === undefined) {
        throw new RequiredError(
          "fluidPackType",
          "Required parameter fluidPackType was null or undefined when calling replaceFluidPack."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/fluidPack/{fluidPackType}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(
          `{${"fluidPackType"}}`,
          encodeURIComponent(String(fluidPackType))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(
      instrumentId: number,
      body?: AcadiaDxPropertiesDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling saveProperties."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/properties`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AcadiaDxPropertiesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling sendMaintenanceResult."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/maintenance`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send Smart QC Result.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmartQCResult(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling sendSmartQCResult."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/smartqc`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setBarcodeValidation."
        );
      }
      // verify required parameter 'barcodeType' is not null or undefined
      if (barcodeType === null || barcodeType === undefined) {
        throw new RequiredError(
          "barcodeType",
          "Required parameter barcodeType was null or undefined when calling setBarcodeValidation."
        );
      }
      const localVarPath = `/acadiaDx/{instrumentId}/barcode/{barcodeType}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"barcodeType"}}`, encodeURIComponent(String(barcodeType)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextBarcodeValidationResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {FluidPackStatusDto} [body] The fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: FluidPackStatusDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setFluidPackStatus."
        );
      }
      // verify required parameter 'fluidPackType' is not null or undefined
      if (fluidPackType === null || fluidPackType === undefined) {
        throw new RequiredError(
          "fluidPackType",
          "Required parameter fluidPackType was null or undefined when calling setFluidPackStatus."
        );
      }
      const localVarPath =
        `/acadiaDx/{instrumentId}/fluidPack/status/{fluidPackType}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"fluidPackType"}}`,
            encodeURIComponent(String(fluidPackType))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"FluidPackStatusDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the next fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {NextFluidPackStatusDto} [body] The next fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: NextFluidPackStatusDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextFluidPackStatus."
        );
      }
      // verify required parameter 'fluidPackType' is not null or undefined
      if (fluidPackType === null || fluidPackType === undefined) {
        throw new RequiredError(
          "fluidPackType",
          "Required parameter fluidPackType was null or undefined when calling setNextFluidPackStatus."
        );
      }
      const localVarPath =
        `/acadiaDx/{instrumentId}/fluidPack/status/next/{fluidPackType}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"fluidPackType"}}`,
            encodeURIComponent(String(fluidPackType))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextFluidPackStatusDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'BleachClean' | 'DrainMixChambers' | 'FlowCellSoak' | 'FullSystemPrime' | 'PrimeReagent' | 'PrimeSheath' | 'ReplaceOBC' | 'ReplaceReagent' | 'ReplaceSheath' | 'SystemFlush' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextAcadiaDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult(
      instrumentId: number,
      maintenanceProcedure:
        | "BleachClean"
        | "DrainMixChambers"
        | "FlowCellSoak"
        | "FullSystemPrime"
        | "PrimeReagent"
        | "PrimeSheath"
        | "ReplaceOBC"
        | "ReplaceReagent"
        | "ReplaceSheath"
        | "SystemFlush"
        | "Shutdown",
      body?: NextAcadiaDxMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult."
        );
      }
      const localVarPath =
        `/acadiaDx/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextAcadiaDxMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AcadiaDxApi - functional programming interface
 * @export
 */
export const AcadiaDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).abortUpgrade(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).addFault(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade(
      instrumentId: number,
      upgradeDetails?: AcadiaDxUpgradeInputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).addUpgrade(instrumentId, upgradeDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).fetchFaults(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<IrisInstrumentStatusDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).fetchInstrumentStatus(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AcadiaDxPropertiesDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).fetchProperties(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AcadiaDxUpgradeDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).fetchUpgrade(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FluidPackStatusDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).getFluidPackStatus(instrumentId, fluidPackType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).pressStartButton(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).removeFault(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Replace a fluid pack.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceFluidPack(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).replaceFluidPack(instrumentId, fluidPackType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(
      instrumentId: number,
      body?: AcadiaDxPropertiesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).saveProperties(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).sendMaintenanceResult(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Send Smart QC Result.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmartQCResult(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).sendSmartQCResult(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).setBarcodeValidation(instrumentId, barcodeType, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {FluidPackStatusDto} [body] The fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: FluidPackStatusDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).setFluidPackStatus(instrumentId, fluidPackType, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Set the next fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {NextFluidPackStatusDto} [body] The next fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: NextFluidPackStatusDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).setNextFluidPackStatus(instrumentId, fluidPackType, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'BleachClean' | 'DrainMixChambers' | 'FlowCellSoak' | 'FullSystemPrime' | 'PrimeReagent' | 'PrimeSheath' | 'ReplaceOBC' | 'ReplaceReagent' | 'ReplaceSheath' | 'SystemFlush' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextAcadiaDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult(
      instrumentId: number,
      maintenanceProcedure:
        | "BleachClean"
        | "DrainMixChambers"
        | "FlowCellSoak"
        | "FullSystemPrime"
        | "PrimeReagent"
        | "PrimeSheath"
        | "ReplaceOBC"
        | "ReplaceReagent"
        | "ReplaceSheath"
        | "SystemFlush"
        | "Shutdown",
      body?: NextAcadiaDxMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AcadiaDxApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AcadiaDxApi - factory interface
 * @export
 */
export const AcadiaDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).abortUpgrade(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).addFault(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade(
      instrumentId: number,
      upgradeDetails?: AcadiaDxUpgradeInputDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).addUpgrade(
        instrumentId,
        upgradeDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).fetchFaults(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).fetchInstrumentStatus(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).fetchProperties(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).fetchUpgrade(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).getFluidPackStatus(
        instrumentId,
        fluidPackType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).pressStartButton(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault(
      instrumentId: number,
      faultEnum:
        | "FILTER_REPLACE"
        | "FILTER_LEAK"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "MISSING_SAMPLE"
        | "SHEATH_EMPTY"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "REAGENT_EMPTY"
        | "BARCODE_READ_FAILURE_REAGENT"
        | "USED_REAGENT"
        | "UNSTABLE_REAGENT"
        | "EXPIRED_REAGENT"
        | "EXPIRED_SHEATH"
        | "UNSTABLE_SHEATH"
        | "MAINTENANCE_TUBE_ERROR"
        | "MISSING_REAGENT"
        | "MISSING_SHEATH"
        | "STOPPER_PRESENT"
        | "UNKNOWN_TUBE"
        | "OVER_TEMP"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "OVER_PRESSURE_UNRECOVERABLE"
        | "UPDATE_PENDING"
        | "UNRECOVERABLE_ERROR"
        | "BLEACH_CLEAN_REQUIRED"
        | "SAMPLE_DRAWER_OPEN_QC"
        | "MISSING_CONTROL"
        | "BARCODE_READ_FAILURE_QC"
        | "OBC_LOW"
        | "OBC_EMPTY"
        | "UNSUPPORTED_QC_LOT"
        | "REAGENT_LOW"
        | "REAGENT_PACK_LEAK_RUN"
        | "REAGENT_PACK_LEAK"
        | "BARCODE_READ_FAILURE_SHEATH"
        | "SHEATH_LOW"
        | "UNEXPECTED_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "UNEXPECTED_ERROR_MAINTENANCE"
        | "SAMPLE_TUBE_RUN_END"
        | "DATA_PROCESSING_ERROR"
        | "INSUFFICIENT_EVENTS"
        | "XAXIS_MOTION_ERROR"
        | "SYR_WBC_HOME_ERROR"
        | "SYR_RBC_HOME_ERROR"
        | "ZAXIS_MOTION_ERROR"
        | "SYR_SAMPLE_HOME_ERROR"
        | "SYR_SHEATH_HOME_ERROR"
        | "SYR_WBC_MOTION_ERROR"
        | "SYR_RBC_MOTION_ERROR"
        | "SYR_SAMPLE_MOTION_ERROR"
        | "SYR_SHEATH_MOTION_ERROR"
        | "SYR_WBC_PRESSURE_ERROR"
        | "SYR_RBC_PRESSURE_ERROR"
        | "SYR_SAMPLE_PRESSURE_ERROR"
        | "SYR_SHEATH_PRESSURE_ERROR"
        | "ASP_ERROR"
        | "TUBE_EMPTY"
        | "ASP_CLOT"
        | "ASP_START_IN_AIR"
        | "ASP_PARTIAL"
        | "ASP_NO_FLUID"
        | "MICROCODE_WATCHDOG"
        | "OVER_PRESSURE"
        | "PACK_ACCESS_OPEN"
        | "PACK_ACCESS_OPEN_RUN"
        | "SHUTDOWN_SHIPPING_CLEANUP"
        | "ALG_RUN_FLAG_FAULT"
        | "JUNK_OVERLOAD"
        | "QC_REMINDER"
        | "BLEACH_CLEAN_RECOMMENDED",
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).removeFault(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Replace a fluid pack.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceFluidPack(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).replaceFluidPack(
        instrumentId,
        fluidPackType,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {AcadiaDxPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties(
      instrumentId: number,
      body?: AcadiaDxPropertiesDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).saveProperties(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).sendMaintenanceResult(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Send Smart QC Result.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSmartQCResult(instrumentId: number, options?: any) {
      return AcadiaDxApiFp(configuration).sendSmartQCResult(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).setBarcodeValidation(
        instrumentId,
        barcodeType,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Set the fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {FluidPackStatusDto} [body] The fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: FluidPackStatusDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).setFluidPackStatus(
        instrumentId,
        fluidPackType,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Set the next fluid pack status.
     * @param {number} instrumentId The instrument id.
     * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
     * @param {NextFluidPackStatusDto} [body] The next fluid pack status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFluidPackStatus(
      instrumentId: number,
      fluidPackType: "Reagent" | "Sheath",
      body?: NextFluidPackStatusDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).setNextFluidPackStatus(
        instrumentId,
        fluidPackType,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'BleachClean' | 'DrainMixChambers' | 'FlowCellSoak' | 'FullSystemPrime' | 'PrimeReagent' | 'PrimeSheath' | 'ReplaceOBC' | 'ReplaceReagent' | 'ReplaceSheath' | 'SystemFlush' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextAcadiaDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult(
      instrumentId: number,
      maintenanceProcedure:
        | "BleachClean"
        | "DrainMixChambers"
        | "FlowCellSoak"
        | "FullSystemPrime"
        | "PrimeReagent"
        | "PrimeSheath"
        | "ReplaceOBC"
        | "ReplaceReagent"
        | "ReplaceSheath"
        | "SystemFlush"
        | "Shutdown",
      body?: NextAcadiaDxMaintenanceResultDto,
      options?: any
    ) {
      return AcadiaDxApiFp(configuration).setNextMaintenanceResult(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * AcadiaDxApi - object-oriented interface
 * @export
 * @class AcadiaDxApi
 * @extends {BaseAPI}
 */
export class AcadiaDxApi extends BaseAPI {
  /**
   *
   * @summary Abort a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public abortUpgrade(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).abortUpgrade(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public addFault(
    instrumentId: number,
    faultEnum:
      | "FILTER_REPLACE"
      | "FILTER_LEAK"
      | "SAMPLE_DRAWER_OPEN_RUN"
      | "MISSING_SAMPLE"
      | "SHEATH_EMPTY"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "REAGENT_EMPTY"
      | "BARCODE_READ_FAILURE_REAGENT"
      | "USED_REAGENT"
      | "UNSTABLE_REAGENT"
      | "EXPIRED_REAGENT"
      | "EXPIRED_SHEATH"
      | "UNSTABLE_SHEATH"
      | "MAINTENANCE_TUBE_ERROR"
      | "MISSING_REAGENT"
      | "MISSING_SHEATH"
      | "STOPPER_PRESENT"
      | "UNKNOWN_TUBE"
      | "OVER_TEMP"
      | "CAMERA_INITIALIZATION_FAILURE"
      | "OVER_PRESSURE_UNRECOVERABLE"
      | "UPDATE_PENDING"
      | "UNRECOVERABLE_ERROR"
      | "BLEACH_CLEAN_REQUIRED"
      | "SAMPLE_DRAWER_OPEN_QC"
      | "MISSING_CONTROL"
      | "BARCODE_READ_FAILURE_QC"
      | "OBC_LOW"
      | "OBC_EMPTY"
      | "UNSUPPORTED_QC_LOT"
      | "REAGENT_LOW"
      | "REAGENT_PACK_LEAK_RUN"
      | "REAGENT_PACK_LEAK"
      | "BARCODE_READ_FAILURE_SHEATH"
      | "SHEATH_LOW"
      | "UNEXPECTED_ERROR"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "UNEXPECTED_ERROR_MAINTENANCE"
      | "SAMPLE_TUBE_RUN_END"
      | "DATA_PROCESSING_ERROR"
      | "INSUFFICIENT_EVENTS"
      | "XAXIS_MOTION_ERROR"
      | "SYR_WBC_HOME_ERROR"
      | "SYR_RBC_HOME_ERROR"
      | "ZAXIS_MOTION_ERROR"
      | "SYR_SAMPLE_HOME_ERROR"
      | "SYR_SHEATH_HOME_ERROR"
      | "SYR_WBC_MOTION_ERROR"
      | "SYR_RBC_MOTION_ERROR"
      | "SYR_SAMPLE_MOTION_ERROR"
      | "SYR_SHEATH_MOTION_ERROR"
      | "SYR_WBC_PRESSURE_ERROR"
      | "SYR_RBC_PRESSURE_ERROR"
      | "SYR_SAMPLE_PRESSURE_ERROR"
      | "SYR_SHEATH_PRESSURE_ERROR"
      | "ASP_ERROR"
      | "TUBE_EMPTY"
      | "ASP_CLOT"
      | "ASP_START_IN_AIR"
      | "ASP_PARTIAL"
      | "ASP_NO_FLUID"
      | "MICROCODE_WATCHDOG"
      | "OVER_PRESSURE"
      | "PACK_ACCESS_OPEN"
      | "PACK_ACCESS_OPEN_RUN"
      | "SHUTDOWN_SHIPPING_CLEANUP"
      | "ALG_RUN_FLAG_FAULT"
      | "JUNK_OVERLOAD"
      | "QC_REMINDER"
      | "BLEACH_CLEAN_RECOMMENDED",
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).addFault(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {AcadiaDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public addUpgrade(
    instrumentId: number,
    upgradeDetails?: AcadiaDxUpgradeInputDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).addUpgrade(
      instrumentId,
      upgradeDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public fetchFaults(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).fetchFaults(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the instrument status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public fetchInstrumentStatus(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).fetchInstrumentStatus(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the instrument properties.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public fetchProperties(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).fetchProperties(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the details of the active upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public fetchUpgrade(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).fetchUpgrade(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the fluid pack status.
   * @param {number} instrumentId The instrument id.
   * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public getFluidPackStatus(
    instrumentId: number,
    fluidPackType: "Reagent" | "Sheath",
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).getFluidPackStatus(
      instrumentId,
      fluidPackType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Presses the 'Start' button on the instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public pressStartButton(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).pressStartButton(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'FILTER_REPLACE' | 'FILTER_LEAK' | 'SAMPLE_DRAWER_OPEN_RUN' | 'MISSING_SAMPLE' | 'SHEATH_EMPTY' | 'UNSPECIFIED_ALERT_SYSTEM' | 'REAGENT_EMPTY' | 'BARCODE_READ_FAILURE_REAGENT' | 'USED_REAGENT' | 'UNSTABLE_REAGENT' | 'EXPIRED_REAGENT' | 'EXPIRED_SHEATH' | 'UNSTABLE_SHEATH' | 'MAINTENANCE_TUBE_ERROR' | 'MISSING_REAGENT' | 'MISSING_SHEATH' | 'STOPPER_PRESENT' | 'UNKNOWN_TUBE' | 'OVER_TEMP' | 'CAMERA_INITIALIZATION_FAILURE' | 'OVER_PRESSURE_UNRECOVERABLE' | 'UPDATE_PENDING' | 'UNRECOVERABLE_ERROR' | 'BLEACH_CLEAN_REQUIRED' | 'SAMPLE_DRAWER_OPEN_QC' | 'MISSING_CONTROL' | 'BARCODE_READ_FAILURE_QC' | 'OBC_LOW' | 'OBC_EMPTY' | 'UNSUPPORTED_QC_LOT' | 'REAGENT_LOW' | 'REAGENT_PACK_LEAK_RUN' | 'REAGENT_PACK_LEAK' | 'BARCODE_READ_FAILURE_SHEATH' | 'SHEATH_LOW' | 'UNEXPECTED_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'UNEXPECTED_ERROR_MAINTENANCE' | 'SAMPLE_TUBE_RUN_END' | 'DATA_PROCESSING_ERROR' | 'INSUFFICIENT_EVENTS' | 'XAXIS_MOTION_ERROR' | 'SYR_WBC_HOME_ERROR' | 'SYR_RBC_HOME_ERROR' | 'ZAXIS_MOTION_ERROR' | 'SYR_SAMPLE_HOME_ERROR' | 'SYR_SHEATH_HOME_ERROR' | 'SYR_WBC_MOTION_ERROR' | 'SYR_RBC_MOTION_ERROR' | 'SYR_SAMPLE_MOTION_ERROR' | 'SYR_SHEATH_MOTION_ERROR' | 'SYR_WBC_PRESSURE_ERROR' | 'SYR_RBC_PRESSURE_ERROR' | 'SYR_SAMPLE_PRESSURE_ERROR' | 'SYR_SHEATH_PRESSURE_ERROR' | 'ASP_ERROR' | 'TUBE_EMPTY' | 'ASP_CLOT' | 'ASP_START_IN_AIR' | 'ASP_PARTIAL' | 'ASP_NO_FLUID' | 'MICROCODE_WATCHDOG' | 'OVER_PRESSURE' | 'PACK_ACCESS_OPEN' | 'PACK_ACCESS_OPEN_RUN' | 'SHUTDOWN_SHIPPING_CLEANUP' | 'ALG_RUN_FLAG_FAULT' | 'JUNK_OVERLOAD' | 'QC_REMINDER' | 'BLEACH_CLEAN_RECOMMENDED'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public removeFault(
    instrumentId: number,
    faultEnum:
      | "FILTER_REPLACE"
      | "FILTER_LEAK"
      | "SAMPLE_DRAWER_OPEN_RUN"
      | "MISSING_SAMPLE"
      | "SHEATH_EMPTY"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "REAGENT_EMPTY"
      | "BARCODE_READ_FAILURE_REAGENT"
      | "USED_REAGENT"
      | "UNSTABLE_REAGENT"
      | "EXPIRED_REAGENT"
      | "EXPIRED_SHEATH"
      | "UNSTABLE_SHEATH"
      | "MAINTENANCE_TUBE_ERROR"
      | "MISSING_REAGENT"
      | "MISSING_SHEATH"
      | "STOPPER_PRESENT"
      | "UNKNOWN_TUBE"
      | "OVER_TEMP"
      | "CAMERA_INITIALIZATION_FAILURE"
      | "OVER_PRESSURE_UNRECOVERABLE"
      | "UPDATE_PENDING"
      | "UNRECOVERABLE_ERROR"
      | "BLEACH_CLEAN_REQUIRED"
      | "SAMPLE_DRAWER_OPEN_QC"
      | "MISSING_CONTROL"
      | "BARCODE_READ_FAILURE_QC"
      | "OBC_LOW"
      | "OBC_EMPTY"
      | "UNSUPPORTED_QC_LOT"
      | "REAGENT_LOW"
      | "REAGENT_PACK_LEAK_RUN"
      | "REAGENT_PACK_LEAK"
      | "BARCODE_READ_FAILURE_SHEATH"
      | "SHEATH_LOW"
      | "UNEXPECTED_ERROR"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "UNEXPECTED_ERROR_MAINTENANCE"
      | "SAMPLE_TUBE_RUN_END"
      | "DATA_PROCESSING_ERROR"
      | "INSUFFICIENT_EVENTS"
      | "XAXIS_MOTION_ERROR"
      | "SYR_WBC_HOME_ERROR"
      | "SYR_RBC_HOME_ERROR"
      | "ZAXIS_MOTION_ERROR"
      | "SYR_SAMPLE_HOME_ERROR"
      | "SYR_SHEATH_HOME_ERROR"
      | "SYR_WBC_MOTION_ERROR"
      | "SYR_RBC_MOTION_ERROR"
      | "SYR_SAMPLE_MOTION_ERROR"
      | "SYR_SHEATH_MOTION_ERROR"
      | "SYR_WBC_PRESSURE_ERROR"
      | "SYR_RBC_PRESSURE_ERROR"
      | "SYR_SAMPLE_PRESSURE_ERROR"
      | "SYR_SHEATH_PRESSURE_ERROR"
      | "ASP_ERROR"
      | "TUBE_EMPTY"
      | "ASP_CLOT"
      | "ASP_START_IN_AIR"
      | "ASP_PARTIAL"
      | "ASP_NO_FLUID"
      | "MICROCODE_WATCHDOG"
      | "OVER_PRESSURE"
      | "PACK_ACCESS_OPEN"
      | "PACK_ACCESS_OPEN_RUN"
      | "SHUTDOWN_SHIPPING_CLEANUP"
      | "ALG_RUN_FLAG_FAULT"
      | "JUNK_OVERLOAD"
      | "QC_REMINDER"
      | "BLEACH_CLEAN_RECOMMENDED",
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).removeFault(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Replace a fluid pack.
   * @param {number} instrumentId The instrument id.
   * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public replaceFluidPack(
    instrumentId: number,
    fluidPackType: "Reagent" | "Sheath",
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).replaceFluidPack(
      instrumentId,
      fluidPackType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save the instrument properties.
   * @param {number} instrumentId The instrument id.
   * @param {AcadiaDxPropertiesDto} [body] The instrument properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public saveProperties(
    instrumentId: number,
    body?: AcadiaDxPropertiesDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).saveProperties(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Send maintenance result from instrument.
   * @param {number} instrumentId The instrument id.
   * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public sendMaintenanceResult(
    instrumentId: number,
    body?: InstrumentMaintenanceResultDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).sendMaintenanceResult(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Send Smart QC Result.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public sendSmartQCResult(instrumentId: number, options?: any) {
    return AcadiaDxApiFp(this.configuration).sendSmartQCResult(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next barcode validation result.
   * @param {number} instrumentId The instrument id.
   * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
   * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public setBarcodeValidation(
    instrumentId: number,
    barcodeType:
      | "Cuvettes"
      | "Reagent"
      | "Sheath"
      | "SmartQC"
      | "Blood"
      | "EarSwab"
      | "FNA",
    body?: NextBarcodeValidationResultDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).setBarcodeValidation(
      instrumentId,
      barcodeType,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Set the fluid pack status.
   * @param {number} instrumentId The instrument id.
   * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
   * @param {FluidPackStatusDto} [body] The fluid pack status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public setFluidPackStatus(
    instrumentId: number,
    fluidPackType: "Reagent" | "Sheath",
    body?: FluidPackStatusDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).setFluidPackStatus(
      instrumentId,
      fluidPackType,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Set the next fluid pack status.
   * @param {number} instrumentId The instrument id.
   * @param {'Reagent' | 'Sheath'} fluidPackType The fluid pack type.
   * @param {NextFluidPackStatusDto} [body] The next fluid pack status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public setNextFluidPackStatus(
    instrumentId: number,
    fluidPackType: "Reagent" | "Sheath",
    body?: NextFluidPackStatusDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).setNextFluidPackStatus(
      instrumentId,
      fluidPackType,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'BleachClean' | 'DrainMixChambers' | 'FlowCellSoak' | 'FullSystemPrime' | 'PrimeReagent' | 'PrimeSheath' | 'ReplaceOBC' | 'ReplaceReagent' | 'ReplaceSheath' | 'SystemFlush' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
   * @param {NextAcadiaDxMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AcadiaDxApi
   */
  public setNextMaintenanceResult(
    instrumentId: number,
    maintenanceProcedure:
      | "BleachClean"
      | "DrainMixChambers"
      | "FlowCellSoak"
      | "FullSystemPrime"
      | "PrimeReagent"
      | "PrimeSheath"
      | "ReplaceOBC"
      | "ReplaceReagent"
      | "ReplaceSheath"
      | "SystemFlush"
      | "Shutdown",
    body?: NextAcadiaDxMaintenanceResultDto,
    options?: any
  ) {
    return AcadiaDxApiFp(this.configuration).setNextMaintenanceResult(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * CatalystDxApi - fetch parameter creator
 * @export
 */
export const CatalystDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLegacyQcEnabled(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchLegacyQcEnabled."
        );
      }
      const localVarPath = `/catalystDx/{instrumentId}/legacyQcEnabled`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled1(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchRejectQcLotQueryEnabled1."
        );
      }
      const localVarPath =
        `/catalystDx/{instrumentId}/rejectQcLotQueryEnabled`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLegacyQcEnabled(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateLegacyQcEnabled."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateLegacyQcEnabled."
        );
      }
      const localVarPath = `/catalystDx/{instrumentId}/legacyQcEnabled/{status}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled1(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateRejectQcLotQueryEnabled1."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateRejectQcLotQueryEnabled1."
        );
      }
      const localVarPath =
        `/catalystDx/{instrumentId}/rejectQcLotQueryEnabled/{status}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CatalystDxApi - functional programming interface
 * @export
 */
export const CatalystDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLegacyQcEnabled(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = CatalystDxApiFetchParamCreator(
        configuration
      ).fetchLegacyQcEnabled(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = CatalystDxApiFetchParamCreator(
        configuration
      ).fetchRejectQcLotQueryEnabled1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLegacyQcEnabled(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystDxApiFetchParamCreator(
        configuration
      ).updateLegacyQcEnabled(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled1(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystDxApiFetchParamCreator(
        configuration
      ).updateRejectQcLotQueryEnabled1(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CatalystDxApi - factory interface
 * @export
 */
export const CatalystDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchLegacyQcEnabled(instrumentId: number, options?: any) {
      return CatalystDxApiFp(configuration).fetchLegacyQcEnabled(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled1(instrumentId: number, options?: any) {
      return CatalystDxApiFp(configuration).fetchRejectQcLotQueryEnabled1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the legacy qc enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLegacyQcEnabled(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return CatalystDxApiFp(configuration).updateLegacyQcEnabled(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled1(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return CatalystDxApiFp(configuration).updateRejectQcLotQueryEnabled1(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * CatalystDxApi - object-oriented interface
 * @export
 * @class CatalystDxApi
 * @extends {BaseAPI}
 */
export class CatalystDxApi extends BaseAPI {
  /**
   *
   * @summary Get the legacy qc enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystDxApi
   */
  public fetchLegacyQcEnabled(instrumentId: number, options?: any) {
    return CatalystDxApiFp(this.configuration).fetchLegacyQcEnabled(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the reject qc lot query enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystDxApi
   */
  public fetchRejectQcLotQueryEnabled1(instrumentId: number, options?: any) {
    return CatalystDxApiFp(this.configuration).fetchRejectQcLotQueryEnabled1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the legacy qc enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystDxApi
   */
  public updateLegacyQcEnabled(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return CatalystDxApiFp(this.configuration).updateLegacyQcEnabled(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the reject qc lot query enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystDxApi
   */
  public updateRejectQcLotQueryEnabled1(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return CatalystDxApiFp(this.configuration).updateRejectQcLotQueryEnabled1(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * CatalystOneApi - fetch parameter creator
 * @export
 */
export const CatalystOneApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling abortUpgrade1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/upgrade/abort`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a curves-only software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {string} curvesVersion The curves version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCurvesUpgrade(
      instrumentId: number,
      curvesVersion: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addCurvesUpgrade."
        );
      }
      // verify required parameter 'curvesVersion' is not null or undefined
      if (curvesVersion === null || curvesVersion === undefined) {
        throw new RequiredError(
          "curvesVersion",
          "Required parameter curvesVersion was null or undefined when calling addCurvesUpgrade."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/upgrade/curves/add/{curvesVersion}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"curvesVersion"}}`,
            encodeURIComponent(String(curvesVersion))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault1."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/fault/add/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {CatOneUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade1(
      instrumentId: number,
      upgradeDetails?: CatOneUpgradeInputDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addUpgrade1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/upgrade/add`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"CatOneUpgradeInputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(upgradeDetails || {})
        : upgradeDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchRejectQcLotQueryEnabled."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/rejectQcLotQueryEnabled`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchUpgrade1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/upgrade`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling pressStartButton1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/startButton`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault1."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault1."
        );
      }
      const localVarPath = `/catOne/{instrumentId}/fault/remove/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'GeneralClean' | 'Offsets' | 'OpticsCalibration' | 'Shutdown' | 'Optimize'} maintenanceProcedure The maintenance procedure.
     * @param {NextCatOneMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult1(
      instrumentId: number,
      maintenanceProcedure:
        | "GeneralClean"
        | "Offsets"
        | "OpticsCalibration"
        | "Shutdown"
        | "Optimize",
      body?: NextCatOneMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult1."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult1."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextCatOneMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateRejectQcLotQueryEnabled."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateRejectQcLotQueryEnabled."
        );
      }
      const localVarPath =
        `/catOne/{instrumentId}/rejectQcLotQueryEnabled/{status}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CatalystOneApi - functional programming interface
 * @export
 */
export const CatalystOneApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).abortUpgrade1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a curves-only software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {string} curvesVersion The curves version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCurvesUpgrade(
      instrumentId: number,
      curvesVersion: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).addCurvesUpgrade(instrumentId, curvesVersion, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).addFault1(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {CatOneUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade1(
      instrumentId: number,
      upgradeDetails?: CatOneUpgradeInputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).addUpgrade1(instrumentId, upgradeDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).fetchFaults1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).fetchRejectQcLotQueryEnabled(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CatOneUpgradeDto> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).fetchUpgrade1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).pressStartButton1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).removeFault1(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'GeneralClean' | 'Offsets' | 'OpticsCalibration' | 'Shutdown' | 'Optimize'} maintenanceProcedure The maintenance procedure.
     * @param {NextCatOneMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult1(
      instrumentId: number,
      maintenanceProcedure:
        | "GeneralClean"
        | "Offsets"
        | "OpticsCalibration"
        | "Shutdown"
        | "Optimize",
      body?: NextCatOneMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult1(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CatalystOneApiFetchParamCreator(
        configuration
      ).updateRejectQcLotQueryEnabled(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * CatalystOneApi - factory interface
 * @export
 */
export const CatalystOneApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade1(instrumentId: number, options?: any) {
      return CatalystOneApiFp(configuration).abortUpgrade1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a curves-only software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {string} curvesVersion The curves version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCurvesUpgrade(
      instrumentId: number,
      curvesVersion: string,
      options?: any
    ) {
      return CatalystOneApiFp(configuration).addCurvesUpgrade(
        instrumentId,
        curvesVersion,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options?: any
    ) {
      return CatalystOneApiFp(configuration).addFault1(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {CatOneUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade1(
      instrumentId: number,
      upgradeDetails?: CatOneUpgradeInputDto,
      options?: any
    ) {
      return CatalystOneApiFp(configuration).addUpgrade1(
        instrumentId,
        upgradeDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults1(instrumentId: number, options?: any) {
      return CatalystOneApiFp(configuration).fetchFaults1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRejectQcLotQueryEnabled(instrumentId: number, options?: any) {
      return CatalystOneApiFp(configuration).fetchRejectQcLotQueryEnabled(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade1(instrumentId: number, options?: any) {
      return CatalystOneApiFp(configuration).fetchUpgrade1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton1(instrumentId: number, options?: any) {
      return CatalystOneApiFp(configuration).pressStartButton1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault1(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UPDATE_FAILED"
        | "ADD_PIPETTE_TIPS"
        | "AIR_DETECTED_IN_SAMPLE"
        | "AIR_DETECTED_IN_SAMPLE_WARNING"
        | "ASPIRATION_FAILURE"
        | "BAD_OR_MISSING_CALCURVE_DATA"
        | "CALIBRATION_SOFTWARE_ERROR"
        | "CAMERA_INITIALIZATION_FAILURE"
        | "CANNOT_LOCK_SAMPLE_DRAWER"
        | "CANNOT_UNLOCK_SAMPLE_DRAWER"
        | "CAP_DETECTED"
        | "CAROUSEL_ALIGNMENT_FAILED"
        | "CAROUSEL_COVER_OPEN"
        | "CENTRIFUGE_ERROR"
        | "CLEANING_REQUIRED"
        | "DILUTION_SLIDE_COUNT_EXCEEDED"
        | "DUPLICATE_REAGENT_TYPE_DETECTED"
        | "FLUID_FIND_FAILURE_DIL_CUP"
        | "FLUID_FIND_FAILURE_MIX_CUP"
        | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
        | "INCORRECT_SLIDE_OR_REAGENT"
        | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
        | "INCORRECTLY_SEATED_CAROUSEL"
        | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
        | "INSUFFICIENT_DILUENT_VOLUME"
        | "INSUFFICIENT_PIPETTE_TIPS"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
        | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
        | "INTERNAL_TIMING_ERROR"
        | "MATERIALS_INCOMPATIBLE"
        | "MISSING_DILUTION_MATERIALS"
        | "MISSING_EMPTY_CUP"
        | "MISSING_REAGENT"
        | "MISSING_REAGENT_IGNORABLE"
        | "MISSING_UPC_MATERIALS"
        | "MULTIPLE_SAMPLES_DETECTED"
        | "NO_IDENTIFIABLE_SLIDES_FOUND"
        | "NO_SAMPLE_DETECTED"
        | "OPTICS_INITIALIZATION_FAILURE"
        | "OPTICS_MODULE_CONFIGURATION_ERROR"
        | "PHBR_LOAD_ERROR"
        | "PHBR_LOAD_ERROR_IGNORABLE"
        | "PIPETTE_TIPS_LOW"
        | "REAGENT_IDENTIFICATION_ERROR"
        | "RECOVERABLE_TIMEOUT"
        | "RECOVERY_FAILURE"
        | "ROBOT_HOMING_FAILURE"
        | "ROBOT_MOTION_ERROR"
        | "RUN_COMPLETION_ERROR"
        | "SAMPLE_DRAWER_LOCK_ERROR"
        | "SAMPLE_DRAWER_OPEN"
        | "SAMPLE_DRAWER_OPEN_RUN"
        | "SHIPPING_CLIPS_DETECTED"
        | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
        | "SLIDE_DETECTION_ERROR"
        | "SLIDE_EJECT_ERROR"
        | "SLIDE_LOADING_ERROR"
        | "SLIDE_TIMEOUT_ERROR"
        | "SPURIOUS_DEVICE_EVENT"
        | "THERMAL_CONTROL_ERROR"
        | "THERMAL_ERROR"
        | "UNSPECIFIED_ERROR"
        | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
        | "USER_CALIBRATION_UNSUCCESSFUL"
        | "WARMUP_THERMAL_ERROR"
        | "WASTE_DRAWER_FULL"
        | "WASTE_DRAWER_OPEN"
        | "WASTE_DRAWER_OPEN_RUN"
        | "UPGRADE_FAILED_PREPARATION"
        | "UPGRADE_FAILED_DOWNLOAD"
        | "WBS_SAMPLE_VOLUME_HIGH"
        | "CAMERA_COM_ERROR"
        | "CAMERA_CONNECTION_ERROR"
        | "CAROUSEL_ROTATION_ERROR"
        | "OPTICS_CALIBRATION_REQUIRED"
        | "SLIDE_REAGENT_MISMATCH"
        | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
        | "PRESSURE_SENSOR_ERROR"
        | "FLUID_FIND_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_ELLIPSE_INTERSECTION_FAIL"
        | "ALG_INTERFERING_SUBSTANCE"
        | "ALG_ION_CALIBRATION_DRIFT"
        | "ALG_ION_IMPULSE_DETECTED"
        | "ALG_ION_SAMPLE_DRIFT"
        | "ALG_ION_SAMPLE_ERROR"
        | "ALG_ION_SAMPLE_NOT_DETECTED"
        | "ALG_ION_SHIFT_DETECTED"
        | "ALG_NO_SAMPLE_DISPENSE"
        | "ALG_NO_WASH_1_DISPENSE"
        | "ALG_NO_WASH_2_DISPENSE"
        | "ALG_PHBR_BIASED_RESULT"
        | "ALG_SLIDE_NOT_SPOTTED"
        | "ALG_SUBSTRATE_DEPLETION"
        | "ASPIRATION_START_IN_AIR"
        | "ASPIRATION_START_IN_AIR_WARNING"
        | "BARCODE_READ_FAILURE"
        | "CLOT_DETECTED_IN_SAMPLE"
        | "CLOT_DETECTED_IN_SAMPLE_WARNING"
        | "FOAM_DETECTED_IN_SAMPLE"
        | "FOAM_DETECTED_IN_SAMPLE_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME"
        | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
        | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
        | "LVLASP_BUBBLE"
        | "LVLASP_CLOT"
        | "LVLASP_INSUFFICIENT_SAMPLE"
        | "LVLASP_START_IN_AIR"
        | "SAMPLE_TOO_LOW"
        | "SLIDE_CONTAMINATED"
        | "UNSUPPORTED_QC_RANGE"
        | "UNSUPPORTED_SLIDE_LOT"
        | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
        | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
        | "OFFSETS_OUT_OF_RANGE_ERROR"
        | "OFFSETS_CV_TOO_HIGH_ERROR"
        | "ALG_BAD_DRY_READ"
        | "ALG_BAD_SC_MINUS_DRY_DIFF"
        | "ALG_BAD_WASH_MINUS_SC_DIFF"
        | "ALG_BAD_LATE_SLOPE"
        | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
        | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
        | "ASSAY_NORMALIZATION_MISSING"
        | "ALG_SLOPE_NOT_CORRECTABLE"
        | "USED_REAGENT_DETECTED_WARNING"
        | "MATERIALS_INCOMPATIBLE_FRIENDS"
        | "SUSPECT_RESULT_COMPARISON"
        | "LYTE_PROCESSING_ERROR"
        | "ALG_BAD_RESPONSE_RANGE"
        | "OPTICS_LED_FAILURE"
        | "OPTICS_SENSOR_FAILURE"
        | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
        | "MISSING_IA_FOR_REAGENT"
        | "MISSING_REAGENT_FOR_IA"
        | "OFFSETS_CALIBRATION_ERROR"
        | "BARCODE_READ_ERROR"
        | "MISSING_EMPTY_DILUTION_CUP"
        | "PHBR_ORIENT_ERROR_IGNORABLE"
        | "PHBR_ORIENT_ERROR"
        | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
        | "SLIDE_REAGENT_LOT_MISMATCH"
        | "USED_REAGENT_DETECTED"
        | "USED_REAGENT_DETECTED_IGNORABLE"
        | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
        | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
        | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
        | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
        | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "OPTIMIZATION_AVAILABLE"
        | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
        | "CHECK_EVAP_CAP"
        | "ALG_DRY_READ_VARIANCE"
        | "RUN_CONSUMABLE_ID_START"
        | "PLAN_FAIL_TIPS_EXHAUSTED"
        | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
        | "UPGRADE_FAILED_VERIFICATION"
        | "UPGRADE_FAILED_INSTALLATION"
        | "SLIDE_TYPES_INCOMPATIBLE"
        | "DUPLICATE_SLIDE_DETECTED",
      options?: any
    ) {
      return CatalystOneApiFp(configuration).removeFault1(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'GeneralClean' | 'Offsets' | 'OpticsCalibration' | 'Shutdown' | 'Optimize'} maintenanceProcedure The maintenance procedure.
     * @param {NextCatOneMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult1(
      instrumentId: number,
      maintenanceProcedure:
        | "GeneralClean"
        | "Offsets"
        | "OpticsCalibration"
        | "Shutdown"
        | "Optimize",
      body?: NextCatOneMaintenanceResultDto,
      options?: any
    ) {
      return CatalystOneApiFp(configuration).setNextMaintenanceResult1(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the reject qc lot query enabled status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRejectQcLotQueryEnabled(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return CatalystOneApiFp(configuration).updateRejectQcLotQueryEnabled(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * CatalystOneApi - object-oriented interface
 * @export
 * @class CatalystOneApi
 * @extends {BaseAPI}
 */
export class CatalystOneApi extends BaseAPI {
  /**
   *
   * @summary Abort a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public abortUpgrade1(instrumentId: number, options?: any) {
    return CatalystOneApiFp(this.configuration).abortUpgrade1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a curves-only software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {string} curvesVersion The curves version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public addCurvesUpgrade(
    instrumentId: number,
    curvesVersion: string,
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).addCurvesUpgrade(
      instrumentId,
      curvesVersion,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public addFault1(
    instrumentId: number,
    faultEnum:
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED_CATASTROPHIC"
      | "UPDATE_FAILED"
      | "ADD_PIPETTE_TIPS"
      | "AIR_DETECTED_IN_SAMPLE"
      | "AIR_DETECTED_IN_SAMPLE_WARNING"
      | "ASPIRATION_FAILURE"
      | "BAD_OR_MISSING_CALCURVE_DATA"
      | "CALIBRATION_SOFTWARE_ERROR"
      | "CAMERA_INITIALIZATION_FAILURE"
      | "CANNOT_LOCK_SAMPLE_DRAWER"
      | "CANNOT_UNLOCK_SAMPLE_DRAWER"
      | "CAP_DETECTED"
      | "CAROUSEL_ALIGNMENT_FAILED"
      | "CAROUSEL_COVER_OPEN"
      | "CENTRIFUGE_ERROR"
      | "CLEANING_REQUIRED"
      | "DILUTION_SLIDE_COUNT_EXCEEDED"
      | "DUPLICATE_REAGENT_TYPE_DETECTED"
      | "FLUID_FIND_FAILURE_DIL_CUP"
      | "FLUID_FIND_FAILURE_MIX_CUP"
      | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
      | "INCORRECT_SLIDE_OR_REAGENT"
      | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
      | "INCORRECTLY_SEATED_CAROUSEL"
      | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
      | "INSUFFICIENT_DILUENT_VOLUME"
      | "INSUFFICIENT_PIPETTE_TIPS"
      | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
      | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
      | "INTERNAL_TIMING_ERROR"
      | "MATERIALS_INCOMPATIBLE"
      | "MISSING_DILUTION_MATERIALS"
      | "MISSING_EMPTY_CUP"
      | "MISSING_REAGENT"
      | "MISSING_REAGENT_IGNORABLE"
      | "MISSING_UPC_MATERIALS"
      | "MULTIPLE_SAMPLES_DETECTED"
      | "NO_IDENTIFIABLE_SLIDES_FOUND"
      | "NO_SAMPLE_DETECTED"
      | "OPTICS_INITIALIZATION_FAILURE"
      | "OPTICS_MODULE_CONFIGURATION_ERROR"
      | "PHBR_LOAD_ERROR"
      | "PHBR_LOAD_ERROR_IGNORABLE"
      | "PIPETTE_TIPS_LOW"
      | "REAGENT_IDENTIFICATION_ERROR"
      | "RECOVERABLE_TIMEOUT"
      | "RECOVERY_FAILURE"
      | "ROBOT_HOMING_FAILURE"
      | "ROBOT_MOTION_ERROR"
      | "RUN_COMPLETION_ERROR"
      | "SAMPLE_DRAWER_LOCK_ERROR"
      | "SAMPLE_DRAWER_OPEN"
      | "SAMPLE_DRAWER_OPEN_RUN"
      | "SHIPPING_CLIPS_DETECTED"
      | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
      | "SLIDE_DETECTION_ERROR"
      | "SLIDE_EJECT_ERROR"
      | "SLIDE_LOADING_ERROR"
      | "SLIDE_TIMEOUT_ERROR"
      | "SPURIOUS_DEVICE_EVENT"
      | "THERMAL_CONTROL_ERROR"
      | "THERMAL_ERROR"
      | "UNSPECIFIED_ERROR"
      | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
      | "USER_CALIBRATION_UNSUCCESSFUL"
      | "WARMUP_THERMAL_ERROR"
      | "WASTE_DRAWER_FULL"
      | "WASTE_DRAWER_OPEN"
      | "WASTE_DRAWER_OPEN_RUN"
      | "UPGRADE_FAILED_PREPARATION"
      | "UPGRADE_FAILED_DOWNLOAD"
      | "WBS_SAMPLE_VOLUME_HIGH"
      | "CAMERA_COM_ERROR"
      | "CAMERA_CONNECTION_ERROR"
      | "CAROUSEL_ROTATION_ERROR"
      | "OPTICS_CALIBRATION_REQUIRED"
      | "SLIDE_REAGENT_MISMATCH"
      | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
      | "PRESSURE_SENSOR_ERROR"
      | "FLUID_FIND_FAILURE"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
      | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
      | "ALG_BAD_SUB_MINUS_WASH_DIFF"
      | "ALG_ELLIPSE_INTERSECTION_FAIL"
      | "ALG_INTERFERING_SUBSTANCE"
      | "ALG_ION_CALIBRATION_DRIFT"
      | "ALG_ION_IMPULSE_DETECTED"
      | "ALG_ION_SAMPLE_DRIFT"
      | "ALG_ION_SAMPLE_ERROR"
      | "ALG_ION_SAMPLE_NOT_DETECTED"
      | "ALG_ION_SHIFT_DETECTED"
      | "ALG_NO_SAMPLE_DISPENSE"
      | "ALG_NO_WASH_1_DISPENSE"
      | "ALG_NO_WASH_2_DISPENSE"
      | "ALG_PHBR_BIASED_RESULT"
      | "ALG_SLIDE_NOT_SPOTTED"
      | "ALG_SUBSTRATE_DEPLETION"
      | "ASPIRATION_START_IN_AIR"
      | "ASPIRATION_START_IN_AIR_WARNING"
      | "BARCODE_READ_FAILURE"
      | "CLOT_DETECTED_IN_SAMPLE"
      | "CLOT_DETECTED_IN_SAMPLE_WARNING"
      | "FOAM_DETECTED_IN_SAMPLE"
      | "FOAM_DETECTED_IN_SAMPLE_WARNING"
      | "INSUFFICIENT_SAMPLE_VOLUME"
      | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
      | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
      | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
      | "LVLASP_BUBBLE"
      | "LVLASP_CLOT"
      | "LVLASP_INSUFFICIENT_SAMPLE"
      | "LVLASP_START_IN_AIR"
      | "SAMPLE_TOO_LOW"
      | "SLIDE_CONTAMINATED"
      | "UNSUPPORTED_QC_RANGE"
      | "UNSUPPORTED_SLIDE_LOT"
      | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
      | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
      | "OFFSETS_OUT_OF_RANGE_ERROR"
      | "OFFSETS_CV_TOO_HIGH_ERROR"
      | "ALG_BAD_DRY_READ"
      | "ALG_BAD_SC_MINUS_DRY_DIFF"
      | "ALG_BAD_WASH_MINUS_SC_DIFF"
      | "ALG_BAD_LATE_SLOPE"
      | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
      | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
      | "ASSAY_NORMALIZATION_MISSING"
      | "ALG_SLOPE_NOT_CORRECTABLE"
      | "USED_REAGENT_DETECTED_WARNING"
      | "MATERIALS_INCOMPATIBLE_FRIENDS"
      | "SUSPECT_RESULT_COMPARISON"
      | "LYTE_PROCESSING_ERROR"
      | "ALG_BAD_RESPONSE_RANGE"
      | "OPTICS_LED_FAILURE"
      | "OPTICS_SENSOR_FAILURE"
      | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
      | "MISSING_IA_FOR_REAGENT"
      | "MISSING_REAGENT_FOR_IA"
      | "OFFSETS_CALIBRATION_ERROR"
      | "BARCODE_READ_ERROR"
      | "MISSING_EMPTY_DILUTION_CUP"
      | "PHBR_ORIENT_ERROR_IGNORABLE"
      | "PHBR_ORIENT_ERROR"
      | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
      | "SLIDE_REAGENT_LOT_MISMATCH"
      | "USED_REAGENT_DETECTED"
      | "USED_REAGENT_DETECTED_IGNORABLE"
      | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
      | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
      | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
      | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
      | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "OPTIMIZATION_AVAILABLE"
      | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
      | "CHECK_EVAP_CAP"
      | "ALG_DRY_READ_VARIANCE"
      | "RUN_CONSUMABLE_ID_START"
      | "PLAN_FAIL_TIPS_EXHAUSTED"
      | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
      | "UPGRADE_FAILED_VERIFICATION"
      | "UPGRADE_FAILED_INSTALLATION"
      | "SLIDE_TYPES_INCOMPATIBLE"
      | "DUPLICATE_SLIDE_DETECTED",
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).addFault1(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {CatOneUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public addUpgrade1(
    instrumentId: number,
    upgradeDetails?: CatOneUpgradeInputDto,
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).addUpgrade1(
      instrumentId,
      upgradeDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public fetchFaults1(instrumentId: number, options?: any) {
    return CatalystOneApiFp(this.configuration).fetchFaults1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the reject qc lot query enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public fetchRejectQcLotQueryEnabled(instrumentId: number, options?: any) {
    return CatalystOneApiFp(this.configuration).fetchRejectQcLotQueryEnabled(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the details of the active upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public fetchUpgrade1(instrumentId: number, options?: any) {
    return CatalystOneApiFp(this.configuration).fetchUpgrade1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Presses the 'Start' button on the instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public pressStartButton1(instrumentId: number, options?: any) {
    return CatalystOneApiFp(this.configuration).pressStartButton1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED_CATASTROPHIC' | 'UPDATE_FAILED' | 'ADD_PIPETTE_TIPS' | 'AIR_DETECTED_IN_SAMPLE' | 'AIR_DETECTED_IN_SAMPLE_WARNING' | 'ASPIRATION_FAILURE' | 'BAD_OR_MISSING_CALCURVE_DATA' | 'CALIBRATION_SOFTWARE_ERROR' | 'CAMERA_INITIALIZATION_FAILURE' | 'CANNOT_LOCK_SAMPLE_DRAWER' | 'CANNOT_UNLOCK_SAMPLE_DRAWER' | 'CAP_DETECTED' | 'CAROUSEL_ALIGNMENT_FAILED' | 'CAROUSEL_COVER_OPEN' | 'CENTRIFUGE_ERROR' | 'CLEANING_REQUIRED' | 'DILUTION_SLIDE_COUNT_EXCEEDED' | 'DUPLICATE_REAGENT_TYPE_DETECTED' | 'FLUID_FIND_FAILURE_DIL_CUP' | 'FLUID_FIND_FAILURE_MIX_CUP' | 'HEIGHT_CORRECTION_SURFACE_FIND_FAILURE' | 'INCORRECT_SLIDE_OR_REAGENT' | 'INCORRECT_SLIDE_OR_REAGENT_IGNORABLE' | 'INCORRECTLY_SEATED_CAROUSEL' | 'INSUFFICIENT_DILUENT_VOLUME_WARNING' | 'INSUFFICIENT_DILUENT_VOLUME' | 'INSUFFICIENT_PIPETTE_TIPS' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING' | 'INSUFFICIENT_SAMPLE_FOR_DILUTION' | 'INTERNAL_TIMING_ERROR' | 'MATERIALS_INCOMPATIBLE' | 'MISSING_DILUTION_MATERIALS' | 'MISSING_EMPTY_CUP' | 'MISSING_REAGENT' | 'MISSING_REAGENT_IGNORABLE' | 'MISSING_UPC_MATERIALS' | 'MULTIPLE_SAMPLES_DETECTED' | 'NO_IDENTIFIABLE_SLIDES_FOUND' | 'NO_SAMPLE_DETECTED' | 'OPTICS_INITIALIZATION_FAILURE' | 'OPTICS_MODULE_CONFIGURATION_ERROR' | 'PHBR_LOAD_ERROR' | 'PHBR_LOAD_ERROR_IGNORABLE' | 'PIPETTE_TIPS_LOW' | 'REAGENT_IDENTIFICATION_ERROR' | 'RECOVERABLE_TIMEOUT' | 'RECOVERY_FAILURE' | 'ROBOT_HOMING_FAILURE' | 'ROBOT_MOTION_ERROR' | 'RUN_COMPLETION_ERROR' | 'SAMPLE_DRAWER_LOCK_ERROR' | 'SAMPLE_DRAWER_OPEN' | 'SAMPLE_DRAWER_OPEN_RUN' | 'SHIPPING_CLIPS_DETECTED' | 'SLIDE_DATE_SOFTWARE_VERSION_MISMATCH' | 'SLIDE_DETECTION_ERROR' | 'SLIDE_EJECT_ERROR' | 'SLIDE_LOADING_ERROR' | 'SLIDE_TIMEOUT_ERROR' | 'SPURIOUS_DEVICE_EVENT' | 'THERMAL_CONTROL_ERROR' | 'THERMAL_ERROR' | 'UNSPECIFIED_ERROR' | 'UNSUPPORTED_WHITE_REF_SLIDE_LOT' | 'USER_CALIBRATION_UNSUCCESSFUL' | 'WARMUP_THERMAL_ERROR' | 'WASTE_DRAWER_FULL' | 'WASTE_DRAWER_OPEN' | 'WASTE_DRAWER_OPEN_RUN' | 'UPGRADE_FAILED_PREPARATION' | 'UPGRADE_FAILED_DOWNLOAD' | 'WBS_SAMPLE_VOLUME_HIGH' | 'CAMERA_COM_ERROR' | 'CAMERA_CONNECTION_ERROR' | 'CAROUSEL_ROTATION_ERROR' | 'OPTICS_CALIBRATION_REQUIRED' | 'SLIDE_REAGENT_MISMATCH' | 'SLIDE_REAGENT_MISMATCH_IGNORABLE' | 'PRESSURE_SENSOR_ERROR' | 'FLUID_FIND_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'ALG_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_ELLIPSE_INTERSECTION_FAIL' | 'ALG_INTERFERING_SUBSTANCE' | 'ALG_ION_CALIBRATION_DRIFT' | 'ALG_ION_IMPULSE_DETECTED' | 'ALG_ION_SAMPLE_DRIFT' | 'ALG_ION_SAMPLE_ERROR' | 'ALG_ION_SAMPLE_NOT_DETECTED' | 'ALG_ION_SHIFT_DETECTED' | 'ALG_NO_SAMPLE_DISPENSE' | 'ALG_NO_WASH_1_DISPENSE' | 'ALG_NO_WASH_2_DISPENSE' | 'ALG_PHBR_BIASED_RESULT' | 'ALG_SLIDE_NOT_SPOTTED' | 'ALG_SUBSTRATE_DEPLETION' | 'ASPIRATION_START_IN_AIR' | 'ASPIRATION_START_IN_AIR_WARNING' | 'BARCODE_READ_FAILURE' | 'CLOT_DETECTED_IN_SAMPLE' | 'CLOT_DETECTED_IN_SAMPLE_WARNING' | 'FOAM_DETECTED_IN_SAMPLE' | 'FOAM_DETECTED_IN_SAMPLE_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME' | 'INSUFFICIENT_SAMPLE_VOLUME_WARNING' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE' | 'INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING' | 'LVLASP_BUBBLE' | 'LVLASP_CLOT' | 'LVLASP_INSUFFICIENT_SAMPLE' | 'LVLASP_START_IN_AIR' | 'SAMPLE_TOO_LOW' | 'SLIDE_CONTAMINATED' | 'UNSUPPORTED_QC_RANGE' | 'UNSUPPORTED_SLIDE_LOT' | 'USED_REAGENT_DETECTED_IGNORABLE_WARNING' | 'OFFSETS_INSUFFICIENT_SLIDES_ERROR' | 'OFFSETS_OUT_OF_RANGE_ERROR' | 'OFFSETS_CV_TOO_HIGH_ERROR' | 'ALG_BAD_DRY_READ' | 'ALG_BAD_SC_MINUS_DRY_DIFF' | 'ALG_BAD_WASH_MINUS_SC_DIFF' | 'ALG_BAD_LATE_SLOPE' | 'ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT' | 'ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT' | 'ASSAY_NORMALIZATION_MISSING' | 'ALG_SLOPE_NOT_CORRECTABLE' | 'USED_REAGENT_DETECTED_WARNING' | 'MATERIALS_INCOMPATIBLE_FRIENDS' | 'SUSPECT_RESULT_COMPARISON' | 'LYTE_PROCESSING_ERROR' | 'ALG_BAD_RESPONSE_RANGE' | 'OPTICS_LED_FAILURE' | 'OPTICS_SENSOR_FAILURE' | 'ALG_SLOPE_NOT_CORRECTABLE_GEN' | 'MISSING_IA_FOR_REAGENT' | 'MISSING_REAGENT_FOR_IA' | 'OFFSETS_CALIBRATION_ERROR' | 'BARCODE_READ_ERROR' | 'MISSING_EMPTY_DILUTION_CUP' | 'PHBR_ORIENT_ERROR_IGNORABLE' | 'PHBR_ORIENT_ERROR' | 'SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE' | 'SLIDE_REAGENT_LOT_MISMATCH' | 'USED_REAGENT_DETECTED' | 'USED_REAGENT_DETECTED_IGNORABLE' | 'ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ' | 'ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT' | 'ALG_TT4_BAD_SUB_MINUS_WASH_DIFF' | 'ALG_TT4_ELLIPSE_INTERSECTION_FAIL' | 'ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'OPTIMIZATION_AVAILABLE' | 'OPTIMIZATION_AVAILABLE_ALIGNMENT' | 'CHECK_EVAP_CAP' | 'ALG_DRY_READ_VARIANCE' | 'RUN_CONSUMABLE_ID_START' | 'PLAN_FAIL_TIPS_EXHAUSTED' | 'PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED' | 'UPGRADE_FAILED_VERIFICATION' | 'UPGRADE_FAILED_INSTALLATION' | 'SLIDE_TYPES_INCOMPATIBLE' | 'DUPLICATE_SLIDE_DETECTED'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public removeFault1(
    instrumentId: number,
    faultEnum:
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED_CATASTROPHIC"
      | "UPDATE_FAILED"
      | "ADD_PIPETTE_TIPS"
      | "AIR_DETECTED_IN_SAMPLE"
      | "AIR_DETECTED_IN_SAMPLE_WARNING"
      | "ASPIRATION_FAILURE"
      | "BAD_OR_MISSING_CALCURVE_DATA"
      | "CALIBRATION_SOFTWARE_ERROR"
      | "CAMERA_INITIALIZATION_FAILURE"
      | "CANNOT_LOCK_SAMPLE_DRAWER"
      | "CANNOT_UNLOCK_SAMPLE_DRAWER"
      | "CAP_DETECTED"
      | "CAROUSEL_ALIGNMENT_FAILED"
      | "CAROUSEL_COVER_OPEN"
      | "CENTRIFUGE_ERROR"
      | "CLEANING_REQUIRED"
      | "DILUTION_SLIDE_COUNT_EXCEEDED"
      | "DUPLICATE_REAGENT_TYPE_DETECTED"
      | "FLUID_FIND_FAILURE_DIL_CUP"
      | "FLUID_FIND_FAILURE_MIX_CUP"
      | "HEIGHT_CORRECTION_SURFACE_FIND_FAILURE"
      | "INCORRECT_SLIDE_OR_REAGENT"
      | "INCORRECT_SLIDE_OR_REAGENT_IGNORABLE"
      | "INCORRECTLY_SEATED_CAROUSEL"
      | "INSUFFICIENT_DILUENT_VOLUME_WARNING"
      | "INSUFFICIENT_DILUENT_VOLUME"
      | "INSUFFICIENT_PIPETTE_TIPS"
      | "INSUFFICIENT_SAMPLE_FOR_DILUTION_WARNING"
      | "INSUFFICIENT_SAMPLE_FOR_DILUTION"
      | "INTERNAL_TIMING_ERROR"
      | "MATERIALS_INCOMPATIBLE"
      | "MISSING_DILUTION_MATERIALS"
      | "MISSING_EMPTY_CUP"
      | "MISSING_REAGENT"
      | "MISSING_REAGENT_IGNORABLE"
      | "MISSING_UPC_MATERIALS"
      | "MULTIPLE_SAMPLES_DETECTED"
      | "NO_IDENTIFIABLE_SLIDES_FOUND"
      | "NO_SAMPLE_DETECTED"
      | "OPTICS_INITIALIZATION_FAILURE"
      | "OPTICS_MODULE_CONFIGURATION_ERROR"
      | "PHBR_LOAD_ERROR"
      | "PHBR_LOAD_ERROR_IGNORABLE"
      | "PIPETTE_TIPS_LOW"
      | "REAGENT_IDENTIFICATION_ERROR"
      | "RECOVERABLE_TIMEOUT"
      | "RECOVERY_FAILURE"
      | "ROBOT_HOMING_FAILURE"
      | "ROBOT_MOTION_ERROR"
      | "RUN_COMPLETION_ERROR"
      | "SAMPLE_DRAWER_LOCK_ERROR"
      | "SAMPLE_DRAWER_OPEN"
      | "SAMPLE_DRAWER_OPEN_RUN"
      | "SHIPPING_CLIPS_DETECTED"
      | "SLIDE_DATE_SOFTWARE_VERSION_MISMATCH"
      | "SLIDE_DETECTION_ERROR"
      | "SLIDE_EJECT_ERROR"
      | "SLIDE_LOADING_ERROR"
      | "SLIDE_TIMEOUT_ERROR"
      | "SPURIOUS_DEVICE_EVENT"
      | "THERMAL_CONTROL_ERROR"
      | "THERMAL_ERROR"
      | "UNSPECIFIED_ERROR"
      | "UNSUPPORTED_WHITE_REF_SLIDE_LOT"
      | "USER_CALIBRATION_UNSUCCESSFUL"
      | "WARMUP_THERMAL_ERROR"
      | "WASTE_DRAWER_FULL"
      | "WASTE_DRAWER_OPEN"
      | "WASTE_DRAWER_OPEN_RUN"
      | "UPGRADE_FAILED_PREPARATION"
      | "UPGRADE_FAILED_DOWNLOAD"
      | "WBS_SAMPLE_VOLUME_HIGH"
      | "CAMERA_COM_ERROR"
      | "CAMERA_CONNECTION_ERROR"
      | "CAROUSEL_ROTATION_ERROR"
      | "OPTICS_CALIBRATION_REQUIRED"
      | "SLIDE_REAGENT_MISMATCH"
      | "SLIDE_REAGENT_MISMATCH_IGNORABLE"
      | "PRESSURE_SENSOR_ERROR"
      | "FLUID_FIND_FAILURE"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "ALG_ANOM_INIT_SLOPE_VS_SUB_READ"
      | "ALG_ANOM_PROG_CURVE_DEVELOPMENT"
      | "ALG_BAD_SUB_MINUS_WASH_DIFF"
      | "ALG_ELLIPSE_INTERSECTION_FAIL"
      | "ALG_INTERFERING_SUBSTANCE"
      | "ALG_ION_CALIBRATION_DRIFT"
      | "ALG_ION_IMPULSE_DETECTED"
      | "ALG_ION_SAMPLE_DRIFT"
      | "ALG_ION_SAMPLE_ERROR"
      | "ALG_ION_SAMPLE_NOT_DETECTED"
      | "ALG_ION_SHIFT_DETECTED"
      | "ALG_NO_SAMPLE_DISPENSE"
      | "ALG_NO_WASH_1_DISPENSE"
      | "ALG_NO_WASH_2_DISPENSE"
      | "ALG_PHBR_BIASED_RESULT"
      | "ALG_SLIDE_NOT_SPOTTED"
      | "ALG_SUBSTRATE_DEPLETION"
      | "ASPIRATION_START_IN_AIR"
      | "ASPIRATION_START_IN_AIR_WARNING"
      | "BARCODE_READ_FAILURE"
      | "CLOT_DETECTED_IN_SAMPLE"
      | "CLOT_DETECTED_IN_SAMPLE_WARNING"
      | "FOAM_DETECTED_IN_SAMPLE"
      | "FOAM_DETECTED_IN_SAMPLE_WARNING"
      | "INSUFFICIENT_SAMPLE_VOLUME"
      | "INSUFFICIENT_SAMPLE_VOLUME_WARNING"
      | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE"
      | "INSUFFICIENT_SAMPLE_VOLUME_IGNORABLE_WARNING"
      | "LVLASP_BUBBLE"
      | "LVLASP_CLOT"
      | "LVLASP_INSUFFICIENT_SAMPLE"
      | "LVLASP_START_IN_AIR"
      | "SAMPLE_TOO_LOW"
      | "SLIDE_CONTAMINATED"
      | "UNSUPPORTED_QC_RANGE"
      | "UNSUPPORTED_SLIDE_LOT"
      | "USED_REAGENT_DETECTED_IGNORABLE_WARNING"
      | "OFFSETS_INSUFFICIENT_SLIDES_ERROR"
      | "OFFSETS_OUT_OF_RANGE_ERROR"
      | "OFFSETS_CV_TOO_HIGH_ERROR"
      | "ALG_BAD_DRY_READ"
      | "ALG_BAD_SC_MINUS_DRY_DIFF"
      | "ALG_BAD_WASH_MINUS_SC_DIFF"
      | "ALG_BAD_LATE_SLOPE"
      | "ALG_GREATER_THAN_EXTREME_HIGH_CONC_LIMIT"
      | "ALG_GREATER_THAN_EXTREME_LOW_CONC_LIMIT"
      | "ASSAY_NORMALIZATION_MISSING"
      | "ALG_SLOPE_NOT_CORRECTABLE"
      | "USED_REAGENT_DETECTED_WARNING"
      | "MATERIALS_INCOMPATIBLE_FRIENDS"
      | "SUSPECT_RESULT_COMPARISON"
      | "LYTE_PROCESSING_ERROR"
      | "ALG_BAD_RESPONSE_RANGE"
      | "OPTICS_LED_FAILURE"
      | "OPTICS_SENSOR_FAILURE"
      | "ALG_SLOPE_NOT_CORRECTABLE_GEN"
      | "MISSING_IA_FOR_REAGENT"
      | "MISSING_REAGENT_FOR_IA"
      | "OFFSETS_CALIBRATION_ERROR"
      | "BARCODE_READ_ERROR"
      | "MISSING_EMPTY_DILUTION_CUP"
      | "PHBR_ORIENT_ERROR_IGNORABLE"
      | "PHBR_ORIENT_ERROR"
      | "SLIDE_REAGENT_LOT_MISMATCH_IGNORABLE"
      | "SLIDE_REAGENT_LOT_MISMATCH"
      | "USED_REAGENT_DETECTED"
      | "USED_REAGENT_DETECTED_IGNORABLE"
      | "ALG_TT4_ANOM_INIT_SLOPE_VS_SUB_READ"
      | "ALG_TT4_ANOM_PROG_CURVE_DEVELOPMENT"
      | "ALG_TT4_BAD_SUB_MINUS_WASH_DIFF"
      | "ALG_TT4_ELLIPSE_INTERSECTION_FAIL"
      | "ERR_ALG_ALGORITHM_INTERFERING_SUBSTANCE"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "OPTIMIZATION_AVAILABLE"
      | "OPTIMIZATION_AVAILABLE_ALIGNMENT"
      | "CHECK_EVAP_CAP"
      | "ALG_DRY_READ_VARIANCE"
      | "RUN_CONSUMABLE_ID_START"
      | "PLAN_FAIL_TIPS_EXHAUSTED"
      | "PLAN_FAIL_REPLAN_ATTEMPTS_EXCEEDED"
      | "UPGRADE_FAILED_VERIFICATION"
      | "UPGRADE_FAILED_INSTALLATION"
      | "SLIDE_TYPES_INCOMPATIBLE"
      | "DUPLICATE_SLIDE_DETECTED",
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).removeFault1(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'GeneralClean' | 'Offsets' | 'OpticsCalibration' | 'Shutdown' | 'Optimize'} maintenanceProcedure The maintenance procedure.
   * @param {NextCatOneMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public setNextMaintenanceResult1(
    instrumentId: number,
    maintenanceProcedure:
      | "GeneralClean"
      | "Offsets"
      | "OpticsCalibration"
      | "Shutdown"
      | "Optimize",
    body?: NextCatOneMaintenanceResultDto,
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).setNextMaintenanceResult1(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the reject qc lot query enabled status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CatalystOneApi
   */
  public updateRejectQcLotQueryEnabled(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return CatalystOneApiFp(this.configuration).updateRejectQcLotQueryEnabled(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * InstrumentApi - fetch parameter creator
 * @export
 */
export const InstrumentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * For ProCyte Dx, the instrument serial number must start with 'IPU' and the main unit serial number must start with 'A'.
     * @summary Add a new instrument.
     * @param {'Catalyst Dx' | 'Catalyst One' | 'ProCyte Dx' | 'SediVue Dx' | 'SnapPro' | 'SnapShot Dx' | 'Acadia Dx' | 'UriSys Dx' | 'Theia' | 'Tensei'} instrumentType The instrument type.
     * @param {InstrumentInputDto} [instrumentDetails] The details of the instrument to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInstrument(
      instrumentType:
        | "Catalyst Dx"
        | "Catalyst One"
        | "ProCyte Dx"
        | "SediVue Dx"
        | "SnapPro"
        | "SnapShot Dx"
        | "Acadia Dx"
        | "UriSys Dx"
        | "Theia"
        | "Tensei",
      instrumentDetails?: InstrumentInputDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentType' is not null or undefined
      if (instrumentType === null || instrumentType === undefined) {
        throw new RequiredError(
          "instrumentType",
          "Required parameter instrumentType was null or undefined when calling addInstrument."
        );
      }
      const localVarPath = `/instrument/add/{instrumentType}`.replace(
        `{${"instrumentType"}}`,
        encodeURIComponent(String(instrumentType))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentInputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(instrumentDetails || {})
        : instrumentDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutorun(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAutorun."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/autorun`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the details of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active instruments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstruments(options: any = {}): FetchArgs {
      const localVarPath = `/instrument`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the power cycle status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPowerCycling(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchPowerCycling."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/powerCycle`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the reboot status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRebooting(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchRebooting."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/reboot`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the turned off status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTurnedOff(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchTurnedOff."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/turnOff/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cause an instrument to reboot.
     * @param {number} instrumentId The instrument id.
     * @param {number} rebootTimeInMillis The reboot time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rebootInstrument(
      instrumentId: number,
      rebootTimeInMillis: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling rebootInstrument."
        );
      }
      // verify required parameter 'rebootTimeInMillis' is not null or undefined
      if (rebootTimeInMillis === null || rebootTimeInMillis === undefined) {
        throw new RequiredError(
          "rebootTimeInMillis",
          "Required parameter rebootTimeInMillis was null or undefined when calling rebootInstrument."
        );
      }
      const localVarPath =
        `/instrument/{instrumentId}/reboot/{rebootTimeInMillis}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"rebootTimeInMillis"}}`,
            encodeURIComponent(String(rebootTimeInMillis))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/remove`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cause an instrument to start power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {number} cycleTimeInMillis The cycle time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startPowerCycleInstrument(
      instrumentId: number,
      cycleTimeInMillis: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling startPowerCycleInstrument."
        );
      }
      // verify required parameter 'cycleTimeInMillis' is not null or undefined
      if (cycleTimeInMillis === null || cycleTimeInMillis === undefined) {
        throw new RequiredError(
          "cycleTimeInMillis",
          "Required parameter cycleTimeInMillis was null or undefined when calling startPowerCycleInstrument."
        );
      }
      const localVarPath =
        `/instrument/{instrumentId}/powerCycle/start/{cycleTimeInMillis}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"cycleTimeInMillis"}}`,
            encodeURIComponent(String(cycleTimeInMillis))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cause an instrument to stop power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopPowerCycleInstrument(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling stopPowerCycleInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/powerCycle/stop`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Turn off an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling turnOffInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/turnOff`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Turn on an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnInstrument(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling turnOnInstrument."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/turnOn`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutorun(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateAutorun."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateAutorun."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/autorun/{status}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {IrisInstrumentStatusDto} [body] The instrument status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentStatus(
      instrumentId: number,
      body?: IrisInstrumentStatusDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateInstrumentStatus."
        );
      }
      const localVarPath = `/instrument/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"IrisInstrumentStatusDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstrumentApi - functional programming interface
 * @export
 */
export const InstrumentApiFp = function (configuration?: Configuration) {
  return {
    /**
     * For ProCyte Dx, the instrument serial number must start with 'IPU' and the main unit serial number must start with 'A'.
     * @summary Add a new instrument.
     * @param {'Catalyst Dx' | 'Catalyst One' | 'ProCyte Dx' | 'SediVue Dx' | 'SnapPro' | 'SnapShot Dx' | 'Acadia Dx' | 'UriSys Dx' | 'Theia' | 'Tensei'} instrumentType The instrument type.
     * @param {InstrumentInputDto} [instrumentDetails] The details of the instrument to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInstrument(
      instrumentType:
        | "Catalyst Dx"
        | "Catalyst One"
        | "ProCyte Dx"
        | "SediVue Dx"
        | "SnapPro"
        | "SnapShot Dx"
        | "Acadia Dx"
        | "UriSys Dx"
        | "Theia"
        | "Tensei",
      instrumentDetails?: InstrumentInputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisInstrumentDto> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).addInstrument(instrumentType, instrumentDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutorun(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchAutorun(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the details of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisInstrumentDto> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active instruments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstruments(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<IrisInstrumentDto>> {
      const localVarFetchArgs =
        InstrumentApiFetchParamCreator(configuration).fetchInstruments(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the power cycle status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPowerCycling(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchPowerCycling(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the reboot status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRebooting(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchRebooting(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the turned off status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTurnedOff(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).fetchTurnedOff(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cause an instrument to reboot.
     * @param {number} instrumentId The instrument id.
     * @param {number} rebootTimeInMillis The reboot time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rebootInstrument(
      instrumentId: number,
      rebootTimeInMillis: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).rebootInstrument(instrumentId, rebootTimeInMillis, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).removeInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cause an instrument to start power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {number} cycleTimeInMillis The cycle time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startPowerCycleInstrument(
      instrumentId: number,
      cycleTimeInMillis: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).startPowerCycleInstrument(instrumentId, cycleTimeInMillis, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Cause an instrument to stop power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopPowerCycleInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).stopPowerCycleInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Turn off an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).turnOffInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Turn on an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnInstrument(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).turnOnInstrument(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutorun(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).updateAutorun(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {IrisInstrumentStatusDto} [body] The instrument status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentStatus(
      instrumentId: number,
      body?: IrisInstrumentStatusDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = InstrumentApiFetchParamCreator(
        configuration
      ).updateInstrumentStatus(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InstrumentApi - factory interface
 * @export
 */
export const InstrumentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * For ProCyte Dx, the instrument serial number must start with 'IPU' and the main unit serial number must start with 'A'.
     * @summary Add a new instrument.
     * @param {'Catalyst Dx' | 'Catalyst One' | 'ProCyte Dx' | 'SediVue Dx' | 'SnapPro' | 'SnapShot Dx' | 'Acadia Dx' | 'UriSys Dx' | 'Theia' | 'Tensei'} instrumentType The instrument type.
     * @param {InstrumentInputDto} [instrumentDetails] The details of the instrument to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInstrument(
      instrumentType:
        | "Catalyst Dx"
        | "Catalyst One"
        | "ProCyte Dx"
        | "SediVue Dx"
        | "SnapPro"
        | "SnapShot Dx"
        | "Acadia Dx"
        | "UriSys Dx"
        | "Theia"
        | "Tensei",
      instrumentDetails?: InstrumentInputDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).addInstrument(
        instrumentType,
        instrumentDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutorun(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchAutorun(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the details of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active instruments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstruments(options?: any) {
      return InstrumentApiFp(configuration).fetchInstruments(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the power cycle status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchPowerCycling(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchPowerCycling(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the reboot status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRebooting(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchRebooting(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the turned off status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchTurnedOff(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).fetchTurnedOff(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cause an instrument to reboot.
     * @param {number} instrumentId The instrument id.
     * @param {number} rebootTimeInMillis The reboot time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rebootInstrument(
      instrumentId: number,
      rebootTimeInMillis: number,
      options?: any
    ) {
      return InstrumentApiFp(configuration).rebootInstrument(
        instrumentId,
        rebootTimeInMillis,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).removeInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cause an instrument to start power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {number} cycleTimeInMillis The cycle time in milliseconds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startPowerCycleInstrument(
      instrumentId: number,
      cycleTimeInMillis: number,
      options?: any
    ) {
      return InstrumentApiFp(configuration).startPowerCycleInstrument(
        instrumentId,
        cycleTimeInMillis,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Cause an instrument to stop power cycling.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stopPowerCycleInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).stopPowerCycleInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Turn off an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).turnOffInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Turn on an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnInstrument(instrumentId: number, options?: any) {
      return InstrumentApiFp(configuration).turnOnInstrument(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the autorun status of an instrument.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutorun(instrumentId: number, status: boolean, options?: any) {
      return InstrumentApiFp(configuration).updateAutorun(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {IrisInstrumentStatusDto} [body] The instrument status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInstrumentStatus(
      instrumentId: number,
      body?: IrisInstrumentStatusDto,
      options?: any
    ) {
      return InstrumentApiFp(configuration).updateInstrumentStatus(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InstrumentApi - object-oriented interface
 * @export
 * @class InstrumentApi
 * @extends {BaseAPI}
 */
export class InstrumentApi extends BaseAPI {
  /**
   * For ProCyte Dx, the instrument serial number must start with 'IPU' and the main unit serial number must start with 'A'.
   * @summary Add a new instrument.
   * @param {'Catalyst Dx' | 'Catalyst One' | 'ProCyte Dx' | 'SediVue Dx' | 'SnapPro' | 'SnapShot Dx' | 'Acadia Dx' | 'UriSys Dx' | 'Theia' | 'Tensei'} instrumentType The instrument type.
   * @param {InstrumentInputDto} [instrumentDetails] The details of the instrument to be added.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public addInstrument(
    instrumentType:
      | "Catalyst Dx"
      | "Catalyst One"
      | "ProCyte Dx"
      | "SediVue Dx"
      | "SnapPro"
      | "SnapShot Dx"
      | "Acadia Dx"
      | "UriSys Dx"
      | "Theia"
      | "Tensei",
    instrumentDetails?: InstrumentInputDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).addInstrument(
      instrumentType,
      instrumentDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the autorun status of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchAutorun(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchAutorun(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the details of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active instruments.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchInstruments(options?: any) {
    return InstrumentApiFp(this.configuration).fetchInstruments(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the power cycle status of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchPowerCycling(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchPowerCycling(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the reboot status of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchRebooting(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchRebooting(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the turned off status of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public fetchTurnedOff(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).fetchTurnedOff(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cause an instrument to reboot.
   * @param {number} instrumentId The instrument id.
   * @param {number} rebootTimeInMillis The reboot time in milliseconds.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public rebootInstrument(
    instrumentId: number,
    rebootTimeInMillis: number,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).rebootInstrument(
      instrumentId,
      rebootTimeInMillis,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public removeInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).removeInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cause an instrument to start power cycling.
   * @param {number} instrumentId The instrument id.
   * @param {number} cycleTimeInMillis The cycle time in milliseconds.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public startPowerCycleInstrument(
    instrumentId: number,
    cycleTimeInMillis: number,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).startPowerCycleInstrument(
      instrumentId,
      cycleTimeInMillis,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Cause an instrument to stop power cycling.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public stopPowerCycleInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).stopPowerCycleInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Turn off an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public turnOffInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).turnOffInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Turn on an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public turnOnInstrument(instrumentId: number, options?: any) {
    return InstrumentApiFp(this.configuration).turnOnInstrument(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the autorun status of an instrument.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public updateAutorun(instrumentId: number, status: boolean, options?: any) {
    return InstrumentApiFp(this.configuration).updateAutorun(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the instrument status.
   * @param {number} instrumentId The instrument id.
   * @param {IrisInstrumentStatusDto} [body] The instrument status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstrumentApi
   */
  public updateInstrumentStatus(
    instrumentId: number,
    body?: IrisInstrumentStatusDto,
    options?: any
  ) {
    return InstrumentApiFp(this.configuration).updateInstrumentStatus(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * IrapInstrumentApi - fetch parameter creator
 * @export
 */
export const IrapInstrumentApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the FTP credentials of an IRAP instrument.
     * @param {number} instrumentId The instrument id.
     * @param {'FILE' | 'UPGRADE'} ftpCredentialType The FTP credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFtpCredentials(
      instrumentId: number,
      ftpCredentialType: "FILE" | "UPGRADE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFtpCredentials."
        );
      }
      // verify required parameter 'ftpCredentialType' is not null or undefined
      if (ftpCredentialType === null || ftpCredentialType === undefined) {
        throw new RequiredError(
          "ftpCredentialType",
          "Required parameter ftpCredentialType was null or undefined when calling fetchFtpCredentials."
        );
      }
      const localVarPath =
        `/irapInstrument/{instrumentId}/ftp/{ftpCredentialType}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"ftpCredentialType"}}`,
            encodeURIComponent(String(ftpCredentialType))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IrapInstrumentApi - functional programming interface
 * @export
 */
export const IrapInstrumentApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the FTP credentials of an IRAP instrument.
     * @param {number} instrumentId The instrument id.
     * @param {'FILE' | 'UPGRADE'} ftpCredentialType The FTP credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFtpCredentials(
      instrumentId: number,
      ftpCredentialType: "FILE" | "UPGRADE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FtpCredentialsDto> {
      const localVarFetchArgs = IrapInstrumentApiFetchParamCreator(
        configuration
      ).fetchFtpCredentials(instrumentId, ftpCredentialType, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * IrapInstrumentApi - factory interface
 * @export
 */
export const IrapInstrumentApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the FTP credentials of an IRAP instrument.
     * @param {number} instrumentId The instrument id.
     * @param {'FILE' | 'UPGRADE'} ftpCredentialType The FTP credential type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFtpCredentials(
      instrumentId: number,
      ftpCredentialType: "FILE" | "UPGRADE",
      options?: any
    ) {
      return IrapInstrumentApiFp(configuration).fetchFtpCredentials(
        instrumentId,
        ftpCredentialType,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * IrapInstrumentApi - object-oriented interface
 * @export
 * @class IrapInstrumentApi
 * @extends {BaseAPI}
 */
export class IrapInstrumentApi extends BaseAPI {
  /**
   *
   * @summary Get the FTP credentials of an IRAP instrument.
   * @param {number} instrumentId The instrument id.
   * @param {'FILE' | 'UPGRADE'} ftpCredentialType The FTP credential type.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IrapInstrumentApi
   */
  public fetchFtpCredentials(
    instrumentId: number,
    ftpCredentialType: "FILE" | "UPGRADE",
    options?: any
  ) {
    return IrapInstrumentApiFp(this.configuration).fetchFtpCredentials(
      instrumentId,
      ftpCredentialType,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * NextDotPlotsEndpointApi - fetch parameter creator
 * @export
 */
export const NextDotPlotsEndpointApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Set next FCS files for dot plots.
     * @param {NextFcsFilesDto} [body] Next FCS files to use for RBC and WBC dot plot generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFcsFiles(body?: NextFcsFilesDto, options: any = {}): FetchArgs {
      const localVarPath = `/nextDotPlots`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextFcsFilesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NextDotPlotsEndpointApi - functional programming interface
 * @export
 */
export const NextDotPlotsEndpointApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Set next FCS files for dot plots.
     * @param {NextFcsFilesDto} [body] Next FCS files to use for RBC and WBC dot plot generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFcsFiles(
      body?: NextFcsFilesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = NextDotPlotsEndpointApiFetchParamCreator(
        configuration
      ).setNextFcsFiles(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * NextDotPlotsEndpointApi - factory interface
 * @export
 */
export const NextDotPlotsEndpointApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Set next FCS files for dot plots.
     * @param {NextFcsFilesDto} [body] Next FCS files to use for RBC and WBC dot plot generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextFcsFiles(body?: NextFcsFilesDto, options?: any) {
      return NextDotPlotsEndpointApiFp(configuration).setNextFcsFiles(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * NextDotPlotsEndpointApi - object-oriented interface
 * @export
 * @class NextDotPlotsEndpointApi
 * @extends {BaseAPI}
 */
export class NextDotPlotsEndpointApi extends BaseAPI {
  /**
   *
   * @summary Set next FCS files for dot plots.
   * @param {NextFcsFilesDto} [body] Next FCS files to use for RBC and WBC dot plot generation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NextDotPlotsEndpointApi
   */
  public setNextFcsFiles(body?: NextFcsFilesDto, options?: any) {
    return NextDotPlotsEndpointApiFp(this.configuration).setNextFcsFiles(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * NextResultEndpointApi - fetch parameter creator
 * @export
 */
export const NextResultEndpointApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Set next result location.
     * @param {NextResultDto} [body] Next result location for instrument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextResult(body?: NextResultDto, options: any = {}): FetchArgs {
      const localVarPath = `/nextResult`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * NextResultEndpointApi - functional programming interface
 * @export
 */
export const NextResultEndpointApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Set next result location.
     * @param {NextResultDto} [body] Next result location for instrument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextResult(
      body?: NextResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = NextResultEndpointApiFetchParamCreator(
        configuration
      ).setNextResult(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * NextResultEndpointApi - factory interface
 * @export
 */
export const NextResultEndpointApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Set next result location.
     * @param {NextResultDto} [body] Next result location for instrument
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextResult(body?: NextResultDto, options?: any) {
      return NextResultEndpointApiFp(configuration).setNextResult(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * NextResultEndpointApi - object-oriented interface
 * @export
 * @class NextResultEndpointApi
 * @extends {BaseAPI}
 */
export class NextResultEndpointApi extends BaseAPI {
  /**
   *
   * @summary Set next result location.
   * @param {NextResultDto} [body] Next result location for instrument
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NextResultEndpointApi
   */
  public setNextResult(body?: NextResultDto, options?: any) {
    return NextResultEndpointApiFp(this.configuration).setNextResult(
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ProcyteDxApi - fetch parameter creator
 * @export
 */
export const ProcyteDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addAlert."
        );
      }
      // verify required parameter 'alertEnum' is not null or undefined
      if (alertEnum === null || alertEnum === undefined) {
        throw new RequiredError(
          "alertEnum",
          "Required parameter alertEnum was null or undefined when calling addAlert."
        );
      }
      const localVarPath = `/procyteDx/{instrumentId}/alert/add/{alertEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"alertEnum"}}`, encodeURIComponent(String(alertEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active alerts.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAlerts(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAlerts."
        );
      }
      const localVarPath = `/procyteDx/{instrumentId}/alert`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeAlert."
        );
      }
      // verify required parameter 'alertEnum' is not null or undefined
      if (alertEnum === null || alertEnum === undefined) {
        throw new RequiredError(
          "alertEnum",
          "Required parameter alertEnum was null or undefined when calling removeAlert."
        );
      }
      const localVarPath = `/procyteDx/{instrumentId}/alert/remove/{alertEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"alertEnum"}}`, encodeURIComponent(String(alertEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add background check alert.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} [success] Result of background check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendBackgroundCheckError(
      instrumentId: number,
      success?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling sendBackgroundCheckError."
        );
      }
      const localVarPath = `/procyteDx/{instrumentId}/backgroundCheck`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (success !== undefined) {
        localVarQueryParameter["success"] = success;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProcyteDxApi - functional programming interface
 * @export
 */
export const ProcyteDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProcyteDxApiFetchParamCreator(
        configuration
      ).addAlert(instrumentId, alertEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active alerts.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAlerts(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisAlertDto>> {
      const localVarFetchArgs = ProcyteDxApiFetchParamCreator(
        configuration
      ).fetchAlerts(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProcyteDxApiFetchParamCreator(
        configuration
      ).removeAlert(instrumentId, alertEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add background check alert.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} [success] Result of background check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendBackgroundCheckError(
      instrumentId: number,
      success?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ProcyteDxApiFetchParamCreator(
        configuration
      ).sendBackgroundCheckError(instrumentId, success, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ProcyteDxApi - factory interface
 * @export
 */
export const ProcyteDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Add an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options?: any
    ) {
      return ProcyteDxApiFp(configuration).addAlert(
        instrumentId,
        alertEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active alerts.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAlerts(instrumentId: number, options?: any) {
      return ProcyteDxApiFp(configuration).fetchAlerts(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Remove an alert.
     * @param {number} instrumentId The instrument id.
     * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeAlert(
      instrumentId: number,
      alertEnum:
        | "Pressure Lower Error"
        | "0.06MPa Error"
        | "-0.03Mpa Error"
        | "RH Temp High (DIFF)"
        | "RH Temp Low (DIFF)"
        | "RH Temp High (RET)"
        | "RH Temp Low (RET)"
        | "FCM RU Temp High"
        | "FCM RU Temp Low"
        | "Env Temp High"
        | "Env Temp Low"
        | "RH Therm Sens ERR (DIFF)"
        | "RH Therm Sens ERR (RET)"
        | "FCM RU Therm Sens ERR"
        | "FCM Sheath Sens ERR"
        | "Env Therm Sens ERR"
        | "Replace Container CELLPACK(EPK)"
        | "Replace Container SULFOLYSER(SLS)"
        | "Replace Container STROMATOLYSER-4DL(FFD)"
        | "Replace Container RET SEARCH(II) Diluent (RED)"
        | "Replace Container STROMATOLYSER-4DS(FFS)"
        | "Replace Container RET SEARCH(II) Stain (RES)"
        | "Chamber CELLPACK(EPK) Error"
        | "STROMATOLYSER-4DS(FFS) Aspiration Error"
        | "Replace Reagent Package"
        | "Waste Chamber 1 Error"
        | "Waste Chamber 2 Error"
        | "RBC/HGB Chamber Error"
        | "WBC Chamber Error"
        | "RET Chamber Error"
        | "WB Asp Motor Error"
        | "Sheath Motor Error"
        | "Aspiration Unit Up Down Motor Error"
        | "Aspiration Unit Front Back Motor Error"
        | "Rinse Cup Pinch Valve Error"
        | "Waste Chamber 1 Pinch Valve Error"
        | "Waste Chamber 2 Pinch Valve Error"
        | "Tube Holder Motor Error"
        | "Sample Not Asp Error"
        | "Short Sample"
        | "Blood Asp Sensor Error"
        | "Background Error"
        | "RBC Sampling Error"
        | "PLT Sampling Error"
        | "Diff Sampling Error"
        | "RET Sampling Error"
        | "RBC Clog Error"
        | "RBC Bubble Error"
        | "HGB ERROR"
        | "DIFF-CH Error"
        | "RBC-CH Error"
        | "PLT-CH Error"
        | "RET-CH Error"
        | "RET Error"
        | "Right side cover is open."
        | "Right side cover has opened."
        | "Tube Holder has opened."
        | "Laser Diode Aged"
        | "Laser Power Error"
        | "Close FCM Detect Cover"
        | "System Configuration Error"
        | "L-J Limit Error"
        | "Control Expired"
        | "Replace Piercer"
        | "Execute Monthly Rinse"
        | "Execute Monthly Rinse(Warning)"
        | "Exchange the Air pump"
        | "Expired Reagent [CELLPACK(EPK)]"
        | "Expired Reagent [SULFOLYSER(SLS)]"
        | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
        | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
        | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
        | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
        | "Sleep Mode"
        | "UnSupported Alert",
      options?: any
    ) {
      return ProcyteDxApiFp(configuration).removeAlert(
        instrumentId,
        alertEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add background check alert.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} [success] Result of background check.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendBackgroundCheckError(
      instrumentId: number,
      success?: boolean,
      options?: any
    ) {
      return ProcyteDxApiFp(configuration).sendBackgroundCheckError(
        instrumentId,
        success,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ProcyteDxApi - object-oriented interface
 * @export
 * @class ProcyteDxApi
 * @extends {BaseAPI}
 */
export class ProcyteDxApi extends BaseAPI {
  /**
   *
   * @summary Add an alert.
   * @param {number} instrumentId The instrument id.
   * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcyteDxApi
   */
  public addAlert(
    instrumentId: number,
    alertEnum:
      | "Pressure Lower Error"
      | "0.06MPa Error"
      | "-0.03Mpa Error"
      | "RH Temp High (DIFF)"
      | "RH Temp Low (DIFF)"
      | "RH Temp High (RET)"
      | "RH Temp Low (RET)"
      | "FCM RU Temp High"
      | "FCM RU Temp Low"
      | "Env Temp High"
      | "Env Temp Low"
      | "RH Therm Sens ERR (DIFF)"
      | "RH Therm Sens ERR (RET)"
      | "FCM RU Therm Sens ERR"
      | "FCM Sheath Sens ERR"
      | "Env Therm Sens ERR"
      | "Replace Container CELLPACK(EPK)"
      | "Replace Container SULFOLYSER(SLS)"
      | "Replace Container STROMATOLYSER-4DL(FFD)"
      | "Replace Container RET SEARCH(II) Diluent (RED)"
      | "Replace Container STROMATOLYSER-4DS(FFS)"
      | "Replace Container RET SEARCH(II) Stain (RES)"
      | "Chamber CELLPACK(EPK) Error"
      | "STROMATOLYSER-4DS(FFS) Aspiration Error"
      | "Replace Reagent Package"
      | "Waste Chamber 1 Error"
      | "Waste Chamber 2 Error"
      | "RBC/HGB Chamber Error"
      | "WBC Chamber Error"
      | "RET Chamber Error"
      | "WB Asp Motor Error"
      | "Sheath Motor Error"
      | "Aspiration Unit Up Down Motor Error"
      | "Aspiration Unit Front Back Motor Error"
      | "Rinse Cup Pinch Valve Error"
      | "Waste Chamber 1 Pinch Valve Error"
      | "Waste Chamber 2 Pinch Valve Error"
      | "Tube Holder Motor Error"
      | "Sample Not Asp Error"
      | "Short Sample"
      | "Blood Asp Sensor Error"
      | "Background Error"
      | "RBC Sampling Error"
      | "PLT Sampling Error"
      | "Diff Sampling Error"
      | "RET Sampling Error"
      | "RBC Clog Error"
      | "RBC Bubble Error"
      | "HGB ERROR"
      | "DIFF-CH Error"
      | "RBC-CH Error"
      | "PLT-CH Error"
      | "RET-CH Error"
      | "RET Error"
      | "Right side cover is open."
      | "Right side cover has opened."
      | "Tube Holder has opened."
      | "Laser Diode Aged"
      | "Laser Power Error"
      | "Close FCM Detect Cover"
      | "System Configuration Error"
      | "L-J Limit Error"
      | "Control Expired"
      | "Replace Piercer"
      | "Execute Monthly Rinse"
      | "Execute Monthly Rinse(Warning)"
      | "Exchange the Air pump"
      | "Expired Reagent [CELLPACK(EPK)]"
      | "Expired Reagent [SULFOLYSER(SLS)]"
      | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
      | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
      | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
      | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
      | "Sleep Mode"
      | "UnSupported Alert",
    options?: any
  ) {
    return ProcyteDxApiFp(this.configuration).addAlert(
      instrumentId,
      alertEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active alerts.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcyteDxApi
   */
  public fetchAlerts(instrumentId: number, options?: any) {
    return ProcyteDxApiFp(this.configuration).fetchAlerts(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove an alert.
   * @param {number} instrumentId The instrument id.
   * @param {'Pressure Lower Error' | '0.06MPa Error' | '-0.03Mpa Error' | 'RH Temp High (DIFF)' | 'RH Temp Low (DIFF)' | 'RH Temp High (RET)' | 'RH Temp Low (RET)' | 'FCM RU Temp High' | 'FCM RU Temp Low' | 'Env Temp High' | 'Env Temp Low' | 'RH Therm Sens ERR (DIFF)' | 'RH Therm Sens ERR (RET)' | 'FCM RU Therm Sens ERR' | 'FCM Sheath Sens ERR' | 'Env Therm Sens ERR' | 'Replace Container CELLPACK(EPK)' | 'Replace Container SULFOLYSER(SLS)' | 'Replace Container STROMATOLYSER-4DL(FFD)' | 'Replace Container RET SEARCH(II) Diluent (RED)' | 'Replace Container STROMATOLYSER-4DS(FFS)' | 'Replace Container RET SEARCH(II) Stain (RES)' | 'Chamber CELLPACK(EPK) Error' | 'STROMATOLYSER-4DS(FFS) Aspiration Error' | 'Replace Reagent Package' | 'Waste Chamber 1 Error' | 'Waste Chamber 2 Error' | 'RBC/HGB Chamber Error' | 'WBC Chamber Error' | 'RET Chamber Error' | 'WB Asp Motor Error' | 'Sheath Motor Error' | 'Aspiration Unit Up Down Motor Error' | 'Aspiration Unit Front Back Motor Error' | 'Rinse Cup Pinch Valve Error' | 'Waste Chamber 1 Pinch Valve Error' | 'Waste Chamber 2 Pinch Valve Error' | 'Tube Holder Motor Error' | 'Sample Not Asp Error' | 'Short Sample' | 'Blood Asp Sensor Error' | 'Background Error' | 'RBC Sampling Error' | 'PLT Sampling Error' | 'Diff Sampling Error' | 'RET Sampling Error' | 'RBC Clog Error' | 'RBC Bubble Error' | 'HGB ERROR' | 'DIFF-CH Error' | 'RBC-CH Error' | 'PLT-CH Error' | 'RET-CH Error' | 'RET Error' | 'Right side cover is open.' | 'Right side cover has opened.' | 'Tube Holder has opened.' | 'Laser Diode Aged' | 'Laser Power Error' | 'Close FCM Detect Cover' | 'System Configuration Error' | 'L-J Limit Error' | 'Control Expired' | 'Replace Piercer' | 'Execute Monthly Rinse' | 'Execute Monthly Rinse(Warning)' | 'Exchange the Air pump' | 'Expired Reagent [CELLPACK(EPK)]' | 'Expired Reagent [SULFOLYSER(SLS)]' | 'Expired Reagent [STROMATOLYSER-4DL(FFD)]' | 'Expired Reagent [RET SEARCH(II) Diluent (RED)]' | 'Expired Reagent [STROMATOLYSER-4DS(FFS)]' | 'Expired Reagent [RET SEARCH(II) Stain (RES)]' | 'Sleep Mode' | 'UnSupported Alert'} alertEnum The alert to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcyteDxApi
   */
  public removeAlert(
    instrumentId: number,
    alertEnum:
      | "Pressure Lower Error"
      | "0.06MPa Error"
      | "-0.03Mpa Error"
      | "RH Temp High (DIFF)"
      | "RH Temp Low (DIFF)"
      | "RH Temp High (RET)"
      | "RH Temp Low (RET)"
      | "FCM RU Temp High"
      | "FCM RU Temp Low"
      | "Env Temp High"
      | "Env Temp Low"
      | "RH Therm Sens ERR (DIFF)"
      | "RH Therm Sens ERR (RET)"
      | "FCM RU Therm Sens ERR"
      | "FCM Sheath Sens ERR"
      | "Env Therm Sens ERR"
      | "Replace Container CELLPACK(EPK)"
      | "Replace Container SULFOLYSER(SLS)"
      | "Replace Container STROMATOLYSER-4DL(FFD)"
      | "Replace Container RET SEARCH(II) Diluent (RED)"
      | "Replace Container STROMATOLYSER-4DS(FFS)"
      | "Replace Container RET SEARCH(II) Stain (RES)"
      | "Chamber CELLPACK(EPK) Error"
      | "STROMATOLYSER-4DS(FFS) Aspiration Error"
      | "Replace Reagent Package"
      | "Waste Chamber 1 Error"
      | "Waste Chamber 2 Error"
      | "RBC/HGB Chamber Error"
      | "WBC Chamber Error"
      | "RET Chamber Error"
      | "WB Asp Motor Error"
      | "Sheath Motor Error"
      | "Aspiration Unit Up Down Motor Error"
      | "Aspiration Unit Front Back Motor Error"
      | "Rinse Cup Pinch Valve Error"
      | "Waste Chamber 1 Pinch Valve Error"
      | "Waste Chamber 2 Pinch Valve Error"
      | "Tube Holder Motor Error"
      | "Sample Not Asp Error"
      | "Short Sample"
      | "Blood Asp Sensor Error"
      | "Background Error"
      | "RBC Sampling Error"
      | "PLT Sampling Error"
      | "Diff Sampling Error"
      | "RET Sampling Error"
      | "RBC Clog Error"
      | "RBC Bubble Error"
      | "HGB ERROR"
      | "DIFF-CH Error"
      | "RBC-CH Error"
      | "PLT-CH Error"
      | "RET-CH Error"
      | "RET Error"
      | "Right side cover is open."
      | "Right side cover has opened."
      | "Tube Holder has opened."
      | "Laser Diode Aged"
      | "Laser Power Error"
      | "Close FCM Detect Cover"
      | "System Configuration Error"
      | "L-J Limit Error"
      | "Control Expired"
      | "Replace Piercer"
      | "Execute Monthly Rinse"
      | "Execute Monthly Rinse(Warning)"
      | "Exchange the Air pump"
      | "Expired Reagent [CELLPACK(EPK)]"
      | "Expired Reagent [SULFOLYSER(SLS)]"
      | "Expired Reagent [STROMATOLYSER-4DL(FFD)]"
      | "Expired Reagent [RET SEARCH(II) Diluent (RED)]"
      | "Expired Reagent [STROMATOLYSER-4DS(FFS)]"
      | "Expired Reagent [RET SEARCH(II) Stain (RES)]"
      | "Sleep Mode"
      | "UnSupported Alert",
    options?: any
  ) {
    return ProcyteDxApiFp(this.configuration).removeAlert(
      instrumentId,
      alertEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add background check alert.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} [success] Result of background check.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProcyteDxApi
   */
  public sendBackgroundCheckError(
    instrumentId: number,
    success?: boolean,
    options?: any
  ) {
    return ProcyteDxApiFp(this.configuration).sendBackgroundCheckError(
      instrumentId,
      success,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SedivueDxApi - fetch parameter creator
 * @export
 */
export const SedivueDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade2(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling abortUpgrade2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/upgrade/abort`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault2."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/fault/add/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {SediVueDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade2(
      instrumentId: number,
      upgradeDetails?: SediVueDxUpgradeInputDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addUpgrade2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/upgrade/add`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SediVueDxUpgradeInputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(upgradeDetails || {})
        : upgradeDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoloadCuvette(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAutoloadCuvette."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/autoloadCuvette`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAvailable(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchCuvetteStatusAvailable."
        );
      }
      const localVarPath =
        `/sediVueDx/{instrumentId}/cuvetteStatusAvailable`.replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults2(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade2(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchUpgrade2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/upgrade`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Load a cuvette.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadCuvette(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling loadCuvette."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/loadCuvette`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault2."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault2."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/fault/remove/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'DropCuvette' | 'GeneralClean' | 'Initialize' | 'Restart' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextSediVueDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult2(
      instrumentId: number,
      maintenanceProcedure:
        | "DropCuvette"
        | "GeneralClean"
        | "Initialize"
        | "Restart"
        | "Shutdown",
      body?: NextSediVueDxMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult2."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult2."
        );
      }
      const localVarPath =
        `/sediVueDx/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextSediVueDxMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoloadCuvette(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateAutoloadCuvette."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateAutoloadCuvette."
        );
      }
      const localVarPath = `/sediVueDx/{instrumentId}/autoloadCuvette/{status}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCuvetteStatusAvailable(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateCuvetteStatusAvailable."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateCuvetteStatusAvailable."
        );
      }
      const localVarPath =
        `/sediVueDx/{instrumentId}/cuvetteStatusAvailable/{status}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SedivueDxApi - functional programming interface
 * @export
 */
export const SedivueDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade2(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).abortUpgrade2(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).addFault2(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {SediVueDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade2(
      instrumentId: number,
      upgradeDetails?: SediVueDxUpgradeInputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).addUpgrade2(instrumentId, upgradeDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoloadCuvette(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).fetchAutoloadCuvette(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAvailable(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).fetchCuvetteStatusAvailable(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults2(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).fetchFaults2(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade2(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<SediVueDxUpgradeDto> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).fetchUpgrade2(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Load a cuvette.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadCuvette(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).loadCuvette(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).removeFault2(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'DropCuvette' | 'GeneralClean' | 'Initialize' | 'Restart' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextSediVueDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult2(
      instrumentId: number,
      maintenanceProcedure:
        | "DropCuvette"
        | "GeneralClean"
        | "Initialize"
        | "Restart"
        | "Shutdown",
      body?: NextSediVueDxMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult2(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoloadCuvette(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).updateAutoloadCuvette(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCuvetteStatusAvailable(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SedivueDxApiFetchParamCreator(
        configuration
      ).updateCuvetteStatusAvailable(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SedivueDxApi - factory interface
 * @export
 */
export const SedivueDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Abort a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abortUpgrade2(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).abortUpgrade2(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return SedivueDxApiFp(configuration).addFault2(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {SediVueDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade2(
      instrumentId: number,
      upgradeDetails?: SediVueDxUpgradeInputDto,
      options?: any
    ) {
      return SedivueDxApiFp(configuration).addUpgrade2(
        instrumentId,
        upgradeDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoloadCuvette(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).fetchAutoloadCuvette(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchCuvetteStatusAvailable(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).fetchCuvetteStatusAvailable(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults2(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).fetchFaults2(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the details of the active upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchUpgrade2(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).fetchUpgrade2(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Load a cuvette.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadCuvette(instrumentId: number, options?: any) {
      return SedivueDxApiFp(configuration).loadCuvette(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault2(
      instrumentId: number,
      faultEnum:
        | "CLEANING_RECOMMENDED"
        | "CUVETTE_COUNT_LOW"
        | "QUALITY_CONTROL_RECOMMENDED"
        | "SYSTEM_REBOOT_RECOMMENDED"
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "ARM_MOVEMENT"
        | "CAMERA_ERROR"
        | "CENTRIFUGE_ROTATION_ERROR"
        | "CUVETTE_COUNT_ZERO"
        | "CUVETTE_SENSOR_EMPTY"
        | "DOOR_OPEN"
        | "FEEDER_MOVEMENT"
        | "FOCUS_DLL_NOT_FOUND"
        | "FOCUS_FUNCTION_MISSING"
        | "FOCUS_HOME_POSITION_ERROR"
        | "GENERAL_COMMUNICATION_ERROR"
        | "HOUSE_OPEN"
        | "INSTRUMENT_PORT_OPEN_ERROR"
        | "MEMORY_ALLOCATION_ERROR"
        | "MICROSCOPE_CTS_TIMEOUT"
        | "MICROSCOPE_THREAD_CREATION_ERROR"
        | "PLATE_MISSING"
        | "PORT_THREAD_NOT_STARTED"
        | "PROTOCOL_CLASS_CREATION_ERROR"
        | "PROTOCOL_USAGE_UNDEFINED"
        | "SERIAL_PORT_NOT_FOUND"
        | "SERIAL_PORT_UNAVAILABLE"
        | "TOO_MANY_SERIAL_PORTS_DEFINED"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "MOTY_MOVEMENT"
        | "CENTRIFUGE_ARM_MISSING"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return SedivueDxApiFp(configuration).removeFault2(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'DropCuvette' | 'GeneralClean' | 'Initialize' | 'Restart' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
     * @param {NextSediVueDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult2(
      instrumentId: number,
      maintenanceProcedure:
        | "DropCuvette"
        | "GeneralClean"
        | "Initialize"
        | "Restart"
        | "Shutdown",
      body?: NextSediVueDxMaintenanceResultDto,
      options?: any
    ) {
      return SedivueDxApiFp(configuration).setNextMaintenanceResult2(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the autoload cuvette status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoloadCuvette(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return SedivueDxApiFp(configuration).updateAutoloadCuvette(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the cuvette status available status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to be set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCuvetteStatusAvailable(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return SedivueDxApiFp(configuration).updateCuvetteStatusAvailable(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SedivueDxApi - object-oriented interface
 * @export
 * @class SedivueDxApi
 * @extends {BaseAPI}
 */
export class SedivueDxApi extends BaseAPI {
  /**
   *
   * @summary Abort a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public abortUpgrade2(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).abortUpgrade2(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public addFault2(
    instrumentId: number,
    faultEnum:
      | "CLEANING_RECOMMENDED"
      | "CUVETTE_COUNT_LOW"
      | "QUALITY_CONTROL_RECOMMENDED"
      | "SYSTEM_REBOOT_RECOMMENDED"
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED"
      | "ARM_MOVEMENT"
      | "CAMERA_ERROR"
      | "CENTRIFUGE_ROTATION_ERROR"
      | "CUVETTE_COUNT_ZERO"
      | "CUVETTE_SENSOR_EMPTY"
      | "DOOR_OPEN"
      | "FEEDER_MOVEMENT"
      | "FOCUS_DLL_NOT_FOUND"
      | "FOCUS_FUNCTION_MISSING"
      | "FOCUS_HOME_POSITION_ERROR"
      | "GENERAL_COMMUNICATION_ERROR"
      | "HOUSE_OPEN"
      | "INSTRUMENT_PORT_OPEN_ERROR"
      | "MEMORY_ALLOCATION_ERROR"
      | "MICROSCOPE_CTS_TIMEOUT"
      | "MICROSCOPE_THREAD_CREATION_ERROR"
      | "PLATE_MISSING"
      | "PORT_THREAD_NOT_STARTED"
      | "PROTOCOL_CLASS_CREATION_ERROR"
      | "PROTOCOL_USAGE_UNDEFINED"
      | "SERIAL_PORT_NOT_FOUND"
      | "SERIAL_PORT_UNAVAILABLE"
      | "TOO_MANY_SERIAL_PORTS_DEFINED"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "MOTY_MOVEMENT"
      | "CENTRIFUGE_ARM_MISSING"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).addFault2(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {SediVueDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public addUpgrade2(
    instrumentId: number,
    upgradeDetails?: SediVueDxUpgradeInputDto,
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).addUpgrade2(
      instrumentId,
      upgradeDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the autoload cuvette status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public fetchAutoloadCuvette(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).fetchAutoloadCuvette(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the cuvette status available status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public fetchCuvetteStatusAvailable(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).fetchCuvetteStatusAvailable(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public fetchFaults2(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).fetchFaults2(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the details of the active upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public fetchUpgrade2(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).fetchUpgrade2(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Load a cuvette.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public loadCuvette(instrumentId: number, options?: any) {
    return SedivueDxApiFp(this.configuration).loadCuvette(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'CLEANING_RECOMMENDED' | 'CUVETTE_COUNT_LOW' | 'QUALITY_CONTROL_RECOMMENDED' | 'SYSTEM_REBOOT_RECOMMENDED' | 'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'ARM_MOVEMENT' | 'CAMERA_ERROR' | 'CENTRIFUGE_ROTATION_ERROR' | 'CUVETTE_COUNT_ZERO' | 'CUVETTE_SENSOR_EMPTY' | 'DOOR_OPEN' | 'FEEDER_MOVEMENT' | 'FOCUS_DLL_NOT_FOUND' | 'FOCUS_FUNCTION_MISSING' | 'FOCUS_HOME_POSITION_ERROR' | 'GENERAL_COMMUNICATION_ERROR' | 'HOUSE_OPEN' | 'INSTRUMENT_PORT_OPEN_ERROR' | 'MEMORY_ALLOCATION_ERROR' | 'MICROSCOPE_CTS_TIMEOUT' | 'MICROSCOPE_THREAD_CREATION_ERROR' | 'PLATE_MISSING' | 'PORT_THREAD_NOT_STARTED' | 'PROTOCOL_CLASS_CREATION_ERROR' | 'PROTOCOL_USAGE_UNDEFINED' | 'SERIAL_PORT_NOT_FOUND' | 'SERIAL_PORT_UNAVAILABLE' | 'TOO_MANY_SERIAL_PORTS_DEFINED' | 'UNSPECIFIED_ALERT_SYSTEM' | 'MOTY_MOVEMENT' | 'CENTRIFUGE_ARM_MISSING' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public removeFault2(
    instrumentId: number,
    faultEnum:
      | "CLEANING_RECOMMENDED"
      | "CUVETTE_COUNT_LOW"
      | "QUALITY_CONTROL_RECOMMENDED"
      | "SYSTEM_REBOOT_RECOMMENDED"
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED"
      | "ARM_MOVEMENT"
      | "CAMERA_ERROR"
      | "CENTRIFUGE_ROTATION_ERROR"
      | "CUVETTE_COUNT_ZERO"
      | "CUVETTE_SENSOR_EMPTY"
      | "DOOR_OPEN"
      | "FEEDER_MOVEMENT"
      | "FOCUS_DLL_NOT_FOUND"
      | "FOCUS_FUNCTION_MISSING"
      | "FOCUS_HOME_POSITION_ERROR"
      | "GENERAL_COMMUNICATION_ERROR"
      | "HOUSE_OPEN"
      | "INSTRUMENT_PORT_OPEN_ERROR"
      | "MEMORY_ALLOCATION_ERROR"
      | "MICROSCOPE_CTS_TIMEOUT"
      | "MICROSCOPE_THREAD_CREATION_ERROR"
      | "PLATE_MISSING"
      | "PORT_THREAD_NOT_STARTED"
      | "PROTOCOL_CLASS_CREATION_ERROR"
      | "PROTOCOL_USAGE_UNDEFINED"
      | "SERIAL_PORT_NOT_FOUND"
      | "SERIAL_PORT_UNAVAILABLE"
      | "TOO_MANY_SERIAL_PORTS_DEFINED"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "MOTY_MOVEMENT"
      | "CENTRIFUGE_ARM_MISSING"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).removeFault2(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'DropCuvette' | 'GeneralClean' | 'Initialize' | 'Restart' | 'Shutdown'} maintenanceProcedure The maintenance procedure.
   * @param {NextSediVueDxMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public setNextMaintenanceResult2(
    instrumentId: number,
    maintenanceProcedure:
      | "DropCuvette"
      | "GeneralClean"
      | "Initialize"
      | "Restart"
      | "Shutdown",
    body?: NextSediVueDxMaintenanceResultDto,
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).setNextMaintenanceResult2(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the autoload cuvette status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to be set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public updateAutoloadCuvette(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).updateAutoloadCuvette(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the cuvette status available status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to be set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SedivueDxApi
   */
  public updateCuvetteStatusAvailable(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return SedivueDxApiFp(this.configuration).updateCuvetteStatusAvailable(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SnapProApi - fetch parameter creator
 * @export
 */
export const SnapProApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoAddPimsRequest(
      instrumentId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchAutoAddPimsRequest."
        );
      }
      const localVarPath = `/snapPro/{instrumentId}/autoAddPimsRequest`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoAddPimsRequest(
      instrumentId: number,
      status: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling updateAutoAddPimsRequest."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling updateAutoAddPimsRequest."
        );
      }
      const localVarPath = `/snapPro/{instrumentId}/autoAddPimsRequest/{status}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"status"}}`, encodeURIComponent(String(status)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SnapProApi - functional programming interface
 * @export
 */
export const SnapProApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoAddPimsRequest(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
      const localVarFetchArgs = SnapProApiFetchParamCreator(
        configuration
      ).fetchAutoAddPimsRequest(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Update the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoAddPimsRequest(
      instrumentId: number,
      status: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = SnapProApiFetchParamCreator(
        configuration
      ).updateAutoAddPimsRequest(instrumentId, status, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SnapProApi - factory interface
 * @export
 */
export const SnapProApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAutoAddPimsRequest(instrumentId: number, options?: any) {
      return SnapProApiFp(configuration).fetchAutoAddPimsRequest(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Update the automatically add a PIMS request status.
     * @param {number} instrumentId The instrument id.
     * @param {boolean} status The status to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoAddPimsRequest(
      instrumentId: number,
      status: boolean,
      options?: any
    ) {
      return SnapProApiFp(configuration).updateAutoAddPimsRequest(
        instrumentId,
        status,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SnapProApi - object-oriented interface
 * @export
 * @class SnapProApi
 * @extends {BaseAPI}
 */
export class SnapProApi extends BaseAPI {
  /**
   *
   * @summary Get the automatically add a PIMS request status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SnapProApi
   */
  public fetchAutoAddPimsRequest(instrumentId: number, options?: any) {
    return SnapProApiFp(this.configuration).fetchAutoAddPimsRequest(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Update the automatically add a PIMS request status.
   * @param {number} instrumentId The instrument id.
   * @param {boolean} status The status to set.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SnapProApi
   */
  public updateAutoAddPimsRequest(
    instrumentId: number,
    status: boolean,
    options?: any
  ) {
    return SnapProApiFp(this.configuration).updateAutoAddPimsRequest(
      instrumentId,
      status,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TenseiApi - fetch parameter creator
 * @export
 */
export const TenseiApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault3."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault3."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults3(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults3."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentStatus1."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties1(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchProperties1."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/properties`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton2(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling pressStartButton2."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/startButton`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault3."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault3."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {TenseiPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties1(
      instrumentId: number,
      body?: TenseiPropertiesDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling saveProperties1."
        );
      }
      const localVarPath = `/tensei/{instrumentId}/properties`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"TenseiPropertiesDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'AutoRinse' | 'ClearPinchValve' | 'DrainRbcIsolationChamber' | 'DrainReactionChamber' | 'DrainWasteChamber' | 'RemoveClog' | 'ResetAirPump' | 'ResetAspirationMotor' | 'ResetSheathMotor' | 'ResetTubeMotor' | 'ResetWBMotor' | 'ReplenishReagent' | 'ReplenishStain' | 'MonthlyRinse' | 'FlowCellRinse' | 'WasteChamberRinse'} maintenanceProcedure The maintenance procedure.
     * @param {NextTenseiMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult3(
      instrumentId: number,
      maintenanceProcedure:
        | "AutoRinse"
        | "ClearPinchValve"
        | "DrainRbcIsolationChamber"
        | "DrainReactionChamber"
        | "DrainWasteChamber"
        | "RemoveClog"
        | "ResetAirPump"
        | "ResetAspirationMotor"
        | "ResetSheathMotor"
        | "ResetTubeMotor"
        | "ResetWBMotor"
        | "ReplenishReagent"
        | "ReplenishStain"
        | "MonthlyRinse"
        | "FlowCellRinse"
        | "WasteChamberRinse",
      body?: NextTenseiMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult3."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult3."
        );
      }
      const localVarPath =
        `/tensei/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextTenseiMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TenseiApi - functional programming interface
 * @export
 */
export const TenseiApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).addFault3(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults3(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).fetchFaults3(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus1(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<IrisInstrumentStatusDto> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).fetchInstrumentStatus1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties1(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TenseiPropertiesDto> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).fetchProperties1(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton2(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).pressStartButton2(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).removeFault3(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {TenseiPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties1(
      instrumentId: number,
      body?: TenseiPropertiesDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).saveProperties1(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'AutoRinse' | 'ClearPinchValve' | 'DrainRbcIsolationChamber' | 'DrainReactionChamber' | 'DrainWasteChamber' | 'RemoveClog' | 'ResetAirPump' | 'ResetAspirationMotor' | 'ResetSheathMotor' | 'ResetTubeMotor' | 'ResetWBMotor' | 'ReplenishReagent' | 'ReplenishStain' | 'MonthlyRinse' | 'FlowCellRinse' | 'WasteChamberRinse'} maintenanceProcedure The maintenance procedure.
     * @param {NextTenseiMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult3(
      instrumentId: number,
      maintenanceProcedure:
        | "AutoRinse"
        | "ClearPinchValve"
        | "DrainRbcIsolationChamber"
        | "DrainReactionChamber"
        | "DrainWasteChamber"
        | "RemoveClog"
        | "ResetAirPump"
        | "ResetAspirationMotor"
        | "ResetSheathMotor"
        | "ResetTubeMotor"
        | "ResetWBMotor"
        | "ReplenishReagent"
        | "ReplenishStain"
        | "MonthlyRinse"
        | "FlowCellRinse"
        | "WasteChamberRinse",
      body?: NextTenseiMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TenseiApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult3(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TenseiApi - factory interface
 * @export
 */
export const TenseiApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return TenseiApiFp(configuration).addFault3(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults3(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).fetchFaults3(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus1(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).fetchInstrumentStatus1(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchProperties1(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).fetchProperties1(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Presses the 'Start' button on the instrument.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pressStartButton2(instrumentId: number, options?: any) {
      return TenseiApiFp(configuration).pressStartButton2(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault3(
      instrumentId: number,
      faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return TenseiApiFp(configuration).removeFault3(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Save the instrument properties.
     * @param {number} instrumentId The instrument id.
     * @param {TenseiPropertiesDto} [body] The instrument properties to save.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveProperties1(
      instrumentId: number,
      body?: TenseiPropertiesDto,
      options?: any
    ) {
      return TenseiApiFp(configuration).saveProperties1(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'AutoRinse' | 'ClearPinchValve' | 'DrainRbcIsolationChamber' | 'DrainReactionChamber' | 'DrainWasteChamber' | 'RemoveClog' | 'ResetAirPump' | 'ResetAspirationMotor' | 'ResetSheathMotor' | 'ResetTubeMotor' | 'ResetWBMotor' | 'ReplenishReagent' | 'ReplenishStain' | 'MonthlyRinse' | 'FlowCellRinse' | 'WasteChamberRinse'} maintenanceProcedure The maintenance procedure.
     * @param {NextTenseiMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult3(
      instrumentId: number,
      maintenanceProcedure:
        | "AutoRinse"
        | "ClearPinchValve"
        | "DrainRbcIsolationChamber"
        | "DrainReactionChamber"
        | "DrainWasteChamber"
        | "RemoveClog"
        | "ResetAirPump"
        | "ResetAspirationMotor"
        | "ResetSheathMotor"
        | "ResetTubeMotor"
        | "ResetWBMotor"
        | "ReplenishReagent"
        | "ReplenishStain"
        | "MonthlyRinse"
        | "FlowCellRinse"
        | "WasteChamberRinse",
      body?: NextTenseiMaintenanceResultDto,
      options?: any
    ) {
      return TenseiApiFp(configuration).setNextMaintenanceResult3(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * TenseiApi - object-oriented interface
 * @export
 * @class TenseiApi
 * @extends {BaseAPI}
 */
export class TenseiApi extends BaseAPI {
  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public addFault3(
    instrumentId: number,
    faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return TenseiApiFp(this.configuration).addFault3(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public fetchFaults3(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).fetchFaults3(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the instrument status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public fetchInstrumentStatus1(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).fetchInstrumentStatus1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the instrument properties.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public fetchProperties1(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).fetchProperties1(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Presses the 'Start' button on the instrument.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public pressStartButton2(instrumentId: number, options?: any) {
    return TenseiApiFp(this.configuration).pressStartButton2(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public removeFault3(
    instrumentId: number,
    faultEnum: "UNSPECIFIED_ALERT_SYSTEM" | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return TenseiApiFp(this.configuration).removeFault3(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Save the instrument properties.
   * @param {number} instrumentId The instrument id.
   * @param {TenseiPropertiesDto} [body] The instrument properties to save.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public saveProperties1(
    instrumentId: number,
    body?: TenseiPropertiesDto,
    options?: any
  ) {
    return TenseiApiFp(this.configuration).saveProperties1(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'AutoRinse' | 'ClearPinchValve' | 'DrainRbcIsolationChamber' | 'DrainReactionChamber' | 'DrainWasteChamber' | 'RemoveClog' | 'ResetAirPump' | 'ResetAspirationMotor' | 'ResetSheathMotor' | 'ResetTubeMotor' | 'ResetWBMotor' | 'ReplenishReagent' | 'ReplenishStain' | 'MonthlyRinse' | 'FlowCellRinse' | 'WasteChamberRinse'} maintenanceProcedure The maintenance procedure.
   * @param {NextTenseiMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenseiApi
   */
  public setNextMaintenanceResult3(
    instrumentId: number,
    maintenanceProcedure:
      | "AutoRinse"
      | "ClearPinchValve"
      | "DrainRbcIsolationChamber"
      | "DrainReactionChamber"
      | "DrainWasteChamber"
      | "RemoveClog"
      | "ResetAirPump"
      | "ResetAspirationMotor"
      | "ResetSheathMotor"
      | "ResetTubeMotor"
      | "ResetWBMotor"
      | "ReplenishReagent"
      | "ReplenishStain"
      | "MonthlyRinse"
      | "FlowCellRinse"
      | "WasteChamberRinse",
    body?: NextTenseiMaintenanceResultDto,
    options?: any
  ) {
    return TenseiApiFp(this.configuration).setNextMaintenanceResult3(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * TheiaApi - fetch parameter creator
 * @export
 */
export const TheiaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault4."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault4."
        );
      }
      const localVarPath = `/theia/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults4(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults4."
        );
      }
      const localVarPath = `/theia/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus2(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentStatus2."
        );
      }
      const localVarPath = `/theia/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault4."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault4."
        );
      }
      const localVarPath = `/theia/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult1(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling sendMaintenanceResult1."
        );
      }
      const localVarPath = `/theia/{instrumentId}/maintenance`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation1(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setBarcodeValidation1."
        );
      }
      // verify required parameter 'barcodeType' is not null or undefined
      if (barcodeType === null || barcodeType === undefined) {
        throw new RequiredError(
          "barcodeType",
          "Required parameter barcodeType was null or undefined when calling setBarcodeValidation1."
        );
      }
      const localVarPath = `/theia/{instrumentId}/barcode/{barcodeType}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"barcodeType"}}`, encodeURIComponent(String(barcodeType)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextBarcodeValidationResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextTheiaMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult4(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextTheiaMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult4."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult4."
        );
      }
      const localVarPath =
        `/theia/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextTheiaMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TheiaApi - functional programming interface
 * @export
 */
export const TheiaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).addFault4(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults4(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).fetchFaults4(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus2(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<IrisInstrumentStatusDto> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).fetchInstrumentStatus2(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).removeFault4(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult1(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).sendMaintenanceResult1(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation1(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).setBarcodeValidation1(instrumentId, barcodeType, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextTheiaMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult4(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextTheiaMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = TheiaApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult4(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TheiaApi - factory interface
 * @export
 */
export const TheiaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return TheiaApiFp(configuration).addFault4(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults4(instrumentId: number, options?: any) {
      return TheiaApiFp(configuration).fetchFaults4(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus2(instrumentId: number, options?: any) {
      return TheiaApiFp(configuration).fetchInstrumentStatus2(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault4(
      instrumentId: number,
      faultEnum:
        | "INST_TEMP_LOW"
        | "INST_TEMP_HIGH"
        | "BARCODE_READ_FAILURE"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "INVALID_CONSUMABLES"
        | "EXPIRED_CONSUMABLES"
        | "INCORRECT_TEST_TYPE"
        | "SAMPLE_OVER_TEMP"
        | "SAMPLE_UNDER_TEMP"
        | "IMPROPER_SAMPLE_PREPARATION"
        | "SAMPLE_CELLULARITY_HIGH"
        | "MOTION_ERROR_CARTRIDGE"
        | "MOTION_ERROR_MICROSCOPE"
        | "UNKNOWN_ERROR"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
      options?: any
    ) {
      return TheiaApiFp(configuration).removeFault4(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult1(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ) {
      return TheiaApiFp(configuration).sendMaintenanceResult1(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next barcode validation result.
     * @param {number} instrumentId The instrument id.
     * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
     * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBarcodeValidation1(
      instrumentId: number,
      barcodeType:
        | "Cuvettes"
        | "Reagent"
        | "Sheath"
        | "SmartQC"
        | "Blood"
        | "EarSwab"
        | "FNA",
      body?: NextBarcodeValidationResultDto,
      options?: any
    ) {
      return TheiaApiFp(configuration).setBarcodeValidation1(
        instrumentId,
        barcodeType,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextTheiaMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult4(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextTheiaMaintenanceResultDto,
      options?: any
    ) {
      return TheiaApiFp(configuration).setNextMaintenanceResult4(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * TheiaApi - object-oriented interface
 * @export
 * @class TheiaApi
 * @extends {BaseAPI}
 */
export class TheiaApi extends BaseAPI {
  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public addFault4(
    instrumentId: number,
    faultEnum:
      | "INST_TEMP_LOW"
      | "INST_TEMP_HIGH"
      | "BARCODE_READ_FAILURE"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "INVALID_CONSUMABLES"
      | "EXPIRED_CONSUMABLES"
      | "INCORRECT_TEST_TYPE"
      | "SAMPLE_OVER_TEMP"
      | "SAMPLE_UNDER_TEMP"
      | "IMPROPER_SAMPLE_PREPARATION"
      | "SAMPLE_CELLULARITY_HIGH"
      | "MOTION_ERROR_CARTRIDGE"
      | "MOTION_ERROR_MICROSCOPE"
      | "UNKNOWN_ERROR"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return TheiaApiFp(this.configuration).addFault4(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public fetchFaults4(instrumentId: number, options?: any) {
    return TheiaApiFp(this.configuration).fetchFaults4(instrumentId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @summary Get the instrument status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public fetchInstrumentStatus2(instrumentId: number, options?: any) {
    return TheiaApiFp(this.configuration).fetchInstrumentStatus2(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'INST_TEMP_LOW' | 'INST_TEMP_HIGH' | 'BARCODE_READ_FAILURE' | 'UNSPECIFIED_ALERT_SYSTEM' | 'INVALID_CONSUMABLES' | 'EXPIRED_CONSUMABLES' | 'INCORRECT_TEST_TYPE' | 'SAMPLE_OVER_TEMP' | 'SAMPLE_UNDER_TEMP' | 'IMPROPER_SAMPLE_PREPARATION' | 'SAMPLE_CELLULARITY_HIGH' | 'MOTION_ERROR_CARTRIDGE' | 'MOTION_ERROR_MICROSCOPE' | 'UNKNOWN_ERROR' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public removeFault4(
    instrumentId: number,
    faultEnum:
      | "INST_TEMP_LOW"
      | "INST_TEMP_HIGH"
      | "BARCODE_READ_FAILURE"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "INVALID_CONSUMABLES"
      | "EXPIRED_CONSUMABLES"
      | "INCORRECT_TEST_TYPE"
      | "SAMPLE_OVER_TEMP"
      | "SAMPLE_UNDER_TEMP"
      | "IMPROPER_SAMPLE_PREPARATION"
      | "SAMPLE_CELLULARITY_HIGH"
      | "MOTION_ERROR_CARTRIDGE"
      | "MOTION_ERROR_MICROSCOPE"
      | "UNKNOWN_ERROR"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE",
    options?: any
  ) {
    return TheiaApiFp(this.configuration).removeFault4(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Send maintenance result from instrument.
   * @param {number} instrumentId The instrument id.
   * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public sendMaintenanceResult1(
    instrumentId: number,
    body?: InstrumentMaintenanceResultDto,
    options?: any
  ) {
    return TheiaApiFp(this.configuration).sendMaintenanceResult1(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next barcode validation result.
   * @param {number} instrumentId The instrument id.
   * @param {'Cuvettes' | 'Reagent' | 'Sheath' | 'SmartQC' | 'Blood' | 'EarSwab' | 'FNA'} barcodeType The barcode type.
   * @param {NextBarcodeValidationResultDto} [body] The next barcode validation result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public setBarcodeValidation1(
    instrumentId: number,
    barcodeType:
      | "Cuvettes"
      | "Reagent"
      | "Sheath"
      | "SmartQC"
      | "Blood"
      | "EarSwab"
      | "FNA",
    body?: NextBarcodeValidationResultDto,
    options?: any
  ) {
    return TheiaApiFp(this.configuration).setBarcodeValidation1(
      instrumentId,
      barcodeType,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
   * @param {NextTheiaMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TheiaApi
   */
  public setNextMaintenanceResult4(
    instrumentId: number,
    maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
    body?: NextTheiaMaintenanceResultDto,
    options?: any
  ) {
    return TheiaApiFp(this.configuration).setNextMaintenanceResult4(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UrisysDxApi - fetch parameter creator
 * @export
 */
export const UrisysDxApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addFault5."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling addFault5."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {UriSysDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade3(
      instrumentId: number,
      upgradeDetails?: UriSysDxUpgradeInputDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling addUpgrade3."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/upgrade/add`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UriSysDxUpgradeInputDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(upgradeDetails || {})
        : upgradeDetails || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults5(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchFaults5."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/fault`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus3(instrumentId: number, options: any = {}): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling fetchInstrumentStatus3."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/status`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling removeFault5."
        );
      }
      // verify required parameter 'faultEnum' is not null or undefined
      if (faultEnum === null || faultEnum === undefined) {
        throw new RequiredError(
          "faultEnum",
          "Required parameter faultEnum was null or undefined when calling removeFault5."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/fault/{faultEnum}`
        .replace(
          `{${"instrumentId"}}`,
          encodeURIComponent(String(instrumentId))
        )
        .replace(`{${"faultEnum"}}`, encodeURIComponent(String(faultEnum)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult2(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling sendMaintenanceResult2."
        );
      }
      const localVarPath = `/uriSysDx/{instrumentId}/maintenance`.replace(
        `{${"instrumentId"}}`,
        encodeURIComponent(String(instrumentId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"InstrumentMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextUriSysDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult5(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextUriSysDxMaintenanceResultDto,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'instrumentId' is not null or undefined
      if (instrumentId === null || instrumentId === undefined) {
        throw new RequiredError(
          "instrumentId",
          "Required parameter instrumentId was null or undefined when calling setNextMaintenanceResult5."
        );
      }
      // verify required parameter 'maintenanceProcedure' is not null or undefined
      if (maintenanceProcedure === null || maintenanceProcedure === undefined) {
        throw new RequiredError(
          "maintenanceProcedure",
          "Required parameter maintenanceProcedure was null or undefined when calling setNextMaintenanceResult5."
        );
      }
      const localVarPath =
        `/uriSysDx/{instrumentId}/maintenance/{maintenanceProcedure}`
          .replace(
            `{${"instrumentId"}}`,
            encodeURIComponent(String(instrumentId))
          )
          .replace(
            `{${"maintenanceProcedure"}}`,
            encodeURIComponent(String(maintenanceProcedure))
          );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"NextUriSysDxMaintenanceResultDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UrisysDxApi - functional programming interface
 * @export
 */
export const UrisysDxApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).addFault5(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {UriSysDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade3(
      instrumentId: number,
      upgradeDetails?: UriSysDxUpgradeInputDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).addUpgrade3(instrumentId, upgradeDetails, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults5(
      instrumentId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IrisFaultDto>> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).fetchFaults5(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus3(
      instrumentId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<IrisInstrumentStatusDto> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).fetchInstrumentStatus3(instrumentId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IrisFaultDto> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).removeFault5(instrumentId, faultEnum, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult2(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).sendMaintenanceResult2(instrumentId, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextUriSysDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult5(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextUriSysDxMaintenanceResultDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UrisysDxApiFetchParamCreator(
        configuration
      ).setNextMaintenanceResult5(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UrisysDxApi - factory interface
 * @export
 */
export const UrisysDxApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Add a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options?: any
    ) {
      return UrisysDxApiFp(configuration).addFault5(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Add a software upgrade.
     * @param {number} instrumentId The instrument id.
     * @param {UriSysDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUpgrade3(
      instrumentId: number,
      upgradeDetails?: UriSysDxUpgradeInputDto,
      options?: any
    ) {
      return UrisysDxApiFp(configuration).addUpgrade3(
        instrumentId,
        upgradeDetails,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Get the active faults.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchFaults5(instrumentId: number, options?: any) {
      return UrisysDxApiFp(configuration).fetchFaults5(instrumentId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @summary Get the instrument status.
     * @param {number} instrumentId The instrument id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchInstrumentStatus3(instrumentId: number, options?: any) {
      return UrisysDxApiFp(configuration).fetchInstrumentStatus3(
        instrumentId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Remove a fault.
     * @param {number} instrumentId The instrument id.
     * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFault5(
      instrumentId: number,
      faultEnum:
        | "UPDATE_AVAILABLE"
        | "UPDATE_FAILED"
        | "UPDATE_FAILED_CATASTROPHIC"
        | "UNSPECIFIED_ALERT_SYSTEM"
        | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
        | "E7_MISSING_TRAY_ERROR"
        | "E8_TRAY_POSITION_ERROR"
        | "E9_WRONG_TRAY_ERROR"
        | "E10_LIGHT_BARRIER_ERROR"
        | "E11_MOTOR_STEP_ERROR"
        | "E12_OPTICS_ERROR"
        | "E25_SYSTEM_EPROM_ERROR"
        | "E29_DATABASE_ERROR"
        | "E30_SYSTEM_INITIALIZATION_ERROR"
        | "E33_SYSTEM_ERROR"
        | "E100_POWERSUPPLY_ERROR"
        | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
        | "E2_WRONG_STRIP_ERROR"
        | "E3_STRIP_MEASUREMENT_ERROR"
        | "E4_CALIBRATION_ERROR"
        | "E5_CALIBRATION_INVALID_ERROR"
        | "E15_REFERENCE_PAD_BOTTOM_ERROR"
        | "E16_REFERENCE_PAD_TOP_ERROR"
        | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
        | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
      options?: any
    ) {
      return UrisysDxApiFp(configuration).removeFault5(
        instrumentId,
        faultEnum,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Send maintenance result from instrument.
     * @param {number} instrumentId The instrument id.
     * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMaintenanceResult2(
      instrumentId: number,
      body?: InstrumentMaintenanceResultDto,
      options?: any
    ) {
      return UrisysDxApiFp(configuration).sendMaintenanceResult2(
        instrumentId,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @summary Sets the next maintenance result.
     * @param {number} instrumentId The instrument id.
     * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
     * @param {NextUriSysDxMaintenanceResultDto} [body] The next maintenance result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setNextMaintenanceResult5(
      instrumentId: number,
      maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
      body?: NextUriSysDxMaintenanceResultDto,
      options?: any
    ) {
      return UrisysDxApiFp(configuration).setNextMaintenanceResult5(
        instrumentId,
        maintenanceProcedure,
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * UrisysDxApi - object-oriented interface
 * @export
 * @class UrisysDxApi
 * @extends {BaseAPI}
 */
export class UrisysDxApi extends BaseAPI {
  /**
   *
   * @summary Add a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to add.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public addFault5(
    instrumentId: number,
    faultEnum:
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED"
      | "UPDATE_FAILED_CATASTROPHIC"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "E7_MISSING_TRAY_ERROR"
      | "E8_TRAY_POSITION_ERROR"
      | "E9_WRONG_TRAY_ERROR"
      | "E10_LIGHT_BARRIER_ERROR"
      | "E11_MOTOR_STEP_ERROR"
      | "E12_OPTICS_ERROR"
      | "E25_SYSTEM_EPROM_ERROR"
      | "E29_DATABASE_ERROR"
      | "E30_SYSTEM_INITIALIZATION_ERROR"
      | "E33_SYSTEM_ERROR"
      | "E100_POWERSUPPLY_ERROR"
      | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
      | "E2_WRONG_STRIP_ERROR"
      | "E3_STRIP_MEASUREMENT_ERROR"
      | "E4_CALIBRATION_ERROR"
      | "E5_CALIBRATION_INVALID_ERROR"
      | "E15_REFERENCE_PAD_BOTTOM_ERROR"
      | "E16_REFERENCE_PAD_TOP_ERROR"
      | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
      | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
    options?: any
  ) {
    return UrisysDxApiFp(this.configuration).addFault5(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Add a software upgrade.
   * @param {number} instrumentId The instrument id.
   * @param {UriSysDxUpgradeInputDto} [upgradeDetails] The details of the upgrade to be added.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public addUpgrade3(
    instrumentId: number,
    upgradeDetails?: UriSysDxUpgradeInputDto,
    options?: any
  ) {
    return UrisysDxApiFp(this.configuration).addUpgrade3(
      instrumentId,
      upgradeDetails,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the active faults.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public fetchFaults5(instrumentId: number, options?: any) {
    return UrisysDxApiFp(this.configuration).fetchFaults5(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Get the instrument status.
   * @param {number} instrumentId The instrument id.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public fetchInstrumentStatus3(instrumentId: number, options?: any) {
    return UrisysDxApiFp(this.configuration).fetchInstrumentStatus3(
      instrumentId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Remove a fault.
   * @param {number} instrumentId The instrument id.
   * @param {'UPDATE_AVAILABLE' | 'UPDATE_FAILED' | 'UPDATE_FAILED_CATASTROPHIC' | 'UNSPECIFIED_ALERT_SYSTEM' | 'UNSPECIFIED_ALERT_ACKNOWLEDGE' | 'E7_MISSING_TRAY_ERROR' | 'E8_TRAY_POSITION_ERROR' | 'E9_WRONG_TRAY_ERROR' | 'E10_LIGHT_BARRIER_ERROR' | 'E11_MOTOR_STEP_ERROR' | 'E12_OPTICS_ERROR' | 'E25_SYSTEM_EPROM_ERROR' | 'E29_DATABASE_ERROR' | 'E30_SYSTEM_INITIALIZATION_ERROR' | 'E33_SYSTEM_ERROR' | 'E100_POWERSUPPLY_ERROR' | 'E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR' | 'E2_WRONG_STRIP_ERROR' | 'E3_STRIP_MEASUREMENT_ERROR' | 'E4_CALIBRATION_ERROR' | 'E5_CALIBRATION_INVALID_ERROR' | 'E15_REFERENCE_PAD_BOTTOM_ERROR' | 'E16_REFERENCE_PAD_TOP_ERROR' | 'E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR' | 'E27_USER_CALIBRATION_IS_REQUIRED_ERROR'} faultEnum The fault to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public removeFault5(
    instrumentId: number,
    faultEnum:
      | "UPDATE_AVAILABLE"
      | "UPDATE_FAILED"
      | "UPDATE_FAILED_CATASTROPHIC"
      | "UNSPECIFIED_ALERT_SYSTEM"
      | "UNSPECIFIED_ALERT_ACKNOWLEDGE"
      | "E7_MISSING_TRAY_ERROR"
      | "E8_TRAY_POSITION_ERROR"
      | "E9_WRONG_TRAY_ERROR"
      | "E10_LIGHT_BARRIER_ERROR"
      | "E11_MOTOR_STEP_ERROR"
      | "E12_OPTICS_ERROR"
      | "E25_SYSTEM_EPROM_ERROR"
      | "E29_DATABASE_ERROR"
      | "E30_SYSTEM_INITIALIZATION_ERROR"
      | "E33_SYSTEM_ERROR"
      | "E100_POWERSUPPLY_ERROR"
      | "E1_REFERENCE_PAD_ERROR_MIDDLE_ERROR"
      | "E2_WRONG_STRIP_ERROR"
      | "E3_STRIP_MEASUREMENT_ERROR"
      | "E4_CALIBRATION_ERROR"
      | "E5_CALIBRATION_INVALID_ERROR"
      | "E15_REFERENCE_PAD_BOTTOM_ERROR"
      | "E16_REFERENCE_PAD_TOP_ERROR"
      | "E24_COMP_PAD_REMISSIONS_OUT_OF_RANGE_ERROR"
      | "E27_USER_CALIBRATION_IS_REQUIRED_ERROR",
    options?: any
  ) {
    return UrisysDxApiFp(this.configuration).removeFault5(
      instrumentId,
      faultEnum,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Send maintenance result from instrument.
   * @param {number} instrumentId The instrument id.
   * @param {InstrumentMaintenanceResultDto} [body] Maintenance result from instrument.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public sendMaintenanceResult2(
    instrumentId: number,
    body?: InstrumentMaintenanceResultDto,
    options?: any
  ) {
    return UrisysDxApiFp(this.configuration).sendMaintenanceResult2(
      instrumentId,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Sets the next maintenance result.
   * @param {number} instrumentId The instrument id.
   * @param {'SHUTDOWN' | 'INITIALIZE'} maintenanceProcedure The maintenance procedure.
   * @param {NextUriSysDxMaintenanceResultDto} [body] The next maintenance result.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UrisysDxApi
   */
  public setNextMaintenanceResult5(
    instrumentId: number,
    maintenanceProcedure: "SHUTDOWN" | "INITIALIZE",
    body?: NextUriSysDxMaintenanceResultDto,
    options?: any
  ) {
    return UrisysDxApiFp(this.configuration).setNextMaintenanceResult5(
      instrumentId,
      maintenanceProcedure,
      body,
      options
    )(this.fetch, this.basePath);
  }
}
